<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover">
    <title>BGG Player Count Menu</title>
    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; background: #f7f7fa; color: #222; }
        .container { max-width: 430px; margin: 0 auto; padding: 2em 1em 1em 1em; box-sizing: border-box; min-height: 100vh; padding-bottom: env(safe-area-inset-bottom); }
        h1 { font-size: 1.7em; margin-bottom: 1em; text-align: center; }
        
        .form-container { background: #fff; border-radius: 12px; box-shadow: 0 2px 12px #0001; padding: 1.5em; margin-bottom: 1.5em; }
        .form-group { margin-bottom: 1em; }
        .form-label { display: block; font-weight: 600; margin-bottom: 0.5em; color: #333; }
        .form-input { width: 100%; padding: 0.8em; border: 1px solid #ccc; border-radius: 8px; font-size: 1em; box-sizing: border-box; }
        .form-input:focus { outline: none; border-color: #1976d2; box-shadow: 0 0 5px rgba(25, 118, 210, 0.3); }
        
        .submit-btn { width: 100%; background: #1976d2; color: #fff; border: none; border-radius: 8px; padding: 1em; font-size: 1.1em; font-weight: 600; cursor: pointer; margin-top: 0.5em; }
        .submit-btn:hover { background: #1565c0; }
        .submit-btn:disabled { background: #ccc; cursor: not-allowed; }
        
        .loading { text-align: center; color: #888; font-size: 1.1em; margin: 2em 0; }
        .stats { background: #e3f2fd; border-radius: 8px; padding: 1em; margin-bottom: 1em; font-size: 0.95em; }
        
        .game-list { margin-top: 1em; }
        .game-card { background: #fff; border-radius: 12px; box-shadow: 0 2px 12px #0001; margin-bottom: 1em; padding: 1em 1.2em; display: flex; flex-direction: row; align-items: center; position: relative; }
        .game-thumb { width: 64px; height: 64px; border-radius: 10px; margin-right: 1em; object-fit: cover; flex-shrink: 0; }
        .game-info { display: flex; flex-direction: column; flex: 1; }
        .game-title { font-size: 1.1em; font-weight: 600; margin-bottom: 0.2em; }
        .game-details { font-size: 0.98em; color: #555; }
        
        .category-flag { position: absolute; top: 8px; right: 8px; padding: 0.2em 0.5em; border-radius: 12px; font-size: 0.75em; font-weight: 600; color: #fff; }
        .flag-perfect { background: #4caf50; } /* Min=Max players - Perfect fit */
        .flag-best { background: #ff9800; } /* Best at player count */
        .flag-recommended { background: #2196f3; } /* Recommended at player count */
        .flag-supported { background: #9e9e9e; } /* Just supports player count */
        
        .bayes-indicator { position: absolute; bottom: 8px; right: 8px; padding: 0.2em 0.5em; border-radius: 8px; font-size: 0.75em; font-weight: 600; }
        .bayes-excellent { background: rgba(76,175,80,0.9); color: white; } /* 8.0+ */
        .bayes-very-good { background: rgba(139,195,74,0.9); color: white; } /* 7.5+ */
        .bayes-good { background: rgba(255,235,59,0.9); color: black; } /* 7.0+ */
        .bayes-average { background: rgba(255,152,0,0.9); color: white; } /* 6.0+ */
        .bayes-below { background: rgba(244,67,54,0.9); color: white; } /* < 6.0 */
        
        .error { background: #ffebee; color: #c62828; border-radius: 8px; padding: 1em; margin: 1em 0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>BGG Player Count Menu</h1>
        
        <div class="form-container">
            <div class="form-group">
                <label class="form-label" for="username">BGG Username:</label>
                <input type="text" id="username" class="form-input" value="sportomax" placeholder="Enter BGG username">
            </div>
            
            <div class="form-group">
                <label class="form-label" for="playerCount">Player Count:</label>
                <select id="playerCount" class="form-input">
                    <option value="1">1 Player</option>
                    <option value="2">2 Players</option>
                    <option value="3">3 Players</option>
                    <option value="4" selected>4 Players</option>
                    <option value="5">5 Players</option>
                    <option value="6">6 Players</option>
                    <option value="7">7 Players</option>
                    <option value="8">8 Players</option>
                </select>
            </div>
            
            <button id="submitBtn" class="submit-btn">Find Games</button>
                        <!-- <button id="printBtn" class="submit-btn" style="margin-top:0.5em; background:#4caf50;" disabled>ðŸ“„ Print View (Top 100)</button> -->
        </div>
        
        <div id="results"></div>
    </div>

    <script>
        let allGames = [];
        let gameDetails = {};
        let currentSortedGames = []; // Store current sorted games for print view

        // Function to fetch user's BGG collection
        // Function to fetch user's BGG collection
        async function fetchBGGCollection(username) {
            try {
                const response = await fetch(`https://boardgamegeek.com/xmlapi2/collection?username=${username}&own=1&stats=1`);
                if (!response.ok) {
                    if (response.status === 202) {
                        // BGG is processing the request, wait and retry
                        await new Promise(resolve => setTimeout(resolve, 3000));
                        return await fetchBGGCollection(username);
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const xml = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(xml, 'text/xml');
                
                const items = Array.from(doc.querySelectorAll('item'));
                const games = [];
                
                items.forEach(item => {
                    const objectId = item.getAttribute('objectid');
                    const name = item.querySelector('name')?.textContent || 'Unknown';
                    const thumbnail = item.querySelector('thumbnail')?.textContent || '';
                    const year = item.querySelector('yearpublished')?.textContent || '';
                    
                    // Get stats if available
                    const stats = item.querySelector('stats');
                    let minPlayers = '';
                    let maxPlayers = '';
                    let playingTime = '';
                    let bayesAverage = '';
                    
                    if (stats) {
                        minPlayers = stats.getAttribute('minplayers') || '';
                        maxPlayers = stats.getAttribute('maxplayers') || '';
                        playingTime = stats.getAttribute('playingtime') || '';
                        
                        const rating = stats.querySelector('rating');
                        if (rating) {
                            const bayes = rating.querySelector('bayesaverage');
                            if (bayes) {
                                bayesAverage = parseFloat(bayes.getAttribute('value')) || 0;
                            }
                        }
                    }
                    
                    games.push({
                        objectId,
                        name,
                        thumbnail,
                        year,
                        minPlayers: parseInt(minPlayers) || 0,
                        maxPlayers: parseInt(maxPlayers) || 0,
                        playingTime: parseInt(playingTime) || 0,
                        bayesAverage: bayesAverage
                    });
                });
                
                return games;
            } catch (error) {
                console.error('Error fetching collection:', error);
                throw error;
            }
        }
        
        // Function to fetch detailed game info with player count recommendations
        async function fetchGameDetails(objectIds, startTime, initialGames, username, playerCount) {
            const details = {};
            const batchSize = 20; // Increased batch size for thing API calls
            
            for (let i = 0; i < objectIds.length; i += batchSize) {
                const batch = objectIds.slice(i, i + batchSize);
                const idsParam = batch.join(',');
                
                // Update progress with timer
                const resultsDiv = document.getElementById('results');
                const progress = Math.round((i / objectIds.length) * 100);
                const elapsedTime = ((Date.now() - startTime) / 1000).toFixed(1);
                const estimatedTotal = objectIds.length > 0 ? (elapsedTime / (i + batchSize)) * objectIds.length : 0;
                const eta = estimatedTotal > elapsedTime ? (estimatedTotal - elapsedTime).toFixed(1) : '0.0';
                
                // Update the existing basic results with progress info
                const existingStats = resultsDiv.querySelector('.stats');
                if (existingStats) {
                    const progressDiv = resultsDiv.querySelector('.progress-info') || document.createElement('div');
                    progressDiv.className = 'progress-info';
                    progressDiv.style.cssText = 'background:#fff3e0; border-radius:8px; padding:0.8em; margin:0.5em 0; font-size:0.9em; border-left:4px solid #ff9800;';
                    progressDiv.innerHTML = `
                        <strong>ðŸ”„ Enhancing with detailed data...</strong><br>
                        Progress: ${progress}% (${i}/${objectIds.length}) - Batches of ${batchSize}<br>
                        Elapsed: ${elapsedTime}s | ETA: ${eta}s
                    `;
                    
                    if (!resultsDiv.querySelector('.progress-info')) {
                        existingStats.insertAdjacentElement('afterend', progressDiv);
                    }
                }
                
                let retryCount = 0;
                const maxRetries = 3;
                let success = false;
                
                while (retryCount < maxRetries && !success) {
                    try {
                        const response = await fetch(`https://boardgamegeek.com/xmlapi2/thing?id=${idsParam}&stats=1`);
                        
                        if (response.status === 429) {
                            // Rate limited - wait longer and retry
                            const waitTime = Math.min(5000 * (retryCount + 1), 15000); // Exponential backoff up to 15 seconds
                            console.warn(`Rate limited for batch starting at ${i}, waiting ${waitTime/1000} seconds... (attempt ${retryCount + 1}/${maxRetries})`);
                            await new Promise(resolve => setTimeout(resolve, waitTime));
                            retryCount++;
                            continue;
                        }
                        
                        if (!response.ok) {
                            console.warn(`Failed to fetch details for batch starting at ${i}: ${response.status}`);
                            break;
                        }
                        
                        success = true;
                        
                        const xml = await response.text();
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(xml, 'text/xml');
                        
                        const items = Array.from(doc.querySelectorAll('item'));
                        items.forEach(item => {
                            const objectId = item.getAttribute('id');
                            
                            // Get player count polls
                            const playerCountPoll = item.querySelector('poll[name="suggested_numplayers"]');
                            const playerCountData = {};
                            
                            if (playerCountPoll) {
                                const results = Array.from(playerCountPoll.querySelectorAll('results'));
                                results.forEach(result => {
                                    const numPlayers = result.getAttribute('numplayers');
                                    const best = parseInt(result.querySelector('result[value="Best"]')?.getAttribute('numvotes') || '0');
                                    const recommended = parseInt(result.querySelector('result[value="Recommended"]')?.getAttribute('numvotes') || '0');
                                    const notRecommended = parseInt(result.querySelector('result[value="Not Recommended"]')?.getAttribute('numvotes') || '0');
                                    
                                    playerCountData[numPlayers] = {
                                        best,
                                        recommended,
                                        notRecommended,
                                        total: best + recommended + notRecommended
                                    };
                                });
                            }
                            
                            // Get BGG rank and Bayes average from stats
                            let bggRank = '';
                            let bayesAverage = 0;
                            
                            const statistics = item.querySelector('statistics');
                            if (statistics) {
                                const ranks = statistics.querySelectorAll('rank');
                                for (const rank of ranks) {
                                    if (rank.getAttribute('name') === 'boardgame') {
                                        const rankValue = rank.getAttribute('value');
                                        bggRank = rankValue && rankValue !== 'Not Ranked' ? rankValue : '';
                                        break;
                                    }
                                }
                                
                                const bayesElement = statistics.querySelector('bayesaverage');
                                if (bayesElement) {
                                    bayesAverage = parseFloat(bayesElement.getAttribute('value')) || 0;
                                }
                            }
                            
                            details[objectId] = {
                                playerCountData,
                                bggRank,
                                bayesAverage
                            };
                        });
                        
                        // Progressive re-sort and update display after each batch
                        if (i % (batchSize * 2) === 0 || i + batchSize >= objectIds.length) {
                            // Re-categorize games with current details
                            const updatedGames = initialGames.map(game => ({
                                ...game,
                                category: categorizeGame(game, playerCount, details),
                                bayesAverage: details[game.objectId]?.bayesAverage || game.bayesAverage || 0
                            }));
                            
                            // Re-sort with updated categories
                            const reSortedGames = filterAndSortGames(updatedGames, playerCount, details);
                            
                            // Update the display progressively (without changing the progress indicator)
                            updateGameCardsProgressively(reSortedGames, details);
                        }
                        
                    } catch (error) {
                        console.error(`Error fetching details for batch starting at ${i} (attempt ${retryCount + 1}):`, error);
                        retryCount++;
                        if (retryCount < maxRetries) {
                            const waitTime = 3000 * (retryCount + 1); // Progressive delay
                            await new Promise(resolve => setTimeout(resolve, waitTime));
                        }
                    }
                } // End retry loop
                
                // Add longer delay between batches to be more respectful to BGG API
                if (i + batchSize < objectIds.length) {
                    await new Promise(resolve => setTimeout(resolve, 2500)); // Increased from 1000ms to 2500ms
                }
            }
            
            return details;
        }
        
        // Function to categorize games based on player count
        function categorizeGame(game, targetPlayerCount, details) {
            const gameDetails = details[game.objectId];
            if (!gameDetails) return 'supported';
            
            const playerData = gameDetails.playerCountData[targetPlayerCount.toString()];
            if (!playerData) {
                // Check if game supports this player count within min/max range
                if (targetPlayerCount >= game.minPlayers && targetPlayerCount <= game.maxPlayers) {
                    return 'supported';
                }
                return null; // Doesn't support this player count
            }
            
            // Check if min players equals max players and matches target
            if (game.minPlayers === game.maxPlayers && game.minPlayers === targetPlayerCount) {
                return 'perfect';
            }
            
            // Determine category based on voting
            const bestVotes = playerData.best;
            const recommendedVotes = playerData.recommended;
            const notRecommendedVotes = playerData.notRecommended;
            const totalVotes = playerData.total;
            
            if (totalVotes < 3) {
                // Not enough votes, just check if it supports the count
                return 'supported';
            }
            
            // Calculate percentages
            const bestPercent = (bestVotes / totalVotes) * 100;
            const recommendedPercent = (recommendedVotes / totalVotes) * 100;
            
            if (bestPercent >= 50 || (bestVotes > recommendedVotes && bestVotes > notRecommendedVotes)) {
                return 'best';
            } else if ((bestPercent + recommendedPercent) >= 50 || recommendedVotes > notRecommendedVotes) {
                return 'recommended';
            } else {
                return 'supported';
            }
        }
        
        // Function to get Bayes average styling
        function getBayesStyle(bayes) {
            if (bayes >= 8.0) return 'bayes-excellent';
            if (bayes >= 7.5) return 'bayes-very-good';
            if (bayes >= 7.0) return 'bayes-good';
            if (bayes >= 6.0) return 'bayes-average';
            return 'bayes-below';
        }
        
        // Function to filter and sort games
        function filterAndSortGames(games, targetPlayerCount, details) {
            // Filter games that support the target player count
            const filteredGames = games.filter(game => {
                const category = categorizeGame(game, targetPlayerCount, details);
                return category !== null;
            }).map(game => ({
                ...game,
                category: categorizeGame(game, targetPlayerCount, details),
                bayesAverage: details[game.objectId]?.bayesAverage || game.bayesAverage || 0
            }));
            
            // Sort by category priority, then by Bayes average within each category
            const categoryOrder = { 'perfect': 1, 'best': 2, 'recommended': 3, 'supported': 4 };
            
            filteredGames.sort((a, b) => {
                // First sort by category
                if (categoryOrder[a.category] !== categoryOrder[b.category]) {
                    return categoryOrder[a.category] - categoryOrder[b.category];
                }
                
                // Within same category, sort by Bayes average (descending)
                return b.bayesAverage - a.bayesAverage;
            });
            
            return filteredGames;
        }
        
        // Function to update game cards progressively as details come in
        function updateGameCardsProgressively(games, details) {
            const gameList = document.querySelector('.game-list');
            if (!gameList) return;
            
            currentSortedGames = games; // Update stored games for print view
            
            // Clear and rebuild the game list with updated sorting
            let html = '';
            games.forEach((game, index) => {
                const gameDetails = details[game.objectId];
                const flagClass = `flag-${game.category}`;
                const flagText = {
                    'perfect': 'Perfect',
                    'best': 'Best',
                    'recommended': 'Rec',
                    'supported': 'OK',
                    'loading': 'Loading...'
                }[game.category];
                
                const bayesClass = getBayesStyle(game.bayesAverage);
                const bayesText = game.bayesAverage > 0 ? game.bayesAverage.toFixed(2) : 'N/A';
                
                html += `
                    <div class="game-card">
                        <div class="sort-index" style="position:absolute; top:8px; left:8px; background:rgba(0,0,0,0.7); color:white; padding:0.2em 0.5em; border-radius:8px; font-size:0.75em; font-weight:600; z-index:3;">#${index + 1}</div>
                        <div class="category-flag ${flagClass}">${flagText}</div>
                        <div class="bayes-indicator ${bayesClass}">${bayesText}</div>
                        <img src="${game.thumbnail}" alt="${game.name} thumbnail" class="game-thumb" onerror="this.style.display='none'">
                        <div class="game-info">
                            <div class="game-title">${game.name}</div>
                            <div class="game-details">
                                <strong>Year:</strong> ${game.year}<br>
                                <strong>Players:</strong> ${game.minPlayers}${game.minPlayers !== game.maxPlayers ? '-' + game.maxPlayers : ''}<br>
                                <strong>Playing Time:</strong> ${game.playingTime || 'N/A'} min<br>
                                ${gameDetails?.bggRank ? '<strong>BGG Rank:</strong> #' + gameDetails.bggRank + '<br>' : ''}
                                <a href="https://boardgamegeek.com/boardgame/${game.objectId}" target="_blank" style="color:#1976d2;">View on BGG</a>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            gameList.innerHTML = html;
        }
        
        // Function to display basic results immediately (before detailed player count data)
        function displayBasicResults(games, username, playerCount, collectionTime) {
            const resultsDiv = document.getElementById('results');
            currentSortedGames = games; // Store for print view
            
            // Enable print button
            // const printBtn = document.getElementById('printBtn');
            // printBtn.disabled = false;
            // printBtn.style.background = '#4caf50';
            
            const totalGames = games.length;
            
            let html = `
                <div class="stats">
                    <strong>Quick Results for ${username} at ${playerCount} players:</strong><br>
                    Games found: ${totalGames} (basic filter by min/max players)<br>
                    Collection fetch time: ${collectionTime}s<br>
                    <em>Loading detailed player count recommendations...</em>
                </div>
                <div class="game-list">
            `;
            
            games.forEach((game, index) => {
                const bayesClass = getBayesStyle(game.bayesAverage);
                const bayesText = game.bayesAverage > 0 ? game.bayesAverage.toFixed(2) : 'N/A';
                
                html += `
                    <div class="game-card" id="basic-card-${index}">
                        <div class="sort-index" style="position:absolute; top:8px; left:8px; background:rgba(0,0,0,0.7); color:white; padding:0.2em 0.5em; border-radius:8px; font-size:0.75em; font-weight:600; z-index:3;">#${index + 1}</div>
                        <div class="category-flag flag-supported">Loading...</div>
                        <div class="bayes-indicator ${bayesClass}">${bayesText}</div>
                        <img src="${game.thumbnail}" alt="${game.name} thumbnail" class="game-thumb" onerror="this.style.display='none'">
                        <div class="game-info">
                            <div class="game-title">${game.name}</div>
                            <div class="game-details">
                                <strong>Year:</strong> ${game.year}<br>
                                <strong>Players:</strong> ${game.minPlayers}${game.minPlayers !== game.maxPlayers ? '-' + game.maxPlayers : ''}<br>
                                <strong>Playing Time:</strong> ${game.playingTime || 'N/A'} min<br>
                                <em>Loading detailed recommendations...</em><br>
                                <a href="https://boardgamegeek.com/boardgame/${game.objectId}" target="_blank" style="color:#1976d2;">View on BGG</a>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            resultsDiv.innerHTML = html;
        }
        
        // Function to display results
        function displayResults(games, details, username, playerCount, totalTime) {
            const resultsDiv = document.getElementById('results');
            currentSortedGames = games; // Store final sorted games for print view
            
            // Calculate stats
            const totalGames = games.length;
            const categories = games.reduce((acc, game) => {
                acc[game.category] = (acc[game.category] || 0) + 1;
                return acc;
            }, {});
            
            let html = `
                <div class="stats">
                    <strong>âœ… Final Results for ${username} at ${playerCount} players:</strong><br>
                    Total games: ${totalGames}<br>
                    Perfect fit (min=max): ${categories.perfect || 0}<br>
                    Best at player count: ${categories.best || 0}<br>
                    Recommended at player count: ${categories.recommended || 0}<br>
                    Just supported: ${categories.supported || 0}<br>
                    <strong>Total processing time: ${totalTime}s</strong>
                </div>
                <div class="game-list">
            `;
            
            games.forEach((game, index) => {
                const gameDetails = details[game.objectId];
                const flagClass = `flag-${game.category}`;
                const flagText = {
                    'perfect': 'Perfect',
                    'best': 'Best',
                    'recommended': 'Rec',
                    'supported': 'OK'
                }[game.category];
                
                const bayesClass = getBayesStyle(game.bayesAverage);
                const bayesText = game.bayesAverage > 0 ? game.bayesAverage.toFixed(2) : 'N/A';
                
                html += `
                    <div class="game-card">
                        <div class="sort-index" style="position:absolute; top:8px; left:8px; background:rgba(0,0,0,0.7); color:white; padding:0.2em 0.5em; border-radius:8px; font-size:0.75em; font-weight:600; z-index:3;">#${index + 1}</div>
                        <div class="category-flag ${flagClass}">${flagText}</div>
                        <div class="bayes-indicator ${bayesClass}">${bayesText}</div>
                        <img src="${game.thumbnail}" alt="${game.name} thumbnail" class="game-thumb" onerror="this.style.display='none'">
                        <div class="game-info">
                            <div class="game-title">${game.name}</div>
                            <div class="game-details">
                                <strong>Year:</strong> ${game.year}<br>
                                <strong>Players:</strong> ${game.minPlayers}${game.minPlayers !== game.maxPlayers ? '-' + game.maxPlayers : ''}<br>
                                <strong>Playing Time:</strong> ${game.playingTime || 'N/A'} min<br>
                                ${gameDetails?.bggRank ? '<strong>BGG Rank:</strong> #' + gameDetails.bggRank + '<br>' : ''}
                                <a href="https://boardgamegeek.com/boardgame/${game.objectId}" target="_blank" style="color:#1976d2;">View on BGG</a>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            resultsDiv.innerHTML = html;
        }
        
        // Main function to handle form submission
        async function handleSubmit() {
            const username = document.getElementById('username').value.trim();
            const playerCount = parseInt(document.getElementById('playerCount').value);
            const submitBtn = document.getElementById('submitBtn');
            const resultsDiv = document.getElementById('results');
            
            if (!username) {
                alert('Please enter a username');
                return;
            }
            
            submitBtn.disabled = true;
            submitBtn.textContent = 'Loading...';
            const startTime = Date.now();
            
            try {
                // Fetch collection
                resultsDiv.innerHTML = '<div class="loading">Fetching BGG collection...</div>';
                const games = await fetchBGGCollection(username);
                
                if (games.length === 0) {
                    resultsDiv.innerHTML = '<div class="error">No games found in collection or collection is private.</div>';
                    return;
                }
                
                // Filter games by basic player count first (using min/max from collection)
                const basicFilteredGames = games.filter(game => {
                    return playerCount >= game.minPlayers && playerCount <= game.maxPlayers;
                }).map(game => ({
                    ...game,
                    category: 'loading', // Temporary category while we fetch details
                    bayesAverage: game.bayesAverage || 0
                })).sort((a, b) => b.bayesAverage - a.bayesAverage); // Sort by Bayes average initially
                
                // Show basic results immediately
                const collectionTime = ((Date.now() - startTime) / 1000).toFixed(1);
                displayBasicResults(basicFilteredGames, username, playerCount, collectionTime);
                
                // Now fetch detailed player count data in the background
                const objectIds = basicFilteredGames.map(g => g.objectId);
                if (objectIds.length > 0) {
                    const detailsStartTime = Date.now();
                    const details = await fetchGameDetails(objectIds, startTime, basicFilteredGames, username, playerCount);
                    
                    // Re-categorize and re-sort with detailed data
                    const detailedFilteredGames = filterAndSortGames(basicFilteredGames, playerCount, details);
                    
                    // Update display with final results
                    const totalTime = ((Date.now() - startTime) / 1000).toFixed(1);
                    displayResults(detailedFilteredGames, details, username, playerCount, totalTime);
                }
                
            } catch (error) {
                console.error('Error:', error);
                resultsDiv.innerHTML = `<div class="error">Error: ${error.message}</div>`;
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Find Games';
            }
        }

        // Event listeners
        document.getElementById('submitBtn').addEventListener('click', handleSubmit);
        // document.getElementById('printBtn').addEventListener('click', createPrintView);
        
        // Allow Enter key to submit
        document.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleSubmit();
            }
        });
    </script>
</body>
</html>