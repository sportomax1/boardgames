<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover">
    <title>Boardgame Collage</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: #f7f7fa;
            color: #222;
        }
        .container {
            max-width: 430px;
            margin: 0 auto;
            padding: 2em 1em 1em 1em;
            box-sizing: border-box;
            min-height: 100vh;
            padding-bottom: env(safe-area-inset-bottom);
        }
        h1 {
            font-size: 1.7em;
            margin-bottom: 1em;
            text-align: center;
        }
        #searchBar {
            display: flex;
            justify-content: center;
            margin-bottom: 1em;
        }
        #searchInput {
            font-size: 1.1em;
            padding: 0.5em 1em;
            border-radius: 8px;
            border: 1px solid #bbb;
            width: 60%;
            max-width: 180px;
        }
        #searchBtn {
            background: #1976d2;
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 0.7em 2em;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            margin-left: 1em;
        }
        #results {
            margin-bottom: 2em;
        }
        .result-card {
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 2px 12px #0001;
            margin-bottom: 1em;
            padding: 1em 1.2em;
            display: flex;
            flex-direction: row;
            align-items: center;
        }
        .result-thumb {
            width: 64px;
            height: 64px;
            border-radius: 10px;
            margin-right: 1em;
            object-fit: cover;
            flex-shrink: 0;
        }
        .result-info {
            display: flex;
            flex-direction: column;
            flex: 1;
        }
        .result-title {
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 0.2em;
        }
        .result-details {
            font-size: 0.98em;
            color: #555;
        }
        .add-btn {
            background: #1976d2;
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 0.5em 1.2em;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            margin-left: 1em;
        }
        #collageGrid {
            display: grid;
            gap: 0;
            margin-top: 1em;
            margin-bottom: 2em;
        }
        #collageGrid.grid-1 { grid-template-columns: 1fr; }
        #collageGrid.grid-2 { grid-template-columns: repeat(2, 1fr); }
        #collageGrid.grid-3 { grid-template-columns: repeat(3, 1fr); }
        #collageGrid.grid-4 { grid-template-columns: repeat(4, 1fr); }
        #collageGrid.grid-5 { grid-template-columns: repeat(5, 1fr); }
        .collage-item {
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 2px 12px #0001;
            padding: 0.1em;
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: grab;
            position: relative;
        }
        .collage-thumb {
            width: 100%;
            height: auto;
            aspect-ratio: 1;
            border-radius: 8px;
            object-fit: cover;
        }
        .collage-title {
            font-size: 0.9em;
            font-weight: 600;
            text-align: center;
            margin-bottom: 0.2em;
            line-height: 1.2;
            word-break: break-word;
        }
        .remove-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            background: #c00;
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 1em;
            cursor: pointer;
        }
        #exportBtn {
            background: #1976d2;
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 0.7em 2em;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            display: block;
            margin: 0 auto 2em auto;
        }
        #searchModes {
            display: flex;
            justify-content: center;
            margin-bottom: 1em;
            gap: 0.5em;
            flex-wrap: wrap;
        }
        .search-mode-btn {
            background: #e0e0e0;
            color: #555;
            border: none;
            border-radius: 6px;
            padding: 0.4em 1em;
            font-size: 0.9em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 80px;
        }
        .search-mode-btn.active {
            background: #1976d2;
            color: #fff;
        }
        .search-mode-btn:hover {
            background: #1565c0;
            color: #fff;
        }
        
        /* Responsive adjustments */
        @media (max-width: 350px) {
            #collageGrid.grid-4 { grid-template-columns: repeat(3, 1fr); }
            #collageGrid.grid-5 { grid-template-columns: repeat(3, 1fr); }
            .search-mode-btn {
                padding: 0.3em 0.8em;
                font-size: 0.85em;
                min-width: 70px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Boardgame Collage</h1>
        <div id="searchBar">
            <input id="searchInput" type="text" placeholder="Search boardgames...">
            <button id="searchBtn">Search</button>
            <button id="hideSearchBtn" style="background:#bbb; color:#222; border:none; border-radius:8px; padding:0.7em 1.2em; font-size:1.1em; font-weight:600; cursor:pointer; margin-left:1em;">Done</button>
        </div>
        <div id="searchModes" style="display: flex; justify-content: center; margin-bottom: 1em; gap: 0.5em;">
            <button id="containsMode" class="search-mode-btn" data-mode="contains">Contains</button>
            <button id="startsMode" class="search-mode-btn active" data-mode="starts">Starts With</button>
            <button id="exactMode" class="search-mode-btn" data-mode="exact">Exact Match</button>
        </div>
        <div id="results"></div>
        <h2 style="text-align:center; font-size:1.2em; margin-bottom:0.5em;">Collage</h2>
        <div id="collageGrid"></div>
        <button id="exportBtn">Export as Image</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script>
    const searchBtn = document.getElementById('searchBtn');
    const searchInput = document.getElementById('searchInput');
    const hideSearchBtn = document.getElementById('hideSearchBtn');
    const resultsDiv = document.getElementById('results');
    const collageGrid = document.getElementById('collageGrid');
    const exportBtn = document.getElementById('exportBtn');
    let collageGames = [];
    let allResults = [];
    let searchTimeout;
    let currentSearchMode = 'starts'; // 'contains', 'starts', 'exact'
    let thumbnailRequestQueue = [];
    let isProcessingThumbnails = false;
    
    // Rate limiting for thumbnail requests
    const THUMBNAIL_DELAY = 200; // 200ms between requests
    
    // CORS proxy to fetch external images
    const CORS_PROXY = 'https://api.allorigins.win/raw?url=';
    // Alternative: 'https://cors-anywhere.herokuapp.com/'
    // Local proxy server: 'http://localhost:3001/proxy-image?url='
    const LOCAL_PROXY = 'http://localhost:3001/proxy-image?url=';
    
    // Function to process thumbnail requests with rate limiting
    async function processThumbnailQueue() {
        if (isProcessingThumbnails || thumbnailRequestQueue.length === 0) {
            return;
        }
        
        isProcessingThumbnails = true;
        
        while (thumbnailRequestQueue.length > 0) {
            const { result, index } = thumbnailRequestQueue.shift();
            
            try {
                const resp = await fetch(`https://boardgamegeek.com/xmlapi2/thing?id=${result.objectId}`);
                if (resp.ok) {
                    const xmlText = await resp.text();
                    const parser = new window.DOMParser();
                    const doc2 = parser.parseFromString(xmlText, 'text/xml');
                    const thumb = doc2.querySelector('thumbnail');
                    if (thumb) {
                        result.thumbUrl = thumb.textContent;
                        // Update all images with this objectId in the current results
                        document.querySelectorAll(`img[data-object-id="${result.objectId}"]`).forEach(img => {
                            img.src = thumb.textContent;
                            img.style.display = 'block';
                            // Add error handling for failed image loads
                            img.onerror = () => {
                                img.style.display = 'none';
                                console.warn('Failed to load thumbnail for:', result.name);
                            };
                        });
                    }
                } else if (resp.status === 429) {
                    // Rate limited, put it back in queue and wait longer
                    thumbnailRequestQueue.unshift({ result, index });
                    await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds for rate limit
                    continue;
                }
            } catch (err) {
                console.warn('Failed to fetch thumbnail for', result.name, err);
            }
            
            // Wait between requests to avoid rate limiting
            await new Promise(resolve => setTimeout(resolve, THUMBNAIL_DELAY));
        }
        
        isProcessingThumbnails = false;
    }
    // Function to convert external image to data URL using CORS proxy
    async function imageToDataURL(imageUrl) {
        if (!imageUrl || imageUrl.startsWith('data:')) return imageUrl;
        
        try {
            // Method 1: Try direct conversion first (will only work for same-origin images)
            return await new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    try {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        resolve(canvas.toDataURL('image/png'));
                    } catch (e) {
                        reject('Canvas conversion failed');
                    }
                };
                img.onerror = () => reject('Direct method failed');
                img.crossOrigin = 'anonymous';
                img.src = imageUrl;
                
                // Timeout after 5 seconds
                setTimeout(() => reject('Timeout'), 5000);
            });
        } catch (e) {
            console.warn('Image conversion failed for:', imageUrl, e);
            return imageUrl; // Return original URL as fallback
        }
    }

    async function fetchResults(query) {
        if (!query) {
            resultsDiv.innerHTML = '';
            allResults = [];
            return;
        }
        resultsDiv.innerHTML = '<div style="text-align:center; color:#888; font-size:1.1em;">Searching...</div>';
        try {
            const resp = await fetch(`https://boardgamegeek.com/xmlapi2/search?query=${encodeURIComponent(query)}&type=boardgame`);
            if (!resp.ok) throw new Error('Failed to fetch search results');
            const xml = await resp.text();
            const parser = new window.DOMParser();
            const doc = parser.parseFromString(xml, 'text/xml');
            allResults = Array.from(doc.querySelectorAll('item')).map(item => {
                return {
                    name: item.querySelector('name')?.getAttribute('value') || 'Unknown',
                    objectId: item.getAttribute('id') || '',
                    year: item.querySelector('yearpublished')?.getAttribute('value') || '',
                    thumbUrl: '',
                    item
                };
            });
            // Fetch thumbnails async with rate limiting
            allResults.forEach((result, i) => {
                thumbnailRequestQueue.push({ result, index: i });
            });
            
            // Start processing the queue
            processThumbnailQueue();
            renderResults();
        } catch (e) {
            resultsDiv.innerHTML = `<div style='text-align:center; color:#c00;'>Error: ${e.message}</div>`;
            allResults = [];
        }
    }

    function renderResults(filter = '') {
        let filtered = allResults;
        if (filter) {
            const f = filter.toLowerCase();
            filtered = allResults.filter(r => {
                const name = r.name.toLowerCase();
                switch (currentSearchMode) {
                    case 'starts':
                        return name.startsWith(f);
                    case 'exact':
                        return name === f;
                    case 'contains':
                    default:
                        return name.includes(f);
                }
            });
        }
        if (filtered.length === 0) {
            resultsDiv.innerHTML = '<div style="text-align:center; color:#888;">No games found.</div>';
            return;
        }
        let html = '';
        filtered.forEach((result, i) => {
            const imgStyle = result.thumbUrl ? '' : 'display:none;';
            html += `<div class='result-card'>
                <img src='${result.thumbUrl || ''}' alt='' class='result-thumb' data-object-id='${result.objectId}' style='width:64px; height:64px; border-radius:10px; margin-right:1em; object-fit:cover;${imgStyle}' onerror="this.style.display='none';">
                <div class='result-info'>
                    <div class='result-title'>${result.name}</div>
                    <div class='result-details'><b>Year Published:</b> ${result.year || 'N/A'}</div>
                </div>
                <button class='add-btn' data-object-id='${result.objectId}'>Add</button>
            </div>`;
        });
        resultsDiv.innerHTML = html;
        document.querySelectorAll('.add-btn').forEach(btn => {
            btn.onclick = () => {
                const objectId = btn.getAttribute('data-object-id');
                const result = allResults.find(r => r.objectId === objectId);
                if (result) {
                    collageGames.push({ name: result.name, objectId: result.objectId, thumbUrl: result.thumbUrl });
                    renderCollage();
                }
            };
        });
    }

    searchBtn.onclick = () => {
        fetchResults(searchInput.value.trim());
    };

    // Real-time search with debouncing
    searchInput.addEventListener('input', () => {
        clearTimeout(searchTimeout);
        const query = searchInput.value.trim();
        
        if (query.length === 0) {
            resultsDiv.innerHTML = '';
            allResults = [];
            return;
        }
        
        // If we already have results, filter them immediately for better UX
        if (allResults.length > 0) {
            renderResults(query);
        }
        
        // Debounce API calls to avoid too many requests
        searchTimeout = setTimeout(() => {
            fetchResults(query);
        }, 500);
    });

    hideSearchBtn.onclick = () => {
        document.getElementById('searchBar').style.display = 'none';
        document.getElementById('searchModes').style.display = 'none';
        resultsDiv.style.display = 'none';
    };

    // Search mode toggle functionality
    document.querySelectorAll('.search-mode-btn').forEach(btn => {
        btn.onclick = () => {
            // Update active state
            document.querySelectorAll('.search-mode-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            // Update current search mode
            currentSearchMode = btn.getAttribute('data-mode');
            
            // Re-filter current results if there's a search query
            const query = searchInput.value.trim();
            if (query && allResults.length > 0) {
                renderResults(query);
            }
        };
    });

    function renderCollage() {
        collageGrid.innerHTML = '';
        
        // Dynamically set grid columns based on number of items
        const itemCount = collageGames.length;
        let gridClass = 'grid-3'; // default
        
        if (itemCount === 0) {
            gridClass = 'grid-1';
        } else if (itemCount === 1) {
            gridClass = 'grid-1';
        } else if (itemCount <= 4) {
            gridClass = 'grid-2';
        } else if (itemCount <= 9) {
            gridClass = 'grid-3';
        } else if (itemCount <= 16) {
            gridClass = 'grid-4';
        } else {
            gridClass = 'grid-5';
        }
        
        // Remove all grid classes and add the appropriate one
        collageGrid.className = '';
        collageGrid.classList.add(gridClass);
        
        collageGames.forEach((game, idx) => {
            const div = document.createElement('div');
            div.className = 'collage-item';
            div.draggable = true;
            div.innerHTML = `
                <img src='${game.thumbUrl}' alt='${game.name} thumbnail' class='collage-thumb' onerror="this.style.display='none'">
                <button class='remove-btn' title='Remove'>&times;</button>
            `;
            // Remove button
            div.querySelector('.remove-btn').onclick = () => {
                collageGames.splice(idx, 1);
                renderCollage();
            };
            // Drag and drop
            div.addEventListener('dragstart', e => {
                e.dataTransfer.setData('text/plain', idx);
            });
            div.addEventListener('dragover', e => {
                e.preventDefault();
            });
            div.addEventListener('drop', e => {
                e.preventDefault();
                const fromIdx = parseInt(e.dataTransfer.getData('text/plain'));
                if (fromIdx !== idx) {
                    const moved = collageGames.splice(fromIdx, 1)[0];
                    collageGames.splice(idx, 0, moved);
                    renderCollage();
                }
            });
            collageGrid.appendChild(div);
        });
    }

    exportBtn.onclick = async () => {
        try {
            // Hide remove buttons during export
            const removeButtons = collageGrid.querySelectorAll('.remove-btn');
            removeButtons.forEach(btn => btn.style.display = 'none');
            
            // For export, we'll create a clean version of the collage without CORS issues
            const exportGrid = collageGrid.cloneNode(true);
            exportGrid.style.position = 'absolute';
            exportGrid.style.top = '-9999px';
            exportGrid.style.left = '-9999px';
            document.body.appendChild(exportGrid);
            
            // Replace all images with placeholder or simplified versions
            const images = exportGrid.querySelectorAll('img');
            const conversionPromises = Array.from(images).map(async (img, index) => {
                try {
                    // Create a simple colored rectangle as fallback
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width || 150;
                    canvas.height = img.height || 150;
                    
                    // Try to load the image, but fallback to colored rectangle
                    try {
                        if (img.src && !img.src.startsWith('data:')) {
                            // Create a new image element for conversion
                            const tempImg = new Image();
                            await new Promise((resolve, reject) => {
                                tempImg.onload = () => {
                                    try {
                                        ctx.drawImage(tempImg, 0, 0, canvas.width, canvas.height);
                                        resolve();
                                    } catch (e) {
                                        reject(e);
                                    }
                                };
                                tempImg.onerror = reject;
                                tempImg.crossOrigin = 'anonymous';
                                tempImg.src = img.src;
                                
                                // Timeout after 3 seconds
                                setTimeout(() => reject('timeout'), 3000);
                            });
                        } else {
                            throw new Error('No valid source');
                        }
                    } catch (e) {
                        // Fallback: create a colored rectangle with game info
                        const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF'];
                        const color = colors[index % colors.length];
                        
                        ctx.fillStyle = color;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Add game name if available
                        const gameName = img.alt || 'Board Game';
                        ctx.fillStyle = '#000';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(gameName, canvas.width / 2, canvas.height / 2);
                    }
                    
                    // Replace the image src with the canvas data URL
                    img.src = canvas.toDataURL('image/png');
                    console.log('Converted image', index + 1, 'of', images.length);
                    
                } catch (e) {
                    console.warn('Failed to convert image:', e);
                }
            });
            
            await Promise.allSettled(conversionPromises);
            
            // Small delay to ensure DOM updates
            await new Promise(resolve => setTimeout(resolve, 200));
            
            // Export the clean grid
            const canvas = await html2canvas(exportGrid, {
                allowTaint: false,
                useCORS: false,
                backgroundColor: '#f7f7fa',
                scale: 2,
                logging: false,
                width: exportGrid.offsetWidth,
                height: exportGrid.offsetHeight
            });
            
            // Clean up the temporary element
            document.body.removeChild(exportGrid);
            
            // Restore remove buttons
            removeButtons.forEach(btn => btn.style.display = '');
            
            const link = document.createElement('a');
            link.download = 'boardgame-collage.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
            
            console.log('Export completed successfully!');
            
        } catch (error) {
            console.error('Export failed:', error);
            alert('Export failed: ' + error.message + '. The export will use colored placeholders for images that failed to load.');
            
            // Restore remove buttons even if export fails
            const removeButtons = collageGrid.querySelectorAll('.remove-btn');
            removeButtons.forEach(btn => btn.style.display = '');
            
            // Clean up any temporary elements
            const tempGrid = document.querySelector('body > div[style*="position: absolute"]');
            if (tempGrid) {
                document.body.removeChild(tempGrid);
            }
        }
    };
    </script>
</body>
</html>
