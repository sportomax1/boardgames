<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover">
    <title>Virtual Flea Market (VFM)</title>
    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; background: #f7f7fa; color: #222; }
        .container { max-width: 430px; margin: 0 auto; padding: 2em 1em 1em 1em; box-sizing: border-box; min-height: 100vh; padding-bottom: env(safe-area-inset-bottom); }
        h1 { font-size: 1.7em; margin-bottom: 1em; text-align: center; }
        .game-list { margin-top: 1em; }
        .game-card { background: #fff; border-radius: 12px; box-shadow: 0 2px 12px #0001; margin-bottom: 1em; padding: 1em 1.2em; display: flex; flex-direction: row; align-items: center; }
        .game-thumb { width: 64px; height: 64px; border-radius: 10px; margin-right: 1em; object-fit: cover; flex-shrink: 0; }
        .game-info { display: flex; flex-direction: column; flex: 1; }
        .game-title { font-size: 1.1em; font-weight: 600; margin-bottom: 0.2em; }
        .game-details { font-size: 0.98em; color: #555; }
        .geeklist-label { font-size: 0.95em; color: #1976d2; margin-bottom: 0.2em; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Virtual Flea Market (VFM)</h1>
        <div style="margin-bottom:1em; text-align:center; display:flex; flex-direction:row; justify-content:center; align-items:center; gap:0.7em; flex-wrap:wrap;">
            <button id="analyticsBtn" style="background:#43a047; color:#fff; border:none; border-radius:10px; padding:0.7em 1.4em; font-size:1em; font-weight:600; cursor:pointer; min-height:44px; -webkit-appearance:none; appearance:none;">Analytics</button>
            <button id="statusFilterBtn" style="background:#1976d2; color:#fff; border:none; border-radius:10px; padding:0.7em 1.4em; font-size:1em; font-weight:600; cursor:pointer; min-height:44px; -webkit-appearance:none; appearance:none;">Filter by Status</button>
            <button id="geeklistFilterBtn" style="background:#8e24aa; color:#fff; border:none; border-radius:10px; padding:0.7em 1.4em; font-size:1em; font-weight:600; cursor:pointer; min-height:44px; -webkit-appearance:none; appearance:none;">Select Geeklists</button>
            <select id="statusFilterSelect" style="font-size:1em; padding:0.6em 1em; border-radius:10px; border:1px solid #bbb; display:none; min-height:44px; -webkit-appearance:none; appearance:none;">
                <option value="">All</option>
                <option value="own">✅ Own</option>
                <option value="wanttoplay">🎮 Want to Play</option>
                <option value="wanttobuy">🛒 Want to Buy</option>
                <option value="wantintrade">🔄 Want in Trade</option>
                <option value="prevowned">⏪ Previously Owned</option>
                <option value="tradingaway">📤 Trading Away</option>
            </select>
        </div>
        <div id="geeklistFilterPanel" style="display:none; background:#f7f7fa; border-radius:10px; padding:1em; margin-bottom:1em; border:2px solid #8e24aa;">
            <div style="font-weight:600; margin-bottom:0.7em; color:#8e24aa;">Select Geeklists to Include:</div>
            <div id="geeklistCheckboxes" style="display:grid; grid-template-columns:1fr; gap:0.5em;"></div>
            <div style="margin-top:1em; display:flex; gap:0.5em; justify-content:center;">
                <button id="selectAllGeeklists" style="background:#43a047; color:#fff; border:none; border-radius:8px; padding:0.5em 1em; font-size:0.9em; cursor:pointer;">Select All</button>
                <button id="deselectAllGeeklists" style="background:#ff4136; color:#fff; border:none; border-radius:8px; padding:0.5em 1em; font-size:0.9em; cursor:pointer;">Deselect All</button>
                <button id="applyGeeklistFilter" style="background:#8e24aa; color:#fff; border:none; border-radius:8px; padding:0.5em 1em; font-size:0.9em; cursor:pointer; font-weight:600;">Apply Filter</button>
            </div>
        </div>
        <!-- <div id="emojiDesc" style="background:#f7f7fa; border-radius:8px; padding:0.7em 1em; font-size:1em; color:#333; margin-bottom:1em;">
            <b>Status Emoji Legend:</b><br>
            ✅ Own &mdash; You own this game<br>
            🎮 Want to Play &mdash; You want to play this game<br>
            🛒 Want to Buy &mdash; You want to buy this game<br>
            🔄 Want in Trade &mdash; You want to trade for this game<br>
            ⏪ Previously Owned &mdash; You previously owned this game<br>
            📤 Trading Away &mdash; You are trading away this game<br>
        </div> -->
        <div id="filterBar" style="margin-bottom:1em; text-align:center;">
            <input id="filterInput" type="text" placeholder="Filter by name..." style="font-size:1.1em; padding:0.6em 1em; border-radius:10px; border:1px solid #bbb; width:70%; max-width:200px; margin-bottom:0.7em; -webkit-appearance:none; appearance:none;">
            <div style="display:flex; justify-content:center; gap:0.4em; flex-wrap:wrap;">
                <button id="exactMatchBtn" data-mode="exact" style="background:#ccc; color:#333; border:none; border-radius:8px; padding:0.5em 1em; font-size:0.9em; min-height:36px; cursor:pointer; font-weight:500; -webkit-appearance:none; appearance:none;">Exact Match</button>
                <button id="startsWithBtn" data-mode="startswith" style="background:#ccc; color:#333; border:none; border-radius:8px; padding:0.5em 1em; font-size:0.9em; min-height:36px; cursor:pointer; font-weight:500; -webkit-appearance:none; appearance:none;">Starts With</button>
                <button id="containsBtn" data-mode="contains" style="background:#1976d2; color:#fff; border:none; border-radius:8px; padding:0.5em 1em; font-size:0.9em; min-height:36px; cursor:pointer; font-weight:500; -webkit-appearance:none; appearance:none;">Contains</button>
            </div>
        </div>
        <div id="gamesCardWrapper">
            <div style="text-align:center; color:#888; font-size:1.1em;">Loading VFM Geeklists...</div>
        </div>
        <div id="loadMoreWrapper" style="text-align:center; margin:1em 0;"></div>
    </div>
    <script>
    const geeklists = [
        { id: 363504, name: "BGG.CON VFM 2025" },
        { id: 342440, name: "BGG.CON VFM 2024" },
        { id: 321725, name: "BGG.CON VFM 2023" },
        { id: 349103, name: "DTW VFM 2025" },
        { id: 328677, name: "DTW VFM 2024" },
        { id: 308714, name: "DTW VFM 2023" }
    ];
    const gamesCardWrapper = document.getElementById('gamesCardWrapper');
    async function fetchThingDetails(objectId) {
        if (!objectId) return {};
        try {
            const resp = await fetch(`https://boardgamegeek.com/xmlapi2/thing?id=${objectId}`);
            if (!resp.ok) return {};
            const xml = await resp.text();
            const parser = new window.DOMParser();
            const doc = parser.parseFromString(xml, 'text/xml');
            const thumb = doc.querySelector('thumbnail');
            const year = doc.querySelector('yearpublished');
            const desc = doc.querySelector('description');
            return {
                thumbnail: thumb ? thumb.textContent : '',
                year: year ? year.textContent : '',
                description: desc ? desc.textContent : ''
            };
        } catch {
            return {};
        }
    }
    let allItems = [];
    let userCollection = new Set();
    let userWantToPlay = new Set();
    let userWantToBuy = new Set();
    let userWantInTrade = new Set();
    let userPrevOwned = new Set();
    let userTradingAway = new Set();
    let loadedCount = 0;
    const PAGE_SIZE = 50;
    let loading = false;
    let currentStatusFilter = '';
    let currentFilterMode = 'contains'; // Default to contains
    let selectedGeeklists = new Set(geeklists.map(g => g.id)); // Start with all selected
    const loadMoreWrapper = document.getElementById('loadMoreWrapper');
    const filterInput = document.getElementById('filterInput');

    async function fetchAllGeeklists() {
        // Fetch user's want to play
        try {
            const resp = await fetch('https://boardgamegeek.com/xmlapi2/collection?username=sportomax&wanttoplay=1');
            if (resp.ok) {
                const xml = await resp.text();
                const parser = new window.DOMParser();
                const doc = parser.parseFromString(xml, 'text/xml');
                const items = Array.from(doc.querySelectorAll('item'));
                userWantToPlay = new Set(items.map(i => i.getAttribute('objectid')));
            }
        } catch {}
        // Fetch user's want to buy
        try {
            const resp = await fetch('https://boardgamegeek.com/xmlapi2/collection?username=sportomax&wanttobuy=1');
            if (resp.ok) {
                const xml = await resp.text();
                const parser = new window.DOMParser();
                const doc = parser.parseFromString(xml, 'text/xml');
                const items = Array.from(doc.querySelectorAll('item'));
                userWantToBuy = new Set(items.map(i => i.getAttribute('objectid')));
            }
        } catch {}
        // Fetch user's want in trade
        try {
            const resp = await fetch('https://boardgamegeek.com/xmlapi2/collection?username=sportomax&want=trade');
            if (resp.ok) {
                const xml = await resp.text();
                const parser = new window.DOMParser();
                const doc = parser.parseFromString(xml, 'text/xml');
                const items = Array.from(doc.querySelectorAll('item'));
                userWantInTrade = new Set(items.map(i => i.getAttribute('objectid')));
            }
        } catch {}
        // Fetch user's previously owned
        try {
            const resp = await fetch('https://boardgamegeek.com/xmlapi2/collection?username=sportomax&prevowned=1');
            if (resp.ok) {
                const xml = await resp.text();
                const parser = new window.DOMParser();
                const doc = parser.parseFromString(xml, 'text/xml');
                const items = Array.from(doc.querySelectorAll('item'));
                userPrevOwned = new Set(items.map(i => i.getAttribute('objectid')));
            }
        } catch {}
        // Fetch user's trading away
        try {
            const resp = await fetch('https://boardgamegeek.com/xmlapi2/collection?username=sportomax&fortrade=1');
            if (resp.ok) {
                const xml = await resp.text();
                const parser = new window.DOMParser();
                const doc = parser.parseFromString(xml, 'text/xml');
                const items = Array.from(doc.querySelectorAll('item'));
                userTradingAway = new Set(items.map(i => i.getAttribute('objectid')));
            }
        } catch {}
        // Fetch user's collection first
        try {
            const resp = await fetch('https://boardgamegeek.com/xmlapi2/collection?username=sportomax&own=1');
            if (resp.ok) {
                const xml = await resp.text();
                const parser = new window.DOMParser();
                const doc = parser.parseFromString(xml, 'text/xml');
                const items = Array.from(doc.querySelectorAll('item'));
                userCollection = new Set(items.map(i => i.getAttribute('objectid')));
            }
        } catch {}
        gamesCardWrapper.innerHTML = '<div style="text-align:center; color:#888; font-size:1.1em;" id="loadingStatus">Loading VFM Geeklists...</div>';
        allItems = [];
        loadedCount = 0;
        loading = true;
        
        const loadingStatus = document.getElementById('loadingStatus');
        
        for (let g = 0; g < geeklists.length; g++) {
            const geeklist = geeklists[g];
            loadingStatus.innerHTML = `Loading ${geeklist.name}...`;
            console.log(`Fetching geeklist: ${geeklist.name} (ID: ${geeklist.id})`);
            
            let retryCount = 0;
            // BGG Con VFM 25 needs more retries due to smaller volume but frequent issues
            const maxRetries = geeklist.name.includes('BGG.CON VFM 2025') ? 5 : 3;
            let success = false;
            
            while (retryCount < maxRetries && !success) {
                try {
                    const resp = await fetch(`https://boardgamegeek.com/xmlapi/geeklist/${geeklist.id}`);
                    console.log(`Response status for ${geeklist.name}:`, resp.status);
                    
                    if (resp.status === 202) {
                        const waitTime = geeklist.name.includes('BGG.CON VFM 2025') ? 5000 : 3000; // Extra wait for BGG Con
                        console.log(`BGG still processing ${geeklist.name}, waiting ${waitTime/1000} seconds... (attempt ${retryCount + 1}/${maxRetries})`);
                        loadingStatus.innerHTML = `${geeklist.name}: BGG processing, waiting... (${retryCount + 1}/${maxRetries})`;
                        retryCount++;
                        if (retryCount < maxRetries) {
                            await new Promise(resolve => setTimeout(resolve, waitTime));
                            continue;
                        } else {
                            console.error(`Failed to fetch ${geeklist.name}: BGG processing timeout after ${maxRetries} attempts`);
                            loadingStatus.innerHTML = `${geeklist.name}: Timeout, skipping...`;
                            await new Promise(resolve => setTimeout(resolve, 1000));
                            break;
                        }
                    }
                    
                    if (!resp.ok) {
                        console.error(`Failed to fetch ${geeklist.name}: ${resp.status} ${resp.statusText}`);
                        break;
                    }
                    
                    const xml = await resp.text();
                    console.log(`XML length for ${geeklist.name}:`, xml.length);
                    
                    // Check if XML contains actual data
                    if (xml.length < 100) {
                        console.warn(`${geeklist.name}: XML too short, might be empty response`);
                        loadingStatus.innerHTML = `${geeklist.name}: Empty response, retrying... (${retryCount + 1}/${maxRetries})`;
                        retryCount++;
                        if (retryCount < maxRetries) {
                            const retryWait = geeklist.name.includes('BGG.CON VFM 2025') ? 4000 : 2000;
                            await new Promise(resolve => setTimeout(resolve, retryWait));
                            continue;
                        } else {
                            loadingStatus.innerHTML = `${geeklist.name}: Failed, skipping...`;
                            await new Promise(resolve => setTimeout(resolve, 1000));
                            break;
                        }
                    }
                    
                    const parser = new window.DOMParser();
                    const doc = parser.parseFromString(xml, 'text/xml');
                    
                    // Check for XML parsing errors
                    const parseError = doc.querySelector('parsererror');
                    if (parseError) {
                        console.error(`XML parse error for ${geeklist.name}:`, parseError.textContent);
                        loadingStatus.innerHTML = `${geeklist.name}: Parse error, retrying... (${retryCount + 1}/${maxRetries})`;
                        retryCount++;
                        if (retryCount < maxRetries) {
                            const retryWait = geeklist.name.includes('BGG.CON VFM 2025') ? 4000 : 2000;
                            await new Promise(resolve => setTimeout(resolve, retryWait));
                            continue;
                        } else {
                            loadingStatus.innerHTML = `${geeklist.name}: Parse failed, skipping...`;
                            await new Promise(resolve => setTimeout(resolve, 1000));
                            break;
                        }
                    }
                    
                    const items = Array.from(doc.querySelectorAll('item'));
                    console.log(`Items found in ${geeklist.name}:`, items.length);
                    
                    for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    allItems.push({
                        geeklistName: geeklist.name,
                        geeklistId: geeklist.id,
                        name: item.getAttribute('objectname') || 'Unknown',
                        objectType: item.getAttribute('objecttype') || '',
                        objectId: item.getAttribute('objectid') || '',
                        postdate: item.getAttribute('postdate') || '',
                        comments: item.getAttribute('comments') || '',
                        details: null,
                        item
                    });
                }
                success = true; // Mark as successful
            } catch (e) {
                console.error(`Error fetching geeklist ${geeklist.name} (attempt ${retryCount + 1}):`, e);
                retryCount++;
                if (retryCount < maxRetries) {
                    const retryWait = geeklist.name.includes('BGG.CON VFM 2025') ? 4000 : 2000;
                    console.log(`Retrying ${geeklist.name} in ${retryWait/1000} seconds...`);
                    await new Promise(resolve => setTimeout(resolve, retryWait));
                } else {
                    console.error(`Failed to fetch ${geeklist.name} after ${maxRetries} attempts`);
                }
            }
            } // End retry loop
        }
        // Sort by postdate descending
        allItems.sort((a, b) => {
            const da = new Date(a.postdate);
            const db = new Date(b.postdate);
            return db - da;
        });
        console.log(`Total items loaded from all geeklists: ${allItems.length}`);
        console.log('Items per geeklist:', geeklists.map(g => ({
            name: g.name,
            count: allItems.filter(item => item.geeklistId === g.id).length
        })));
        loading = false;
        renderItems();
    }

    function renderItems(filter = '') {
        let filtered = allItems.filter(item => selectedGeeklists.has(item.geeklistId));
        
        if (filter) {
            const f = filter.toLowerCase();
            filtered = filtered.filter(r => {
                const name = r.name.toLowerCase();
                if (currentFilterMode === 'exact') {
                    return name === f;
                } else if (currentFilterMode === 'startswith') {
                    return name.startsWith(f);
                } else { // contains (default)
                    return name.includes(f);
                }
            });
        }
        // Filter by emoji status if set
        if (currentStatusFilter) {
            filtered = filtered.filter(item => {
                if (!item.objectId) return false;
                if (currentStatusFilter === 'own') return userCollection.has(item.objectId);
                if (currentStatusFilter === 'wanttoplay') return userWantToPlay.has(item.objectId);
                if (currentStatusFilter === 'wanttobuy') return userWantToBuy.has(item.objectId);
                if (currentStatusFilter === 'wantintrade') return userWantInTrade.has(item.objectId);
                if (currentStatusFilter === 'prevowned') return userPrevOwned.has(item.objectId);
                if (currentStatusFilter === 'tradingaway') return userTradingAway.has(item.objectId);
                return false;
            });
        }
        const toShow = filtered.slice(0, loadedCount + PAGE_SIZE);
        let html = '';
        toShow.forEach((item, idx) => {
            // Extract seller name from username attribute
            const seller = item.item.getAttribute('username') || '';
            // Extract price and type from body text
            let price = '';
            let priceType = '';
            const bodyNode = item.item.querySelector('body');
            if (bodyNode) {
                const bodyText = bodyNode.textContent;
                // Try to extract [FP:] $xx or $xx
                const fpMatch = bodyText.match(/\[FP:?\][^$]*\$([0-9]+(?:\.[0-9]{2})?)/i);
                if (fpMatch) {
                    price = `$${fpMatch[1]}`;
                    priceType = 'Fixed Price';
                } else {
                    // BIN
                    const binMatch = bodyText.match(/BIN[^$]*\$([0-9]+(?:\.[0-9]{2})?)/i);
                    if (binMatch) {
                        price = `$${binMatch[1]}`;
                        priceType = 'Buy It Now';
                    } else {
                        // Starting Bid
                        const sbMatch = bodyText.match(/Starting Bid[^$]*\$([0-9]+(?:\.[0-9]{2})?)/i);
                        if (sbMatch) {
                            price = `$${sbMatch[1]}`;
                            priceType = 'Starting Bid';
                        } else {
                            // Sold
                            const soldMatch = bodyText.match(/Sold[^$]*\$([0-9]+(?:\.[0-9]{2})?)/i);
                            if (soldMatch) {
                                price = `$${soldMatch[1]}`;
                                priceType = 'Sold';
                            } else {
                                // Available
                                const availMatch = bodyText.match(/Available[^$]*\$([0-9]+(?:\.[0-9]{2})?)/i);
                                if (availMatch) {
                                    price = `$${availMatch[1]}`;
                                    priceType = 'Available';
                                } else {
                                    // Fallback: any $xx
                                    const dollarMatch = bodyText.match(/\$([0-9]+(?:\.[0-9]{2})?)/);
                                    if (dollarMatch) {
                                        price = `$${dollarMatch[1]}`;
                                        priceType = '';
                                    }
                                }
                            }
                        }
                    }
                }
            }
            // Card border color by year
            let borderColor = '';
            const year = String(item.geeklistName).match(/(202[3-5])/);
            if (year) {
                if (year[1] === '2025') borderColor = '3px solid #2ecc40'; // green
                else if (year[1] === '2024') borderColor = '3px solid #ffe066'; // yellow
                else borderColor = '3px solid #ff4136'; // red
            } else {
                borderColor = '3px solid #ff4136'; // default to red
            }
            // Determine all applicable collection status emojis
            let statusEmojis = [];
            let statusTitles = [];
            if (item.objectId) {
                if (userCollection.has(item.objectId)) { 
                    statusEmojis.push('✅'); 
                    statusTitles.push('Own'); 
                }
                if (userWantToPlay.has(item.objectId)) { 
                    statusEmojis.push('🎮'); 
                    statusTitles.push('Want to Play'); 
                }
                if (userWantToBuy.has(item.objectId)) { 
                    statusEmojis.push('🛒'); 
                    statusTitles.push('Want to Buy'); 
                }
                if (userWantInTrade.has(item.objectId)) { 
                    statusEmojis.push('🔄'); 
                    statusTitles.push('Want in Trade'); 
                }
                if (userPrevOwned.has(item.objectId)) { 
                    statusEmojis.push('⏪'); 
                    statusTitles.push('Previously Owned'); 
                }
                if (userTradingAway.has(item.objectId)) { 
                    statusEmojis.push('📤'); 
                    statusTitles.push('Trading Away'); 
                }
            }
            
            // Create combined emoji string and title
            const statusEmoji = statusEmojis.join('');
            const statusTitle = statusTitles.join(', ');
            
            // Calculate time since posting (only if within last 24 hours)
            let timeIndicator = '';
            if (item.postdate) {
                const postDate = new Date(item.postdate);
                const now = new Date();
                const diffMs = now - postDate;
                const diffHours = diffMs / (1000 * 60 * 60);
                
                if (diffHours <= 24) {
                    if (diffHours < 1) {
                        const diffMinutes = Math.floor(diffMs / (1000 * 60));
                        timeIndicator = `<span style='position:absolute; bottom:8px; right:12px; background:rgba(233,30,99,0.9); color:white; padding:0.2em 0.5em; border-radius:12px; font-size:0.75em; font-weight:600; z-index:2;'>${diffMinutes}m ago</span>`;
                    } else {
                        const hours = Math.floor(diffHours);
                        timeIndicator = `<span style='position:absolute; bottom:8px; right:12px; background:rgba(233,30,99,0.9); color:white; padding:0.2em 0.5em; border-radius:12px; font-size:0.75em; font-weight:600; z-index:2;'>${hours}h ago</span>`;
                    }
                }
            }
            
            html += `<div class='game-card' id='vfmcard-${idx}' style='border:${borderColor}; position:relative;'>
                ${statusEmoji ? `<span style='position:absolute; top:8px; right:12px; font-size:1.4em; z-index:2; line-height:1; letter-spacing:-2px;' title='${statusTitle}'>${statusEmoji}</span>` : ''}
                ${timeIndicator}
                <img src='' alt='' class='game-thumb' style='width:64px; height:64px; border-radius:10px; margin-right:1em; object-fit:cover; display:none;'>
                <div class='game-info'>
                    <div class='game-title'>${item.name}</div>
                    <div class='geeklist-label'>${item.geeklistName}</div>
                    <div class='game-details'>
                        <b>Seller:</b> ${seller}<br>
                        <b>Price:</b> ${price || 'N/A'}${priceType ? ` <span style='font-size:0.95em; color:#1976d2;'>(${priceType})</span>` : ''}<br>
                        <b>Post Date:</b> ${item.postdate ? new Date(item.postdate).toLocaleString() : 'N/A'}
                        ${item.comments ? ` (<b>${item.comments}</b> comments)` : ''}<br>
                        ${item.objectId ? `<a href='https://boardgamegeek.com/boardgame/${item.objectId}' target='_blank' style='color:#1976d2;'>View on BGG</a>` : ''}<br>
                        <a href='https://boardgamegeek.com/geeklist/${item.geeklistId}?itemid=${item.item.getAttribute('id')}' target='_blank' style='color:#1976d2;'>View Geeklisting</a><br>
                        <button class='viewDetailBtn' data-idx='${idx}' style='margin-top:0.7em; background:#1976d2; color:#fff; font-size:1em; padding:0.5em 1.2em; border-radius:8px; border:none; width:100%; max-width:180px;'>View Details</button>
                    </div>
                </div>
            </div>`;
        });
        gamesCardWrapper.innerHTML = html;
        // Show loading indicator if still loading
        if (loading) {
            loadMoreWrapper.innerHTML = '<div style="text-align:center; color:#888; font-size:1.1em;">Loading...</div>';
        } else if (toShow.length < filtered.length) {
            loadMoreWrapper.innerHTML = `<button id='loadMoreBtn' style='background:#1976d2; color:#fff; border:none; border-radius:8px; padding:0.7em 2em; font-size:1.1em; font-weight:600; cursor:pointer;'>Load More</button>`;
            document.getElementById('loadMoreBtn').onclick = () => {
                loadedCount += PAGE_SIZE;
                renderItems(filterInput.value.trim());
            };
        } else {
            loadMoreWrapper.innerHTML = '';
        }
        // Fetch thumbnails/details asynchronously and update cards
        toShow.forEach((item, idx) => {
            if (item.objectType === 'thing' && item.objectId && !item.details) {
                fetchThingDetails(item.objectId).then(details => {
                    item.details = details;
                    const card = document.getElementById(`vfmcard-${idx}`);
                    if (card && details.thumbnail) {
                        const img = card.querySelector('.game-thumb');
                        if (img) {
                            img.src = details.thumbnail;
                            img.alt = `${item.name} thumbnail`;
                            img.style.display = 'block';
                        }
                    }
                    if (card && details.year) {
                        const info = card.querySelector('.game-details');
                        if (info) {
                            info.innerHTML += `<b>Year:</b> ${details.year}<br>`;
                        }
                    }
                });
            }
        });
        // Modal logic for View Details
        document.querySelectorAll('.viewDetailBtn').forEach(btn => {
            btn.onclick = () => {
                const idx = btn.getAttribute('data-idx');
                const item = toShow[idx];
                const details = item.details || {};
                // Extract seller name and price again for modal
                const seller = item.item.getAttribute('username') || '';
                let price = '';
                const bodyNode = item.item.querySelector('body');
                if (bodyNode) {
                    const bodyText = bodyNode.textContent;
                    const fpMatch = bodyText.match(/\[FP:?\][^$]*\$([0-9]+(?:\.[0-9]{2})?)/i);
                    if (fpMatch) price = `$${fpMatch[1]}`;
                    else {
                        const dollarMatch = bodyText.match(/\$([0-9]+(?:\.[0-9]{2})?)/);
                        if (dollarMatch) price = `$${dollarMatch[1]}`;
                    }
                }
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.position = 'fixed';
                modal.style.left = '0';
                modal.style.top = '0';
                modal.style.width = '100vw';
                modal.style.height = '100vh';
                modal.style.background = 'rgba(0,0,0,0.25)';
                modal.style.display = 'flex';
                modal.style.alignItems = 'center';
                modal.style.justifyContent = 'center';
                modal.style.zIndex = '9999';
                modal.style.padding = 'env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)';
                modal.style.boxSizing = 'border-box';
                const content = document.createElement('div');
                content.style.maxWidth = '390px';
                content.style.width = '90vw';
                content.style.background = '#fff';
                content.style.borderRadius = '16px';
                content.style.boxShadow = '0 4px 20px rgba(0,0,0,0.15)';
                content.style.padding = '1.5em 1em 1.2em 1em';
                content.style.maxHeight = '85vh';
                content.style.overflowY = 'auto';
                content.style.margin = '1em';
                content.style.position = 'relative';
                // Extract all attributes from item XML
                const attrs = item.item.attributes;
                let attrHtml = '';
                for (let i = 0; i < attrs.length; i++) {
                    const attr = attrs[i];
                    attrHtml += `<b>${attr.name}:</b> ${attr.value}<br>`;
                }
                // Extract body content
                let bodyHtml = '';
                if (bodyNode) {
                    bodyHtml = `<div style='margin-top:1em; font-size:0.98em; color:#333; background:#f7f7fa; padding:0.7em; border-radius:8px;'><b>Listing Details:</b><br>${bodyNode.textContent.replace(/\n/g,'<br>')}</div>`;
                }
                content.innerHTML = `
                    <h2 style='font-size:1.2em; margin-bottom:0.7em;'>${item.name}</h2>
                    ${details.thumbnail ? `<img src='${details.thumbnail}' alt='${item.name} thumbnail' style='width:80px; height:80px; border-radius:12px; margin-bottom:1em; object-fit:cover;'>` : ''}
                    <div style='font-size:1em; text-align:left; background:#f7f7fa; padding:1em; border-radius:8px; margin-bottom:1em;'>
                        <b>Seller:</b> ${seller}<br>
                        <b>Price:</b> ${price || 'N/A'}<br>
                        ${attrHtml}
                        <b>Year:</b> ${details.year || 'N/A'}<br>
                        ${item.objectId ? `<a href='https://boardgamegeek.com/boardgame/${item.objectId}' target='_blank' style='color:#1976d2;'>View on BGG</a><br>` : ''}
                        <a href='https://boardgamegeek.com/geeklist/${item.geeklistId}?itemid=${item.item.getAttribute('id')}' target='_blank' style='color:#1976d2;'>View Geeklisting</a>
                    </div>
                    ${bodyHtml}
                    <button id='closeModalBtn' style='margin-top:1.5em; background:#1976d2; color:#fff; font-size:1.1em; padding:0.8em 2em; border-radius:12px; border:none; width:100%; min-height:44px; font-weight:600; cursor:pointer; -webkit-appearance:none;'>Close</button>
                `;
                modal.appendChild(content);
                document.body.appendChild(modal);
                document.getElementById('closeModalBtn').onclick = () => {
                    document.body.removeChild(modal);
                };
            };
        });
    }

    filterInput.addEventListener('input', () => {
        loadedCount = 0;
        renderItems(filterInput.value.trim());
    });

    fetchAllGeeklists();
    // Analytics button logic
    document.getElementById('analyticsBtn').onclick = () => {
        // Prepare analytics data
        // 1. Records per geeklist
        const recordsPerGeeklist = {};
        geeklists.forEach(g => { recordsPerGeeklist[g.name] = 0; });
        allItems.forEach(item => {
            const gname = geeklists.find(g => g.id == item.geeklistId)?.name;
            if (gname) recordsPerGeeklist[gname]++;
        });
        // 2. Records listed per month
        const recordsPerMonth = {};
        allItems.forEach(item => {
            if (item.postdate) {
                const d = new Date(item.postdate);
                const key = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`;
                recordsPerMonth[key] = (recordsPerMonth[key]||0)+1;
            }
        });
        // 3. Most listed games per geeklist
        const mostListedGamesPerGeeklist = {};
        geeklists.forEach(g => { mostListedGamesPerGeeklist[g.name] = {}; });
        allItems.forEach(item => {
            const gname = geeklists.find(g => g.id == item.geeklistId)?.name;
            if (gname) {
                const n = item.name;
                mostListedGamesPerGeeklist[gname][n] = (mostListedGamesPerGeeklist[gname][n]||0)+1;
            }
        });
        // 4. Most listed games overall
        const mostListedGamesOverall = {};
        allItems.forEach(item => {
            const n = item.name;
            mostListedGamesOverall[n] = (mostListedGamesOverall[n]||0)+1;
        });
        // Modal UI
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.style.position = 'fixed';
        modal.style.left = '0';
        modal.style.top = '0';
        modal.style.width = '100vw';
        modal.style.height = '100vh';
        modal.style.background = 'rgba(0,0,0,0.25)';
        modal.style.display = 'flex';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
        modal.style.zIndex = '9999';
        modal.style.padding = 'env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)';
        modal.style.boxSizing = 'border-box';
        const content = document.createElement('div');
        content.style.maxWidth = '390px';
        content.style.width = '90vw';
        content.style.background = '#fff';
        content.style.borderRadius = '16px';
        content.style.boxShadow = '0 4px 20px rgba(0,0,0,0.15)';
        content.style.padding = '1.5em 1em 1.2em 1em';
        content.style.maxHeight = '85vh';
        content.style.overflowY = 'auto';
        content.style.margin = '1em';
        content.style.position = 'relative';
        // Tabs
        content.innerHTML = `
            <h2 style='font-size:1.3em; margin-bottom:1em; font-weight:600;'>Analytics Dashboard</h2>
            <div style='display:flex; gap:0.4em; margin-bottom:1.2em; flex-wrap:wrap;'>
                <button id='tabRecordsGeeklist' style='background:#43a047; color:#fff; border:none; border-radius:10px; padding:0.6em 0.8em; font-size:0.9em; min-height:40px; flex:1; min-width:80px; font-weight:600; cursor:pointer; -webkit-appearance:none;'>Records per Geeklist</button>
                <button id='tabRecordsMonth' style='background:#1976d2; color:#fff; border:none; border-radius:10px; padding:0.6em 0.8em; font-size:0.9em; min-height:40px; flex:1; min-width:80px; font-weight:600; cursor:pointer; -webkit-appearance:none;'>Records per Month</button>
                <button id='tabMostListedGeeklist' style='background:#f7b731; color:#222; border:none; border-radius:10px; padding:0.6em 0.8em; font-size:0.9em; min-height:40px; flex:1; min-width:80px; font-weight:600; cursor:pointer; -webkit-appearance:none;'>Most Listed per Geeklist</button>
                <button id='tabMostListedOverall' style='background:#ff4136; color:#fff; border:none; border-radius:10px; padding:0.6em 0.8em; font-size:0.9em; min-height:40px; flex:1; min-width:80px; font-weight:600; cursor:pointer; -webkit-appearance:none;'>Most Listed Overall</button>
            </div>
            <div id='analyticsContent' style='font-size:1em; line-height:1.5;'></div>
            <button id='closeAnalyticsBtn' style='margin-top:1.5em; background:#1976d2; color:#fff; font-size:1.1em; padding:0.8em 2em; border-radius:12px; border:none; width:100%; min-height:44px; font-weight:600; cursor:pointer; -webkit-appearance:none;'>Close</button>
        `;
        modal.appendChild(content);
        document.body.appendChild(modal);
        // Tab logic
        function showTab(tab) {
            const ac = content.querySelector('#analyticsContent');
            if (tab === 'geeklist') {
                ac.innerHTML = `<b>Records per Geeklist:</b><br>` +
                    `<ul style='margin-top:0.5em;'>` +
                    Object.entries(recordsPerGeeklist).map(([k,v]) => `<li><b>${k}:</b> ${v}</li>`).join('') +
                    `</ul>`;
            } else if (tab === 'month') {
                ac.innerHTML = `<b>Records Listed per Month:</b><br>` +
                    `<ul style='margin-top:0.5em;'>` +
                    Object.entries(recordsPerMonth).sort((a,b)=>b[0].localeCompare(a[0])).map(([k,v]) => `<li><b>${k}:</b> ${v}</li>`).join('') +
                    `</ul>`;
            } else if (tab === 'mostgeeklist') {
                ac.innerHTML = `<b>Most Listed Games per Geeklist (Top 10):</b><br>` +
                    Object.entries(mostListedGamesPerGeeklist).map(([g, games]) => {
                        const sorted = Object.entries(games).sort((a,b)=>b[1]-a[1]).slice(0,10);
                        return `<div style='margin-top:0.7em;'><b>${g}:</b><ul>` + sorted.map(([n,c]) => `<li>${n} (${c})</li>`).join('') + `</ul></div>`;
                    }).join('');
            } else if (tab === 'mostoverall') {
                const sorted = Object.entries(mostListedGamesOverall).sort((a,b)=>b[1]-a[1]).slice(0,25);
                ac.innerHTML = `<b>Most Listed Games Overall (Top 25):</b><br><ul style='margin-top:0.5em;'>` +
                    sorted.map(([n,c]) => `<li>${n} (${c})</li>`).join('') +
                    `</ul>`;
            }
        }
        content.querySelector('#tabRecordsGeeklist').onclick = () => showTab('geeklist');
        content.querySelector('#tabRecordsMonth').onclick = () => showTab('month');
        content.querySelector('#tabMostListedGeeklist').onclick = () => showTab('mostgeeklist');
        content.querySelector('#tabMostListedOverall').onclick = () => showTab('mostoverall');
        content.querySelector('#closeAnalyticsBtn').onclick = () => {
            document.body.removeChild(modal);
        };
        showTab('geeklist');
    };
    // Status filter button logic
    const statusFilterBtn = document.getElementById('statusFilterBtn');
    const statusFilterSelect = document.getElementById('statusFilterSelect');
    statusFilterBtn.onclick = () => {
        statusFilterSelect.style.display = statusFilterSelect.style.display === 'none' ? 'inline-block' : 'none';
    };
    statusFilterSelect.onchange = (e) => {
        currentStatusFilter = e.target.value;
        loadedCount = 0;
        renderItems(filterInput.value.trim());
    };
    
    // Geeklist filter logic
    const geeklistFilterBtn = document.getElementById('geeklistFilterBtn');
    const geeklistFilterPanel = document.getElementById('geeklistFilterPanel');
    const geeklistCheckboxes = document.getElementById('geeklistCheckboxes');
    
    // Initialize geeklist checkboxes
    function initializeGeeklistFilter() {
        geeklistCheckboxes.innerHTML = '';
        geeklists.forEach(geeklist => {
            const checkboxDiv = document.createElement('div');
            checkboxDiv.style.display = 'flex';
            checkboxDiv.style.alignItems = 'center';
            checkboxDiv.style.gap = '0.5em';
            checkboxDiv.style.padding = '0.3em 0';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `geeklist-${geeklist.id}`;
            checkbox.checked = selectedGeeklists.has(geeklist.id);
            checkbox.style.transform = 'scale(1.2)';
            
            const label = document.createElement('label');
            label.htmlFor = `geeklist-${geeklist.id}`;
            label.textContent = geeklist.name;
            label.style.fontSize = '0.95em';
            label.style.cursor = 'pointer';
            label.style.flex = '1';
            
            // Add item count
            const count = allItems.filter(item => item.geeklistId === geeklist.id).length;
            const countSpan = document.createElement('span');
            countSpan.textContent = `(${count})`;
            countSpan.style.fontSize = '0.85em';
            countSpan.style.color = '#666';
            countSpan.style.marginLeft = '0.3em';
            
            checkboxDiv.appendChild(checkbox);
            checkboxDiv.appendChild(label);
            checkboxDiv.appendChild(countSpan);
            geeklistCheckboxes.appendChild(checkboxDiv);
        });
    }
    
    geeklistFilterBtn.onclick = () => {
        const isVisible = geeklistFilterPanel.style.display !== 'none';
        geeklistFilterPanel.style.display = isVisible ? 'none' : 'block';
        if (!isVisible) {
            initializeGeeklistFilter();
        }
    };
    
    document.getElementById('selectAllGeeklists').onclick = () => {
        geeklists.forEach(geeklist => {
            const checkbox = document.getElementById(`geeklist-${geeklist.id}`);
            if (checkbox) checkbox.checked = true;
        });
    };
    
    document.getElementById('deselectAllGeeklists').onclick = () => {
        geeklists.forEach(geeklist => {
            const checkbox = document.getElementById(`geeklist-${geeklist.id}`);
            if (checkbox) checkbox.checked = false;
        });
    };
    
    document.getElementById('applyGeeklistFilter').onclick = () => {
        selectedGeeklists.clear();
        geeklists.forEach(geeklist => {
            const checkbox = document.getElementById(`geeklist-${geeklist.id}`);
            if (checkbox && checkbox.checked) {
                selectedGeeklists.add(geeklist.id);
            }
        });
        
        // Update button text to show active filter
        const selectedCount = selectedGeeklists.size;
        const totalCount = geeklists.length;
        if (selectedCount === totalCount) {
            geeklistFilterBtn.textContent = 'Select Geeklists';
            geeklistFilterBtn.style.background = '#8e24aa';
        } else {
            geeklistFilterBtn.textContent = `Geeklists (${selectedCount}/${totalCount})`;
            geeklistFilterBtn.style.background = '#f39c12';
        }
        
        geeklistFilterPanel.style.display = 'none';
        loadedCount = 0;
        renderItems(filterInput.value.trim());
    };
    
    // Filter mode button logic
    const filterModeButtons = [
        document.getElementById('exactMatchBtn'),
        document.getElementById('startsWithBtn'), 
        document.getElementById('containsBtn')
    ];
    
    filterModeButtons.forEach(btn => {
        btn.onclick = () => {
            // Update active button styling
            filterModeButtons.forEach(b => {
                b.style.background = '#ccc';
                b.style.color = '#333';
            });
            btn.style.background = '#1976d2';
            btn.style.color = '#fff';
            
            // Update filter mode
            currentFilterMode = btn.getAttribute('data-mode');
            
            // Re-render with current filter
            loadedCount = 0;
            renderItems(filterInput.value.trim());
        };
    });
    </script>
</body>
</html>
