<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover">
    <title>Virtual Flea Market (VFM)</title>
    <style>
        body { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; background: #f7f7fa; color: #222; }
        .container { max-width: 430px; margin: 0 auto; padding: 2em 1em 1em 1em; box-sizing: border-box; min-height: 100vh; padding-bottom: env(safe-area-inset-bottom); }
        h1 { font-size: 1.7em; margin-bottom: 1em; text-align: center; }
        .game-list { margin-top: 1em; }
        .game-card { background: #fff; border-radius: 12px; box-shadow: 0 2px 12px #0001; margin-bottom: 1em; padding: 1em 1.2em; display: flex; flex-direction: row; align-items: center; }
        .game-thumb { width: 64px; height: 64px; border-radius: 10px; margin-right: 1em; object-fit: cover; flex-shrink: 0; }
        .game-info { display: flex; flex-direction: column; flex: 1; }
        .game-title { font-size: 1.1em; font-weight: 600; margin-bottom: 0.2em; }
        .game-details { font-size: 0.98em; color: #555; }
        .geeklist-label { font-size: 0.95em; color: #1976d2; margin-bottom: 0.2em; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Virtual Flea Market (VFM)</h1>
        <div style="margin-bottom:1em; text-align:center; display:flex; flex-direction:row; justify-content:center; align-items:center; gap:0.5em; flex-wrap:wrap;">
            <button id="analyticsBtn" style="background:#1976d2; color:#fff; border:none; border-radius:8px; padding:0.5em 0.8em; font-size:0.9em; font-weight:600; cursor:pointer; min-height:36px; -webkit-appearance:none; appearance:none; flex:1;">📊 Stats</button>
            <button id="statusFilterBtn" style="background:#1976d2; color:#fff; border:none; border-radius:8px; padding:0.5em 0.8em; font-size:0.9em; font-weight:600; cursor:pointer; min-height:36px; -webkit-appearance:none; appearance:none; flex:1;">🔍 Status</button>
            <button id="sellerFilterBtn" style="background:#1976d2; color:#fff; border:none; border-radius:8px; padding:0.5em 0.8em; font-size:0.9em; font-weight:600; cursor:pointer; min-height:36px; -webkit-appearance:none; appearance:none; flex:1;">👤 Seller</button>
            <button id="geeklistFilterBtn" style="background:#1976d2; color:#fff; border:none; border-radius:8px; padding:0.5em 0.8em; font-size:0.9em; font-weight:600; cursor:pointer; min-height:36px; -webkit-appearance:none; appearance:none; flex:1;">📋 Lists</button>
            <select id="statusFilterSelect" style="font-size:1em; padding:0.6em 1em; border-radius:10px; border:1px solid #bbb; display:none; min-height:44px; -webkit-appearance:none; appearance:none;">
                <option value="">All</option>
                <option value="own">✅ Own</option>
                <option value="wanttoplay">🎮 Want to Play</option>
                <option value="wanttobuy">🛒 Want to Buy</option>
                <option value="wantintrade">🔄 Want in Trade</option>
                <option value="prevowned">⏪ Previously Owned</option>
                <option value="tradingaway">📤 Trading Away</option>
                <option value="sold">🔴 Sold Items</option>
                <option value="available">🟢 Available Items</option>
            </select>
            <div id="sellerFilterContainer" style="display:none; position:relative; max-width:250px;">
                <input id="sellerFilterInput" type="text" placeholder="Search sellers..." style="font-size:1em; padding:0.6em 1em; border-radius:10px; border:1px solid #bbb; width:100%; min-height:44px; -webkit-appearance:none; appearance:none; box-sizing:border-box;">
                <div id="sellerSuggestions" style="position:absolute; top:100%; left:0; right:0; background:#fff; border:1px solid #bbb; border-top:none; border-radius:0 0 10px 10px; max-height:200px; overflow-y:auto; z-index:1000; display:none; box-shadow:0 4px 8px rgba(0,0,0,0.1);"></div>
            </div>
        </div>
        <div id="geeklistFilterPanel" style="display:none; background:#f7f7fa; border-radius:10px; padding:1em; margin-bottom:1em; border:2px solid #8e24aa;">
            <div style="font-weight:600; margin-bottom:0.7em; color:#8e24aa;">Select Geeklists to Include:</div>
            <div id="geeklistCheckboxes" style="display:grid; grid-template-columns:1fr; gap:0.5em;"></div>
            <div style="margin-top:1em; display:flex; gap:0.5em; justify-content:center;">
                <button id="selectAllGeeklists" style="background:#43a047; color:#fff; border:none; border-radius:8px; padding:0.5em 1em; font-size:0.9em; cursor:pointer;">Select All</button>
                <button id="deselectAllGeeklists" style="background:#ff4136; color:#fff; border:none; border-radius:8px; padding:0.5em 1em; font-size:0.9em; cursor:pointer;">Deselect All</button>
                <button id="applyGeeklistFilter" style="background:#8e24aa; color:#fff; border:none; border-radius:8px; padding:0.5em 1em; font-size:0.9em; cursor:pointer; font-weight:600;">Apply Filter</button>
            </div>
        </div>
        <!-- <div id="emojiDesc" style="background:#f7f7fa; border-radius:8px; padding:0.7em 1em; font-size:1em; color:#333; margin-bottom:1em;">
            <b>Status Emoji Legend:</b><br>
            ✅ Own &mdash; You own this game<br>
            🎮 Want to Play &mdash; You want to play this game<br>
            🛒 Want to Buy &mdash; You want to buy this game<br>
            🔄 Want in Trade &mdash; You want to trade for this game<br>
            ⏪ Previously Owned &mdash; You previously owned this game<br>
            📤 Trading Away &mdash; You are trading away this game<br>
        </div> -->
        <div id="filterBar" style="margin-bottom:1em; text-align:center;">
            <input id="filterInput" type="text" placeholder="Filter by name..." style="font-size:1.1em; padding:0.6em 1em; border-radius:10px; border:1px solid #bbb; width:70%; max-width:200px; margin-bottom:0.7em; -webkit-appearance:none; appearance:none;">
            <div style="display:flex; justify-content:center; gap:0.4em; flex-wrap:wrap;">
                <button id="exactMatchBtn" data-mode="exact" style="background:#666; color:#fff; border:none; border-radius:8px; padding:0.5em 1em; font-size:0.9em; min-height:36px; cursor:pointer; font-weight:500; -webkit-appearance:none; appearance:none;">Exact Match</button>
                <button id="startsWithBtn" data-mode="startswith" style="background:#666; color:#fff; border:none; border-radius:8px; padding:0.5em 1em; font-size:0.9em; min-height:36px; cursor:pointer; font-weight:500; -webkit-appearance:none; appearance:none;">Starts With</button>
                <button id="containsBtn" data-mode="contains" style="background:#1976d2; color:#fff; border:none; border-radius:8px; padding:0.5em 1em; font-size:0.9em; min-height:36px; cursor:pointer; font-weight:500; -webkit-appearance:none; appearance:none;">Contains</button>
            </div>
        </div>
        <div id="gamesCardWrapper">
            <div style="text-align:center; color:#888; font-size:1.1em;">Loading VFM Geeklists...</div>
        </div>
        <div id="loadMoreWrapper" style="text-align:center; margin:1em 0;"></div>
    </div>
    <script>
    const geeklists = [
        { id: 363504, name: "BGG.CON VFM 2025" },
        { id: 342440, name: "BGG.CON VFM 2024" },
        { id: 321725, name: "BGG.CON VFM 2023" },
        { id: 349103, name: "DTW VFM 2025" },
        { id: 328677, name: "DTW VFM 2024" },
        { id: 308714, name: "DTW VFM 2023" },
        { id: 235851, name: "Denver CO VFM" }
    ];
    const gamesCardWrapper = document.getElementById('gamesCardWrapper');
    
    // Cache for user details to avoid repeated API calls
    const userDetailsCache = new Map();
    
    // Function to convert BGG BBCode formatting to HTML
    function formatBGGText(text) {
        if (!text) return text;
        
        let formatted = text;
        
        // Convert [B]text[/B] to <b>text</b>
        formatted = formatted.replace(/\[B\](.*?)\[\/B\]/gi, '<b>$1</b>');
        
        // Convert [I]text[/I] to <i>text</i>
        formatted = formatted.replace(/\[I\](.*?)\[\/I\]/gi, '<i>$1</i>');
        
        // Convert [U]text[/U] to <u>text</u>
        formatted = formatted.replace(/\[U\](.*?)\[\/U\]/gi, '<u>$1</u>');
        
        // Convert [size=X]text[/size] to styled spans
        formatted = formatted.replace(/\[size=(\d+)\](.*?)\[\/size\]/gi, '<span style="font-size:$1pt">$2</span>');
        
        // Convert [url=link]text[/url] to <a> tags
        formatted = formatted.replace(/\[url=(.*?)\](.*?)\[\/url\]/gi, '<a href="$1" target="_blank" style="color:#1976d2;">$2</a>');
        
        // Convert [thing=ID]text[/thing] to BGG links
        formatted = formatted.replace(/\[thing=(\d+)\](.*?)\[\/thing\]/gi, '<a href="https://boardgamegeek.com/boardgame/$1" target="_blank" style="color:#1976d2;">$2</a>');
        
        // Convert [imageid=ID] to image links (just show as link since we can't easily embed)
        formatted = formatted.replace(/\[imageid=(\d+)\]/gi, '<a href="https://boardgamegeek.com/image/$1" target="_blank" style="color:#ff9800;">[View Image $1]</a>');
        
        // Convert line breaks
        formatted = formatted.replace(/\n/g, '<br>');
        
        return formatted;
    }
    
    async function fetchUserDetails(username) {
        if (!username) return { name: '', username: '', location: '' };
        
        // Check cache first
        if (userDetailsCache.has(username)) {
            return userDetailsCache.get(username);
        }
        
        try {
            console.log(`🔍 Fetching user details for: ${username}`);
            const resp = await fetch(`https://boardgamegeek.com/xmlapi2/user?name=${username}`);
            if (!resp.ok) {
                console.log(`❌ Failed to fetch user ${username}: ${resp.status}`);
                // Store empty result in cache to avoid repeated failed requests
                const result = { name: '', username: username, location: '' };
                userDetailsCache.set(username, result);
                return result;
            }
            
            const xml = await resp.text();
            const parser = new window.DOMParser();
            const doc = parser.parseFromString(xml, 'text/xml');
            
            const userNode = doc.querySelector('user');
            const firstNameNode = doc.querySelector('firstname');
            const lastNameNode = doc.querySelector('lastname');
            const stateNode = doc.querySelector('stateorprovince');
            const countryNode = doc.querySelector('country');
            
            const firstName = firstNameNode?.getAttribute('value') || '';
            const lastName = lastNameNode?.getAttribute('value') || '';
            const state = stateNode?.getAttribute('value') || '';
            const country = countryNode?.getAttribute('value') || '';
            
            const fullName = [firstName, lastName].filter(n => n).join(' ').trim();
            
            // Build location string
            let location = '';
            if (state && country) {
                location = `${state}, ${country}`;
            } else if (state) {
                location = state;
            } else if (country) {
                location = country;
            }
            
            const result = {
                name: fullName,
                username: username,
                location: location,
                firstName: firstName,
                lastName: lastName,
                state: state,
                country: country
            };
            
            console.log(`✅ User details for ${username}:`, result);
            
            // Cache the result
            userDetailsCache.set(username, result);
            return result;
        } catch (error) {
            console.log(`❌ Error fetching user details for ${username}:`, error);
            const result = { name: '', username: username, location: '' };
            userDetailsCache.set(username, result);
            return result;
        }
    }
    
    async function fetchThingDetails(objectId) {
        if (!objectId) return {};
        try {
            const resp = await fetch(`https://boardgamegeek.com/xmlapi2/thing?id=${objectId}&stats=1`);
            if (!resp.ok) return {};
            const xml = await resp.text();
            const parser = new window.DOMParser();
            const doc = parser.parseFromString(xml, 'text/xml');
            const thumb = doc.querySelector('thumbnail');
            const year = doc.querySelector('yearpublished');
            const desc = doc.querySelector('description');
            
            // Get BGG rank and Bayes average
            const ranks = doc.querySelectorAll('rank');
            let bggRank = '';
            for (const rank of ranks) {
                if (rank.getAttribute('name') === 'boardgame') {
                    const rankValue = rank.getAttribute('value');
                    bggRank = rankValue && rankValue !== 'Not Ranked' ? rankValue : '';
                    break;
                }
            }
            
            const bayesAverage = doc.querySelector('bayesaverage');
            const bayesValue = bayesAverage ? parseFloat(bayesAverage.getAttribute('value')).toFixed(2) : '';
            
            return {
                thumbnail: thumb ? thumb.textContent : '',
                year: year ? year.textContent : '',
                description: desc ? desc.textContent : '',
                bggRank: bggRank,
                bayesAverage: bayesValue
            };
        } catch {
            return {};
        }
    }
    let allItems = [];
    let userCollection = new Set();
    let userWantToPlay = new Set();
    let userWantToBuy = new Set();
    let userWantInTrade = new Set();
    let userPrevOwned = new Set();
    let userTradingAway = new Set();
    let loadedCount = 0;
    const PAGE_SIZE = 50;
    let loading = false;
    let currentStatusFilter = '';
    let currentSellerFilter = '';
    let currentFilterMode = 'contains'; // Default to contains
    let selectedGeeklists = new Set(geeklists.map(g => g.id)); // Start with all selected
    const loadMoreWrapper = document.getElementById('loadMoreWrapper');
    const filterInput = document.getElementById('filterInput');

    // Gradient color functions for visual indicators
    function getRankGradientColor(rank) {
        if (!rank || rank === 'Not Ranked') return { bg: 'rgba(128,128,128,0.9)', text: 'white' }; // Gray for unranked
        const rankNum = parseInt(rank);
        if (rankNum <= 100) return { bg: 'rgba(76,175,80,0.9)', text: 'white' }; // Green for top 100
        if (rankNum <= 500) return { bg: 'rgba(139,195,74,0.9)', text: 'white' }; // Light green for top 500
        if (rankNum <= 1000) return { bg: 'rgba(255,235,59,0.9)', text: 'black' }; // Yellow for top 1000
        if (rankNum <= 5000) return { bg: 'rgba(255,152,0,0.9)', text: 'white' }; // Orange for top 5000
        return { bg: 'rgba(244,67,54,0.9)', text: 'white' }; // Red for below 5000
    }

    function getBayesGradientColor(bayes) {
        if (!bayes) return { bg: 'rgba(128,128,128,0.9)', text: 'white' }; // Gray for no rating
        const bayesNum = parseFloat(bayes);
        if (bayesNum >= 8.0) return { bg: 'rgba(76,175,80,0.9)', text: 'white' }; // Green for excellent (8.0+)
        if (bayesNum >= 7.5) return { bg: 'rgba(139,195,74,0.9)', text: 'white' }; // Light green for very good (7.5+)
        if (bayesNum >= 7.0) return { bg: 'rgba(255,235,59,0.9)', text: 'black' }; // Yellow for good (7.0+)
        if (bayesNum >= 6.0) return { bg: 'rgba(255,152,0,0.9)', text: 'white' }; // Orange for average (6.0+)
        return { bg: 'rgba(244,67,54,0.9)', text: 'white' }; // Red for below average
    }

    function getTimeGradientColor(diffHours) {
        if (diffHours < 1) return { bg: 'rgba(76,175,80,0.9)', text: 'white' }; // Green for very recent (< 1 hour)
        if (diffHours < 6) return { bg: 'rgba(139,195,74,0.9)', text: 'white' }; // Light green for recent (< 6 hours)
        if (diffHours < 12) return { bg: 'rgba(255,235,59,0.9)', text: 'black' }; // Yellow for somewhat recent (< 12 hours)
        if (diffHours < 24) return { bg: 'rgba(255,152,0,0.9)', text: 'white' }; // Orange for within day (< 24 hours)
        return { bg: 'rgba(233,30,99,0.9)', text: 'white' }; // Default pink for older posts
    }

    async function fetchAllGeeklists() {
        // Fetch user's collection first
        try {
            const resp = await fetch('https://boardgamegeek.com/xmlapi2/collection?username=sportomax');
            if (resp.ok) {
                const xml = await resp.text();
                const parser = new window.DOMParser();
                const doc = parser.parseFromString(xml, 'text/xml');
                const items = Array.from(doc.querySelectorAll('item'));
                
                // Extract all status information from the full collection
                userCollection = new Set();
                const tempWantToPlay = new Set();
                const tempWantToBuy = new Set();
                const tempWantInTrade = new Set();
                const tempPrevOwned = new Set();
                const tempTradingAway = new Set();
                
                items.forEach(item => {
                    const objectId = item.getAttribute('objectid');
                    const status = item.querySelector('status');
                    
                    if (status) {
                        if (status.getAttribute('own') === '1') {
                            userCollection.add(objectId);
                        }
                        if (status.getAttribute('wanttoplay') === '1') {
                            tempWantToPlay.add(objectId);
                        }
                        if (status.getAttribute('wanttobuy') === '1') {
                            tempWantToBuy.add(objectId);
                        }
                        if (status.getAttribute('wantintrade') === '1') {
                            tempWantInTrade.add(objectId);
                        }
                        if (status.getAttribute('prevowned') === '1') {
                            tempPrevOwned.add(objectId);
                        }
                        // Check for trade flag > 0
                        const fortrade = status.getAttribute('fortrade') || '0';
                        if (parseInt(fortrade) > 0) {
                            tempTradingAway.add(objectId);
                        }
                    }
                });
                
                // Update the global sets with the more comprehensive data
                userWantToPlay = tempWantToPlay;
                userWantToBuy = tempWantToBuy;
                userWantInTrade = tempWantInTrade;
                userPrevOwned = tempPrevOwned;
                userTradingAway = tempTradingAway;
            }
        } catch {}
        gamesCardWrapper.innerHTML = '<div style="text-align:center; color:#888; font-size:1.1em;" id="loadingStatus">Loading VFM Geeklists...</div>';
        allItems = [];
        loadedCount = 0;
        loading = true;
        
        const loadingStatus = document.getElementById('loadingStatus');
        
        for (let g = 0; g < geeklists.length; g++) {
            const geeklist = geeklists[g];
            loadingStatus.innerHTML = `Loading ${geeklist.name}...`;
            console.log(`Fetching geeklist: ${geeklist.name} (ID: ${geeklist.id})`);
            
            let retryCount = 0;
            // BGG Con VFM 25 needs more retries due to smaller volume but frequent issues
            const maxRetries = geeklist.name.includes('BGG.CON VFM 2025') ? 5 : 3;
            let success = false;
            
            while (retryCount < maxRetries && !success) {
                try {
                    const resp = await fetch(`https://boardgamegeek.com/xmlapi/geeklist/${geeklist.id}?comments=1`);
                    console.log(`Response status for ${geeklist.name}:`, resp.status);
                    
                    if (resp.status === 202) {
                        const waitTime = geeklist.name.includes('BGG.CON VFM 2025') ? 5000 : 3000; // Extra wait for BGG Con
                        console.log(`BGG still processing ${geeklist.name}, waiting ${waitTime/1000} seconds... (attempt ${retryCount + 1}/${maxRetries})`);
                        loadingStatus.innerHTML = `${geeklist.name}: BGG processing, waiting... (${retryCount + 1}/${maxRetries})`;
                        retryCount++;
                        if (retryCount < maxRetries) {
                            await new Promise(resolve => setTimeout(resolve, waitTime));
                            continue;
                        } else {
                            console.error(`Failed to fetch ${geeklist.name}: BGG processing timeout after ${maxRetries} attempts`);
                            loadingStatus.innerHTML = `${geeklist.name}: Timeout, skipping...`;
                            await new Promise(resolve => setTimeout(resolve, 1000));
                            break;
                        }
                    }
                    
                    if (!resp.ok) {
                        console.error(`Failed to fetch ${geeklist.name}: ${resp.status} ${resp.statusText}`);
                        break;
                    }
                    
                    const xml = await resp.text();
                    console.log(`XML length for ${geeklist.name}:`, xml.length);
                    
                    // Check if XML contains actual data
                    if (xml.length < 100) {
                        console.warn(`${geeklist.name}: XML too short, might be empty response`);
                        loadingStatus.innerHTML = `${geeklist.name}: Empty response, retrying... (${retryCount + 1}/${maxRetries})`;
                        retryCount++;
                        if (retryCount < maxRetries) {
                            const retryWait = geeklist.name.includes('BGG.CON VFM 2025') ? 4000 : 2000;
                            await new Promise(resolve => setTimeout(resolve, retryWait));
                            continue;
                        } else {
                            loadingStatus.innerHTML = `${geeklist.name}: Failed, skipping...`;
                            await new Promise(resolve => setTimeout(resolve, 1000));
                            break;
                        }
                    }
                    
                    const parser = new window.DOMParser();
                    const doc = parser.parseFromString(xml, 'text/xml');
                    
                    // Check for XML parsing errors
                    const parseError = doc.querySelector('parsererror');
                    if (parseError) {
                        console.error(`XML parse error for ${geeklist.name}:`, parseError.textContent);
                        loadingStatus.innerHTML = `${geeklist.name}: Parse error, retrying... (${retryCount + 1}/${maxRetries})`;
                        retryCount++;
                        if (retryCount < maxRetries) {
                            const retryWait = geeklist.name.includes('BGG.CON VFM 2025') ? 4000 : 2000;
                            await new Promise(resolve => setTimeout(resolve, retryWait));
                            continue;
                        } else {
                            loadingStatus.innerHTML = `${geeklist.name}: Parse failed, skipping...`;
                            await new Promise(resolve => setTimeout(resolve, 1000));
                            break;
                        }
                    }
                    
                    const items = Array.from(doc.querySelectorAll('item'));
                    console.log(`Items found in ${geeklist.name}:`, items.length);
                    
                    for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    
                    // Extract comment data from the item
                    const commentNodes = Array.from(item.querySelectorAll('comment'));
                    const commentData = commentNodes.map(comment => ({
                        username: comment.getAttribute('username') || '',
                        date: comment.getAttribute('date') || '',
                        content: comment.textContent.trim() || ''
                    }));
                    
                    const username = item.getAttribute('username') || '';
                    
                    const itemData = {
                        geeklistName: geeklist.name,
                        geeklistId: geeklist.id,
                        name: item.getAttribute('objectname') || 'Unknown',
                        objectType: item.getAttribute('objecttype') || '',
                        objectId: item.getAttribute('objectid') || '',
                        postdate: item.getAttribute('postdate') || '',
                        comments: item.getAttribute('comments') || '',
                        commentData: commentData, // Store actual comment data
                        username: username,
                        userDetails: null, // Will be populated later
                        details: null,
                        item
                    };
                    
                    allItems.push(itemData);
                    
                    // Start fetching user details immediately for better performance
                    if (username) {
                        fetchUserDetails(username).then(userDetails => {
                            itemData.userDetails = userDetails;
                        });
                    }
                }
                
                // Sort by postdate descending after adding new items
                allItems.sort((a, b) => {
                    const da = new Date(a.postdate);
                    const db = new Date(b.postdate);
                    return db - da;
                });
                
                // Render items progressively after each geeklist is loaded
                renderItems();
                
                success = true; // Mark as successful
            } catch (e) {
                console.error(`Error fetching geeklist ${geeklist.name} (attempt ${retryCount + 1}):`, e);
                retryCount++;
                if (retryCount < maxRetries) {
                    const retryWait = geeklist.name.includes('BGG.CON VFM 2025') ? 4000 : 2000;
                    console.log(`Retrying ${geeklist.name} in ${retryWait/1000} seconds...`);
                    await new Promise(resolve => setTimeout(resolve, retryWait));
                } else {
                    console.error(`Failed to fetch ${geeklist.name} after ${maxRetries} attempts`);
                }
            }
            } // End retry loop
        }
        
        console.log(`Total items loaded from all geeklists: ${allItems.length}`);
        console.log('Items per geeklist:', geeklists.map(g => ({
            name: g.name,
            count: allItems.filter(item => item.geeklistId === g.id).length
        })));
        loading = false;
        
        // Initialize seller suggestions (but don't show them yet)
        updateSellerSuggestions();
        
        // Remove loading status after all geeklists are processed
        const finalLoadingStatus = document.getElementById('loadingStatus');
        if (finalLoadingStatus) {
            finalLoadingStatus.remove();
        }
        
        renderItems();
    }

    // Function to populate seller suggestions
    function updateSellerSuggestions(searchTerm = '') {
        const sellers = new Set();
        
        // Collect all unique sellers from current items
        allItems.forEach(item => {
            const seller = item.item.getAttribute('username');
            if (seller && seller.trim()) {
                sellers.add(seller.trim());
            }
        });
        
        // Filter sellers based on search term and sort alphabetically
        const filteredSellers = Array.from(sellers)
            .filter(seller => searchTerm === '' || seller.toLowerCase().includes(searchTerm.toLowerCase()))
            .sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
        
        return filteredSellers;
    }

    function showSellerSuggestions(searchTerm = '') {
        const suggestionsDiv = document.getElementById('sellerSuggestions');
        const filteredSellers = updateSellerSuggestions(searchTerm);
        
        if (filteredSellers.length === 0 || (searchTerm === '' && filteredSellers.length > 20)) {
            suggestionsDiv.style.display = 'none';
            return;
        }
        
        // Limit to first 10 suggestions for performance
        const sellersToShow = filteredSellers.slice(0, 10);
        
        suggestionsDiv.innerHTML = '';
        
        // Add "Clear Filter" option if there's a current filter
        if (currentSellerFilter) {
            const clearOption = document.createElement('div');
            clearOption.style.padding = '0.5em 1em';
            clearOption.style.cursor = 'pointer';
            clearOption.style.borderBottom = '1px solid #eee';
            clearOption.style.fontStyle = 'italic';
            clearOption.style.color = '#666';
            clearOption.textContent = 'Clear seller filter';
            clearOption.onclick = () => {
                document.getElementById('sellerFilterInput').value = '';
                currentSellerFilter = '';
                suggestionsDiv.style.display = 'none';
                loadedCount = 0;
                renderItems(filterInput.value.trim());
            };
            suggestionsDiv.appendChild(clearOption);
        }
        
        sellersToShow.forEach(seller => {
            const option = document.createElement('div');
            option.style.padding = '0.5em 1em';
            option.style.cursor = 'pointer';
            option.style.borderBottom = '1px solid #eee';
            option.textContent = seller;
            
            // Add count of listings for this seller
            const count = allItems.filter(item => {
                const itemSeller = item.item.getAttribute('username') || '';
                return itemSeller.trim() === seller;
            }).length;
            
            const countSpan = document.createElement('span');
            countSpan.style.float = 'right';
            countSpan.style.color = '#666';
            countSpan.style.fontSize = '0.9em';
            countSpan.textContent = `(${count})`;
            option.appendChild(countSpan);
            
            option.onmouseenter = () => {
                option.style.backgroundColor = '#f0f0f0';
            };
            option.onmouseleave = () => {
                option.style.backgroundColor = '';
            };
            
            option.onclick = () => {
                document.getElementById('sellerFilterInput').value = seller;
                currentSellerFilter = seller;
                suggestionsDiv.style.display = 'none';
                loadedCount = 0;
                renderItems(filterInput.value.trim());
            };
            
            suggestionsDiv.appendChild(option);
        });
        
        suggestionsDiv.style.display = 'block';
    }

    function renderItems(filter = '') {
        let filtered = allItems.filter(item => selectedGeeklists.has(item.geeklistId));
        
        if (filter) {
            const f = filter.toLowerCase();
            filtered = filtered.filter(r => {
                const name = r.name.toLowerCase();
                if (currentFilterMode === 'exact') {
                    return name === f;
                } else if (currentFilterMode === 'startswith') {
                    return name.startsWith(f);
                } else { // contains (default)
                    return name.includes(f);
                }
            });
        }
        // Filter by emoji status if set
        if (currentStatusFilter) {
            filtered = filtered.filter(item => {
                if (currentStatusFilter === 'sold') {
                    // Check if item is sold
                    const isSold = item.item.getAttribute('sold') === '1';
                    const bodyNode = item.item.querySelector('body');
                    let bodyContainsSold = false;
                    if (bodyNode) {
                        const bodyText = bodyNode.textContent.toLowerCase();
                        const soldPatterns = [
                            /%sold%/i,
                            /\bsold\b/i,
                            /\[sold\]/i,
                            /\(sold\)/i
                        ];
                        bodyContainsSold = soldPatterns.some(pattern => pattern.test(bodyText));
                    }
                    return isSold || bodyContainsSold;
                }
                if (currentStatusFilter === 'available') {
                    // Check if item is NOT sold
                    const isSold = item.item.getAttribute('sold') === '1';
                    const bodyNode = item.item.querySelector('body');
                    let bodyContainsSold = false;
                    if (bodyNode) {
                        const bodyText = bodyNode.textContent.toLowerCase();
                        const soldPatterns = [
                            /%sold%/i,
                            /\bsold\b/i,
                            /\[sold\]/i,
                            /\(sold\)/i
                        ];
                        bodyContainsSold = soldPatterns.some(pattern => pattern.test(bodyText));
                    }
                    return !isSold && !bodyContainsSold;
                }
                if (!item.objectId) return false;
                if (currentStatusFilter === 'own') return userCollection.has(item.objectId);
                if (currentStatusFilter === 'wanttoplay') return userWantToPlay.has(item.objectId);
                if (currentStatusFilter === 'wanttobuy') return userWantToBuy.has(item.objectId);
                if (currentStatusFilter === 'wantintrade') return userWantInTrade.has(item.objectId);
                if (currentStatusFilter === 'prevowned') return userPrevOwned.has(item.objectId);
                if (currentStatusFilter === 'tradingaway') return userTradingAway.has(item.objectId);
                return false;
            });
        }
        
        // Filter by seller if set
        if (currentSellerFilter) {
            filtered = filtered.filter(item => {
                const seller = item.item.getAttribute('username') || '';
                return seller.trim() === currentSellerFilter;
            });
        }
        const toShow = filtered.slice(0, loadedCount + PAGE_SIZE);
        let html = '';
        toShow.forEach((item, idx) => {
            // Extract seller name from username attribute
            const seller = item.item.getAttribute('username') || '';
            
            // Format seller display with name and username
            let sellerDisplay = seller;
            if (item.userDetails && item.userDetails.name) {
                sellerDisplay = `${item.userDetails.name} (${seller})`;
                if (item.userDetails.location) {
                    sellerDisplay += ` - ${item.userDetails.location}`;
                }
            }
            
            // Check if item is sold
            const isSold = item.item.getAttribute('sold') === '1';
            
            // Extract price and type from body text or price attribute
            let price = '';
            let priceType = '';
            let soldIndicator = '';
            
            // Check for sold in body text (case insensitive patterns)
            const bodyNode = item.item.querySelector('body');
            let bodyText = '';
            if (bodyNode) {
                bodyText = bodyNode.textContent.toLowerCase();
            }
            
            // Check for various sold patterns in body text
            const soldPatterns = [
                /%sold%/i,
                /\bsold\b/i,
                /\[sold\]/i,
                /\(sold\)/i
            ];
            const bodyContainsSold = soldPatterns.some(pattern => pattern.test(bodyText));
            
            // Determine if item is sold from either attribute or body text
            const itemIsSold = isSold || bodyContainsSold;
            
            if (itemIsSold) {
                soldIndicator = '<span style="color:#ff0000; font-weight:bold; font-size:1.1em;">SOLD</span>';
            }
            
            // Try to get price from price attribute first
            const priceAttr = item.item.getAttribute('price');
            const currencyAttr = item.item.getAttribute('currency') || 'USD';
            
            if (priceAttr) {
                price = `$${priceAttr}`;
                priceType = 'Listed Price';
            } else if (bodyNode) {
                const bodyTextOrig = bodyNode.textContent;
                // Try to extract [FP:] $xx or $xx
                const fpMatch = bodyTextOrig.match(/\[FP:?\][^$]*\$([0-9]+(?:\.[0-9]{2})?)/i);
                if (fpMatch) {
                    price = `$${fpMatch[1]}`;
                    priceType = 'Fixed Price';
                } else {
                    // BIN
                    const binMatch = bodyTextOrig.match(/BIN[^$]*\$([0-9]+(?:\.[0-9]{2})?)/i);
                    if (binMatch) {
                        price = `$${binMatch[1]}`;
                        priceType = 'Buy It Now';
                    } else {
                        // Starting Bid
                        const sbMatch = bodyTextOrig.match(/Starting Bid[^$]*\$([0-9]+(?:\.[0-9]{2})?)/i);
                        if (sbMatch) {
                            price = `$${sbMatch[1]}`;
                            priceType = 'Starting Bid';
                        } else {
                            // Available
                            const availMatch = bodyTextOrig.match(/Available[^$]*\$([0-9]+(?:\.[0-9]{2})?)/i);
                            if (availMatch) {
                                price = `$${availMatch[1]}`;
                                priceType = 'Available';
                            } else {
                                // Fallback: any $xx
                                const dollarMatch = bodyTextOrig.match(/\$([0-9]+(?:\.[0-9]{2})?)/);
                                if (dollarMatch) {
                                    price = `$${dollarMatch[1]}`;
                                    priceType = '';
                                }
                            }
                        }
                    }
                }
            }
            // Card border color by year
            let borderColor = '';
            const year = String(item.geeklistName).match(/(202[3-5])/);
            if (year) {
                if (year[1] === '2025') borderColor = '3px solid #2ecc40'; // green
                else if (year[1] === '2024') borderColor = '3px solid #ffe066'; // yellow
                else borderColor = '3px solid #ff4136'; // red
            } else {
                borderColor = '3px solid #ff4136'; // default to red
            }
            // Determine all applicable collection status emojis
            let statusEmojis = [];
            let statusTitles = [];
            if (item.objectId) {
                if (userCollection.has(item.objectId)) { 
                    statusEmojis.push('✅'); 
                    statusTitles.push('Own'); 
                }
                if (userWantToPlay.has(item.objectId)) { 
                    statusEmojis.push('🎮'); 
                    statusTitles.push('Want to Play'); 
                }
                if (userWantToBuy.has(item.objectId)) { 
                    statusEmojis.push('🛒'); 
                    statusTitles.push('Want to Buy'); 
                }
                if (userWantInTrade.has(item.objectId)) { 
                    statusEmojis.push('🔄'); 
                    statusTitles.push('Want in Trade'); 
                }
                if (userPrevOwned.has(item.objectId)) { 
                    statusEmojis.push('⏪'); 
                    statusTitles.push('Previously Owned'); 
                }
                if (userTradingAway.has(item.objectId)) { 
                    statusEmojis.push('📤'); 
                    statusTitles.push('Trading Away'); 
                }
            }
            
            // Create combined emoji string and title
            const statusEmoji = statusEmojis.join('');
            const statusTitle = statusTitles.join(', ');
            
            // Calculate time since posting (only if within last 24 hours)
            let timeIndicator = '';
            if (item.postdate) {
                const postDate = new Date(item.postdate);
                const now = new Date();
                const diffMs = now - postDate;
                const diffHours = diffMs / (1000 * 60 * 60);
                
                if (diffHours <= 24) {
                    const timeColors = getTimeGradientColor(diffHours);
                    if (diffHours < 1) {
                        const diffMinutes = Math.floor(diffMs / (1000 * 60));
                        timeIndicator = `<span style='position:absolute; bottom:8px; right:12px; background:${timeColors.bg}; color:${timeColors.text}; padding:0.2em 0.5em; border-radius:12px; font-size:0.75em; font-weight:600; z-index:2;'>${diffMinutes}m ago</span>`;
                    } else {
                        const hours = Math.floor(diffHours);
                        timeIndicator = `<span style='position:absolute; bottom:8px; right:12px; background:${timeColors.bg}; color:${timeColors.text}; padding:0.2em 0.5em; border-radius:12px; font-size:0.75em; font-weight:600; z-index:2;'>${hours}h ago</span>`;
                    }
                }
            }
            
            // Get rank and bayes colors if details are available
            let rankStyle = 'background:rgba(128,128,128,0.9); color:white;';
            let bayesStyle = 'background:rgba(128,128,128,0.9); color:white;';
            if (item.details?.bggRank) {
                const rankColors = getRankGradientColor(item.details.bggRank);
                rankStyle = `background:${rankColors.bg}; color:${rankColors.text};`;
            }
            if (item.details?.bayesAverage) {
                const bayesColors = getBayesGradientColor(item.details.bayesAverage);
                bayesStyle = `background:${bayesColors.bg}; color:${bayesColors.text};`;
            }
            
            html += `<div class='game-card' id='vfmcard-${idx}' data-object-id='${item.objectId}' style='border:${borderColor}; position:relative;'>
                ${statusEmoji ? `<span style='position:absolute; top:8px; right:12px; font-size:1.4em; z-index:2; line-height:1; letter-spacing:-2px;' title='${statusTitle}'>${statusEmoji}</span>` : ''}
                <span class='bgg-rank-indicator' style='position:absolute; top:8px; left:12px; ${rankStyle} padding:0.2em 0.5em; border-radius:8px; font-size:0.75em; font-weight:600; z-index:2; ${item.details?.bggRank ? 'display:block;' : 'display:none;'}'>${item.details?.bggRank ? `#${item.details.bggRank}` : ''}</span>
                ${timeIndicator}
                <img src='${item.details?.thumbnail || ''}' alt='${item.name} thumbnail' class='game-thumb' style='width:64px; height:64px; border-radius:10px; margin-right:1em; object-fit:cover; ${item.details?.thumbnail ? 'display:block;' : 'display:none;'}'>
                <span class='bayes-avg-indicator' style='position:absolute; bottom:8px; left:12px; ${bayesStyle} padding:0.2em 0.5em; border-radius:8px; font-size:0.75em; font-weight:600; z-index:2; ${item.details?.bayesAverage ? 'display:block;' : 'display:none;'}'>${item.details?.bayesAverage || ''}</span>
                <div class='game-info'>
                    <div class='game-title'>${item.name}</div>
                    <div class='geeklist-label'>${item.geeklistName}</div>
                    <div class='game-details'>
                        <b>Seller:</b> ${sellerDisplay}<br>
                        <b>Price:</b> ${price || 'N/A'}${priceType ? ` <span style='font-size:0.95em; color:#1976d2;'>(${priceType})</span>` : ''}${soldIndicator ? ` ${soldIndicator}` : ''}<br>
                        ${item.details?.year ? `<b>Year:</b> ${item.details.year}<br>` : ''}
                        <b>Post Date:</b> ${item.postdate ? new Date(item.postdate).toLocaleString() : 'N/A'}<br>
                        ${item.commentData && item.commentData.length > 0 ? `<b>Comments:</b> ${item.commentData.length} <button class='viewCommentsBtn' data-idx='${idx}' style='background:#ff9800; color:#fff; border:none; border-radius:6px; padding:0.2em 0.5em; font-size:0.8em; margin-left:0.3em; cursor:pointer;'>View</button><br>` : ''}
                        ${item.objectId ? `<a href='https://boardgamegeek.com/boardgame/${item.objectId}' target='_blank' style='color:#1976d2;'>View on BGG</a>` : ''}<br>
                        <a href='https://boardgamegeek.com/geeklist/${item.geeklistId}?itemid=${item.item.getAttribute('id')}' target='_blank' style='color:#1976d2;'>View Geeklisting</a><br>
                        <button class='viewDetailBtn' data-idx='${idx}' style='margin-top:0.7em; background:#1976d2; color:#fff; font-size:1em; padding:0.5em 1.2em; border-radius:8px; border:none; width:100%; max-width:180px;'>View Details</button>
                    </div>
                </div>
            </div>`;
        });
        gamesCardWrapper.innerHTML = html;
        // Show loading indicator if still loading
        if (loading) {
            const loadingStatusEl = document.getElementById('loadingStatus');
            if (loadingStatusEl) {
                // If we have items to show, move the loading status to the top
                if (html) {
                    gamesCardWrapper.innerHTML = `<div style="text-align:center; color:#888; font-size:0.9em; background:#f0f0f0; padding:0.5em; border-radius:8px; margin-bottom:1em;" id="loadingStatus">${loadingStatusEl.innerHTML}</div>` + html;
                }
            }
            loadMoreWrapper.innerHTML = '';
        } else if (toShow.length < filtered.length) {
            loadMoreWrapper.innerHTML = `<button id='loadMoreBtn' style='background:#1976d2; color:#fff; border:none; border-radius:8px; padding:0.7em 2em; font-size:1.1em; font-weight:600; cursor:pointer;'>Load More</button>`;
            document.getElementById('loadMoreBtn').onclick = () => {
                loadedCount += PAGE_SIZE;
                renderItems(filterInput.value.trim());
            };
        } else {
            loadMoreWrapper.innerHTML = '';
        }
        // Fetch thumbnails/details asynchronously and update cards
        toShow.forEach((item, idx) => {
            if (item.objectType === 'thing' && item.objectId && !item.details) {
                fetchThingDetails(item.objectId).then(details => {
                    item.details = details;
                    // Find the card using the objectId data attribute for more reliable matching
                    const card = document.querySelector(`[data-object-id="${item.objectId}"]`);
                    if (card && details.thumbnail) {
                        const img = card.querySelector('.game-thumb');
                        if (img) {
                            img.src = details.thumbnail;
                            img.alt = `${item.name} thumbnail`;
                            img.style.display = 'block';
                        }
                    }
                    if (card && details.year) {
                        const info = card.querySelector('.game-details');
                        if (info && !info.textContent.includes('Year:')) {
                            info.innerHTML += `<b>Year:</b> ${details.year}<br>`;
                        }
                    }
                    // Update BGG rank display
                    if (card && details.bggRank) {
                        const rankSpan = card.querySelector('.bgg-rank-indicator');
                        if (rankSpan) {
                            const rankColors = getRankGradientColor(details.bggRank);
                            rankSpan.textContent = `#${details.bggRank}`;
                            rankSpan.style.background = rankColors.bg;
                            rankSpan.style.color = rankColors.text;
                            rankSpan.style.display = 'block';
                        }
                    }
                    // Update Bayes average display
                    if (card && details.bayesAverage) {
                        const bayesSpan = card.querySelector('.bayes-avg-indicator');
                        if (bayesSpan) {
                            const bayesColors = getBayesGradientColor(details.bayesAverage);
                            bayesSpan.textContent = `${details.bayesAverage}`;
                            bayesSpan.style.background = bayesColors.bg;
                            bayesSpan.style.color = bayesColors.text;
                            bayesSpan.style.display = 'block';
                        }
                    }
                });
            }
        });
        
        // Fetch user details asynchronously and update seller display
        toShow.forEach((item, idx) => {
            if (item.username && !item.userDetails) {
                fetchUserDetails(item.username).then(userDetails => {
                    item.userDetails = userDetails;
                    // Update the seller display in the card
                    const card = document.querySelector(`#vfmcard-${idx}`);
                    if (card && (userDetails.name || userDetails.location)) {
                        const gameDetails = card.querySelector('.game-details');
                        if (gameDetails) {
                            let sellerDisplay = item.username;
                            if (userDetails.name) {
                                sellerDisplay = `${userDetails.name} (${item.username})`;
                                if (userDetails.location) {
                                    sellerDisplay += ` - ${userDetails.location}`;
                                }
                            }
                            gameDetails.innerHTML = gameDetails.innerHTML.replace(
                                new RegExp(`<b>Seller:</b> ${item.username}`),
                                `<b>Seller:</b> ${sellerDisplay}`
                            );
                        }
                    }
                });
            }
        });
        
        // Modal logic for View Details
        document.querySelectorAll('.viewDetailBtn').forEach(btn => {
            btn.onclick = () => {
                const idx = btn.getAttribute('data-idx');
                const item = toShow[idx];
                const details = item.details || {};
                // Extract seller name and price again for modal
                const seller = item.item.getAttribute('username') || '';
                
                // Format seller display with name and username for modal
                let sellerDisplay = seller;
                if (item.userDetails && item.userDetails.name) {
                    sellerDisplay = `${item.userDetails.name} (${seller})`;
                    if (item.userDetails.location) {
                        sellerDisplay += ` - ${item.userDetails.location}`;
                    }
                }
                
                // Check if item is sold
                const isSold = item.item.getAttribute('sold') === '1';
                
                let price = '';
                let soldIndicator = '';
                
                // Check for sold in body text (case insensitive patterns)
                const bodyNode = item.item.querySelector('body');
                let bodyText = '';
                if (bodyNode) {
                    bodyText = bodyNode.textContent.toLowerCase();
                }
                
                // Check for various sold patterns in body text
                const soldPatterns = [
                    /%sold%/i,
                    /\bsold\b/i,
                    /\[sold\]/i,
                    /\(sold\)/i
                ];
                const bodyContainsSold = soldPatterns.some(pattern => pattern.test(bodyText));
                
                // Determine if item is sold from either attribute or body text
                const itemIsSold = isSold || bodyContainsSold;
                
                if (itemIsSold) {
                    soldIndicator = '<span style="color:#ff0000; font-weight:bold; font-size:1.1em;">SOLD</span>';
                }
                
                // Try to get price from price attribute first
                const priceAttr = item.item.getAttribute('price');
                const currencyAttr = item.item.getAttribute('currency') || 'USD';
                
                if (priceAttr) {
                    price = `$${priceAttr}`;
                } else if (bodyNode) {
                    const bodyTextOrig = bodyNode.textContent;
                    const fpMatch = bodyTextOrig.match(/\[FP:?\][^$]*\$([0-9]+(?:\.[0-9]{2})?)/i);
                    if (fpMatch) price = `$${fpMatch[1]}`;
                    else {
                        const dollarMatch = bodyTextOrig.match(/\$([0-9]+(?:\.[0-9]{2})?)/);
                        if (dollarMatch) price = `$${dollarMatch[1]}`;
                    }
                }
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.position = 'fixed';
                modal.style.left = '0';
                modal.style.top = '0';
                modal.style.width = '100vw';
                modal.style.height = '100vh';
                modal.style.background = 'rgba(0,0,0,0.25)';
                modal.style.display = 'flex';
                modal.style.alignItems = 'center';
                modal.style.justifyContent = 'center';
                modal.style.zIndex = '9999';
                modal.style.padding = 'env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)';
                modal.style.boxSizing = 'border-box';
                const content = document.createElement('div');
                content.style.maxWidth = '390px';
                content.style.width = '90vw';
                content.style.background = '#fff';
                content.style.borderRadius = '16px';
                content.style.boxShadow = '0 4px 20px rgba(0,0,0,0.15)';
                content.style.padding = '1.5em 1em 1.2em 1em';
                content.style.maxHeight = '85vh';
                content.style.overflowY = 'auto';
                content.style.margin = '1em';
                content.style.position = 'relative';
                // Extract all attributes from item XML
                const attrs = item.item.attributes;
                let attrHtml = '';
                for (let i = 0; i < attrs.length; i++) {
                    const attr = attrs[i];
                    attrHtml += `<b>${attr.name}:</b> ${attr.value}<br>`;
                }
                // Extract body content
                let bodyHtml = '';
                if (bodyNode) {
                    const formattedBody = formatBGGText(bodyNode.textContent);
                    bodyHtml = `<div style='margin-top:1em; font-size:0.98em; color:#333; background:#f7f7fa; padding:0.7em; border-radius:8px;'><b>Listing Details:</b><br>${formattedBody}</div>`;
                }
                
                // Add comments section if available
                let commentsHtml = '';
                if (item.commentData && item.commentData.length > 0) {
                    commentsHtml = `<div style='margin-top:1em; font-size:0.98em; color:#333; background:#fff3e0; padding:0.7em; border-radius:8px; border-left:4px solid #ff9800;'>
                        <b>Comments (${item.commentData.length}):</b><br>`;
                    item.commentData.forEach((comment, idx) => {
                        const commentDate = comment.date ? new Date(comment.date).toLocaleString() : 'N/A';
                        const formattedComment = formatBGGText(comment.content);
                        commentsHtml += `<div style='margin-top:0.5em; padding:0.5em; background:#f5f5f5; border-radius:6px; border-left:3px solid #ff9800;'>
                            <div style='font-weight:600; color:#ff9800; font-size:0.9em;'>${comment.username} - ${commentDate}</div>
                            <div style='margin-top:0.3em;'>${formattedComment}</div>
                        </div>`;
                    });
                    commentsHtml += `</div>`;
                }
                
                content.innerHTML = `
                    <h2 style='font-size:1.2em; margin-bottom:0.7em;'>${item.name}</h2>
                    ${details.thumbnail ? `<img src='${details.thumbnail}' alt='${item.name} thumbnail' style='width:80px; height:80px; border-radius:12px; margin-bottom:1em; object-fit:cover;'>` : ''}
                    <div style='font-size:1em; text-align:left; background:#f7f7fa; padding:1em; border-radius:8px; margin-bottom:1em;'>
                        <b>Seller:</b> ${sellerDisplay}<br>
                        <b>Price:</b> ${price || 'N/A'}${soldIndicator ? ` ${soldIndicator}` : ''}<br>
                        ${attrHtml}
                        <b>Year:</b> ${details.year || 'N/A'}<br>
                        ${details.bggRank ? `<b>BGG Rank:</b> #${details.bggRank}<br>` : ''}
                        ${details.bayesAverage ? `<b>Bayes Average:</b> ${details.bayesAverage}<br>` : ''}
                        ${item.objectId ? `<a href='https://boardgamegeek.com/boardgame/${item.objectId}' target='_blank' style='color:#1976d2;'>View on BGG</a><br>` : ''}
                        <a href='https://boardgamegeek.com/geeklist/${item.geeklistId}?itemid=${item.item.getAttribute('id')}' target='_blank' style='color:#1976d2;'>View Geeklisting</a>
                    </div>
                    ${bodyHtml}
                    ${commentsHtml}
                    <button id='closeModalBtn' style='margin-top:1.5em; background:#1976d2; color:#fff; font-size:1.1em; padding:0.8em 2em; border-radius:12px; border:none; width:100%; min-height:44px; font-weight:600; cursor:pointer; -webkit-appearance:none;'>Close</button>
                `;
                modal.appendChild(content);
                document.body.appendChild(modal);
                document.getElementById('closeModalBtn').onclick = () => {
                    document.body.removeChild(modal);
                };
            };
        });
        
        // Modal logic for View Comments
        document.querySelectorAll('.viewCommentsBtn').forEach(btn => {
            btn.onclick = (e) => {
                e.stopPropagation(); // Prevent triggering other click events
                const idx = btn.getAttribute('data-idx');
                const item = toShow[idx];
                
                if (!item.commentData || item.commentData.length === 0) {
                    alert('No comments available for this item.');
                    return;
                }
                
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.position = 'fixed';
                modal.style.left = '0';
                modal.style.top = '0';
                modal.style.width = '100vw';
                modal.style.height = '100vh';
                modal.style.background = 'rgba(0,0,0,0.25)';
                modal.style.display = 'flex';
                modal.style.alignItems = 'center';
                modal.style.justifyContent = 'center';
                modal.style.zIndex = '9999';
                modal.style.padding = 'env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)';
                modal.style.boxSizing = 'border-box';
                
                const content = document.createElement('div');
                content.style.maxWidth = '390px';
                content.style.width = '90vw';
                content.style.background = '#fff';
                content.style.borderRadius = '16px';
                content.style.boxShadow = '0 4px 20px rgba(0,0,0,0.15)';
                content.style.padding = '1.5em 1em 1.2em 1em';
                content.style.maxHeight = '85vh';
                content.style.overflowY = 'auto';
                content.style.margin = '1em';
                content.style.position = 'relative';
                
                let commentsHtml = `<h2 style='font-size:1.2em; margin-bottom:0.7em; color:#ff9800;'>💬 Comments for ${item.name}</h2>`;
                commentsHtml += `<div style='margin-bottom:1em; font-size:0.9em; color:#666;'>Total: ${item.commentData.length} comment${item.commentData.length !== 1 ? 's' : ''}</div>`;
                
                item.commentData.forEach((comment, idx) => {
                    const commentDate = comment.date ? new Date(comment.date).toLocaleString() : 'N/A';
                    const formattedComment = formatBGGText(comment.content);
                    commentsHtml += `<div style='margin-bottom:1em; padding:0.8em; background:#fff3e0; border-radius:8px; border-left:4px solid #ff9800;'>
                        <div style='font-weight:600; color:#ff9800; font-size:0.95em; margin-bottom:0.4em;'>
                            👤 ${comment.username} 
                            <span style='font-weight:normal; color:#666; font-size:0.85em;'>• ${commentDate}</span>
                        </div>
                        <div style='color:#333; line-height:1.4;'>${formattedComment}</div>
                    </div>`;
                });
                
                commentsHtml += `<button id='closeCommentsModalBtn' style='margin-top:1em; background:#ff9800; color:#fff; font-size:1.1em; padding:0.8em 2em; border-radius:12px; border:none; width:100%; min-height:44px; font-weight:600; cursor:pointer; -webkit-appearance:none;'>Close Comments</button>`;
                
                content.innerHTML = commentsHtml;
                modal.appendChild(content);
                document.body.appendChild(modal);
                
                document.getElementById('closeCommentsModalBtn').onclick = () => {
                    document.body.removeChild(modal);
                };
            };
        });
    }

    filterInput.addEventListener('input', () => {
        loadedCount = 0;
        renderItems(filterInput.value.trim());
    });

    fetchAllGeeklists();
    // Analytics button logic
    document.getElementById('analyticsBtn').onclick = () => {
        // Prepare analytics data
        // 1. Records per geeklist
        const recordsPerGeeklist = {};
        geeklists.forEach(g => { recordsPerGeeklist[g.name] = 0; });
        allItems.forEach(item => {
            const gname = geeklists.find(g => g.id == item.geeklistId)?.name;
            if (gname) recordsPerGeeklist[gname]++;
        });
        // 2. Records listed per month
        const recordsPerMonth = {};
        allItems.forEach(item => {
            if (item.postdate) {
                const d = new Date(item.postdate);
                const key = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`;
                recordsPerMonth[key] = (recordsPerMonth[key]||0)+1;
            }
        });
        // 3. Most listed games per geeklist
        const mostListedGamesPerGeeklist = {};
        geeklists.forEach(g => { mostListedGamesPerGeeklist[g.name] = {}; });
        allItems.forEach(item => {
            const gname = geeklists.find(g => g.id == item.geeklistId)?.name;
            if (gname) {
                const n = item.name;
                mostListedGamesPerGeeklist[gname][n] = (mostListedGamesPerGeeklist[gname][n]||0)+1;
            }
        });
        // 4. Most listed games overall
        const mostListedGamesOverall = {};
        allItems.forEach(item => {
            const n = item.name;
            mostListedGamesOverall[n] = (mostListedGamesOverall[n]||0)+1;
        });
        
        // 5. Most active sellers
        const mostActiveSellers = {};
        allItems.forEach(item => {
            const seller = item.item.getAttribute('username') || 'Unknown';
            mostActiveSellers[seller] = (mostActiveSellers[seller]||0)+1;
        });
        // Modal UI
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.style.position = 'fixed';
        modal.style.left = '0';
        modal.style.top = '0';
        modal.style.width = '100vw';
        modal.style.height = '100vh';
        modal.style.background = 'rgba(0,0,0,0.25)';
        modal.style.display = 'flex';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
        modal.style.zIndex = '9999';
        modal.style.padding = 'env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)';
        modal.style.boxSizing = 'border-box';
        const content = document.createElement('div');
        content.style.maxWidth = '390px';
        content.style.width = '90vw';
        content.style.background = '#fff';
        content.style.borderRadius = '16px';
        content.style.boxShadow = '0 4px 20px rgba(0,0,0,0.15)';
        content.style.padding = '1.5em 1em 1.2em 1em';
        content.style.maxHeight = '85vh';
        content.style.overflowY = 'auto';
        content.style.margin = '1em';
        content.style.position = 'relative';
        // Tabs
        content.innerHTML = `
            <h2 style='font-size:1.3em; margin-bottom:1em; font-weight:600;'>Analytics Dashboard</h2>
            <div style='display:flex; gap:0.4em; margin-bottom:1.2em; flex-wrap:wrap;'>
                <button id='tabRecordsGeeklist' style='background:#43a047; color:#fff; border:none; border-radius:10px; padding:0.6em 0.8em; font-size:0.9em; min-height:40px; flex:1; min-width:80px; font-weight:600; cursor:pointer; -webkit-appearance:none;'>Records per Geeklist</button>
                <button id='tabRecordsMonth' style='background:#1976d2; color:#fff; border:none; border-radius:10px; padding:0.6em 0.8em; font-size:0.9em; min-height:40px; flex:1; min-width:80px; font-weight:600; cursor:pointer; -webkit-appearance:none;'>Records per Month</button>
                <button id='tabMostListedGeeklist' style='background:#f7b731; color:#222; border:none; border-radius:10px; padding:0.6em 0.8em; font-size:0.9em; min-height:40px; flex:1; min-width:80px; font-weight:600; cursor:pointer; -webkit-appearance:none;'>Most Listed per Geeklist</button>
                <button id='tabMostListedOverall' style='background:#ff4136; color:#fff; border:none; border-radius:10px; padding:0.6em 0.8em; font-size:0.9em; min-height:40px; flex:1; min-width:80px; font-weight:600; cursor:pointer; -webkit-appearance:none;'>Most Listed Overall</button>
                <button id='tabMostActiveSellers' style='background:#ff9800; color:#fff; border:none; border-radius:10px; padding:0.6em 0.8em; font-size:0.9em; min-height:40px; flex:1; min-width:80px; font-weight:600; cursor:pointer; -webkit-appearance:none;'>Most Active Sellers</button>
            </div>
            <div id='analyticsContent' style='font-size:1em; line-height:1.5;'></div>
            <button id='closeAnalyticsBtn' style='margin-top:1.5em; background:#1976d2; color:#fff; font-size:1.1em; padding:0.8em 2em; border-radius:12px; border:none; width:100%; min-height:44px; font-weight:600; cursor:pointer; -webkit-appearance:none;'>Close</button>
        `;
        modal.appendChild(content);
        document.body.appendChild(modal);
        // Tab logic
        function showTab(tab) {
            const ac = content.querySelector('#analyticsContent');
            if (tab === 'geeklist') {
                ac.innerHTML = `<b>Records per Geeklist:</b><br>` +
                    `<ul style='margin-top:0.5em;'>` +
                    Object.entries(recordsPerGeeklist).map(([k,v]) => `<li><b>${k}:</b> ${v}</li>`).join('') +
                    `</ul>`;
            } else if (tab === 'month') {
                ac.innerHTML = `<b>Records Listed per Month:</b><br>` +
                    `<ul style='margin-top:0.5em;'>` +
                    Object.entries(recordsPerMonth).sort((a,b)=>b[0].localeCompare(a[0])).map(([k,v]) => `<li><b>${k}:</b> ${v}</li>`).join('') +
                    `</ul>`;
            } else if (tab === 'mostgeeklist') {
                ac.innerHTML = `<b>Most Listed Games per Geeklist (Top 10):</b><br>` +
                    Object.entries(mostListedGamesPerGeeklist).map(([g, games]) => {
                        const sorted = Object.entries(games).sort((a,b)=>b[1]-a[1]).slice(0,10);
                        return `<div style='margin-top:0.7em;'><b>${g}:</b><ul>` + sorted.map(([n,c]) => `<li>${n} (${c})</li>`).join('') + `</ul></div>`;
                    }).join('');
            } else if (tab === 'mostoverall') {
                const sorted = Object.entries(mostListedGamesOverall).sort((a,b)=>b[1]-a[1]).slice(0,25);
                ac.innerHTML = `<b>Most Listed Games Overall (Top 25):</b><br><ul style='margin-top:0.5em;'>` +
                    sorted.map(([n,c]) => `<li>${n} (${c})</li>`).join('') +
                    `</ul>`;
            } else if (tab === 'sellers') {
                const sorted = Object.entries(mostActiveSellers).sort((a,b)=>b[1]-a[1]).slice(0,25);
                ac.innerHTML = `<b>Most Active Sellers (Top 25):</b><br><ul style='margin-top:0.5em;'>` +
                    sorted.map(([seller,count]) => `<li><b>${seller}:</b> ${count} listings</li>`).join('') +
                    `</ul>`;
            }
        }
        content.querySelector('#tabRecordsGeeklist').onclick = () => showTab('geeklist');
        content.querySelector('#tabRecordsMonth').onclick = () => showTab('month');
        content.querySelector('#tabMostListedGeeklist').onclick = () => showTab('mostgeeklist');
        content.querySelector('#tabMostListedOverall').onclick = () => showTab('mostoverall');
        content.querySelector('#tabMostActiveSellers').onclick = () => showTab('sellers');
        content.querySelector('#closeAnalyticsBtn').onclick = () => {
            document.body.removeChild(modal);
        };
        showTab('geeklist');
    };
    // Status filter button logic
    const statusFilterBtn = document.getElementById('statusFilterBtn');
    const statusFilterSelect = document.getElementById('statusFilterSelect');
    statusFilterBtn.onclick = () => {
        statusFilterSelect.style.display = statusFilterSelect.style.display === 'none' ? 'inline-block' : 'none';
        // Hide seller filter if it's open
        document.getElementById('sellerFilterContainer').style.display = 'none';
        document.getElementById('sellerSuggestions').style.display = 'none';
    };
    statusFilterSelect.onchange = (e) => {
        currentStatusFilter = e.target.value;
        loadedCount = 0;
        renderItems(filterInput.value.trim());
    };
    
    // Seller filter button logic
    const sellerFilterBtn = document.getElementById('sellerFilterBtn');
    const sellerFilterContainer = document.getElementById('sellerFilterContainer');
    const sellerFilterInput = document.getElementById('sellerFilterInput');
    const sellerSuggestions = document.getElementById('sellerSuggestions');
    
    sellerFilterBtn.onclick = () => {
        const isVisible = sellerFilterContainer.style.display !== 'none';
        sellerFilterContainer.style.display = isVisible ? 'none' : 'block';
        // Hide status filter if it's open
        document.getElementById('statusFilterSelect').style.display = 'none';
        
        if (!isVisible) {
            sellerFilterInput.focus();
            if (sellerFilterInput.value === '') {
                showSellerSuggestions('');
            }
        } else {
            sellerSuggestions.style.display = 'none';
        }
    };
    
    sellerFilterInput.addEventListener('input', (e) => {
        const searchTerm = e.target.value.trim();
        showSellerSuggestions(searchTerm);
        
        // If input is cleared, clear the filter
        if (searchTerm === '') {
            currentSellerFilter = '';
            loadedCount = 0;
            renderItems(filterInput.value.trim());
        }
    });
    
    sellerFilterInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            const searchTerm = e.target.value.trim();
            if (searchTerm) {
                // Use exact match for entered text
                currentSellerFilter = searchTerm;
                sellerSuggestions.style.display = 'none';
                loadedCount = 0;
                renderItems(filterInput.value.trim());
            }
        } else if (e.key === 'Escape') {
            sellerSuggestions.style.display = 'none';
            sellerFilterContainer.style.display = 'none';
        }
    });
    
    // Hide suggestions when clicking outside
    document.addEventListener('click', (e) => {
        if (!sellerFilterContainer.contains(e.target) && !sellerFilterBtn.contains(e.target)) {
            sellerSuggestions.style.display = 'none';
        }
    });
    
    // Geeklist filter logic
    const geeklistFilterBtn = document.getElementById('geeklistFilterBtn');
    const geeklistFilterPanel = document.getElementById('geeklistFilterPanel');
    const geeklistCheckboxes = document.getElementById('geeklistCheckboxes');
    
    // Initialize geeklist checkboxes
    function initializeGeeklistFilter() {
        geeklistCheckboxes.innerHTML = '';
        geeklists.forEach(geeklist => {
            const checkboxDiv = document.createElement('div');
            checkboxDiv.style.display = 'flex';
            checkboxDiv.style.alignItems = 'center';
            checkboxDiv.style.gap = '0.5em';
            checkboxDiv.style.padding = '0.3em 0';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `geeklist-${geeklist.id}`;
            checkbox.checked = selectedGeeklists.has(geeklist.id);
            checkbox.style.transform = 'scale(1.2)';
            
            const label = document.createElement('label');
            label.htmlFor = `geeklist-${geeklist.id}`;
            label.textContent = geeklist.name;
            label.style.fontSize = '0.95em';
            label.style.cursor = 'pointer';
            label.style.flex = '1';
            
            // Add item count
            const count = allItems.filter(item => item.geeklistId === geeklist.id).length;
            const countSpan = document.createElement('span');
            countSpan.textContent = `(${count})`;
            countSpan.style.fontSize = '0.85em';
            countSpan.style.color = '#666';
            countSpan.style.marginLeft = '0.3em';
            
            checkboxDiv.appendChild(checkbox);
            checkboxDiv.appendChild(label);
            checkboxDiv.appendChild(countSpan);
            geeklistCheckboxes.appendChild(checkboxDiv);
        });
    }
    
    geeklistFilterBtn.onclick = () => {
        const isVisible = geeklistFilterPanel.style.display !== 'none';
        geeklistFilterPanel.style.display = isVisible ? 'none' : 'block';
        if (!isVisible) {
            initializeGeeklistFilter();
        }
    };
    
    document.getElementById('selectAllGeeklists').onclick = () => {
        geeklists.forEach(geeklist => {
            const checkbox = document.getElementById(`geeklist-${geeklist.id}`);
            if (checkbox) checkbox.checked = true;
        });
    };
    
    document.getElementById('deselectAllGeeklists').onclick = () => {
        geeklists.forEach(geeklist => {
            const checkbox = document.getElementById(`geeklist-${geeklist.id}`);
            if (checkbox) checkbox.checked = false;
        });
    };
    
    document.getElementById('applyGeeklistFilter').onclick = () => {
        selectedGeeklists.clear();
        geeklists.forEach(geeklist => {
            const checkbox = document.getElementById(`geeklist-${geeklist.id}`);
            if (checkbox && checkbox.checked) {
                selectedGeeklists.add(geeklist.id);
            }
        });
        
        // Update button text to show active filter
        const selectedCount = selectedGeeklists.size;
        const totalCount = geeklists.length;
        if (selectedCount === totalCount) {
            geeklistFilterBtn.textContent = '📋 Lists';
            geeklistFilterBtn.style.background = '#8e24aa';
        } else {
            geeklistFilterBtn.textContent = `📋 Lists (${selectedCount})`;
            geeklistFilterBtn.style.background = '#f39c12';
        }
        
        geeklistFilterPanel.style.display = 'none';
        loadedCount = 0;
        renderItems(filterInput.value.trim());
    };
    
    // Filter mode button logic
    const filterModeButtons = [
        document.getElementById('exactMatchBtn'),
        document.getElementById('startsWithBtn'), 
        document.getElementById('containsBtn')
    ];
    
    filterModeButtons.forEach(btn => {
        btn.onclick = () => {
            // Update active button styling
            filterModeButtons.forEach(b => {
                b.style.background = '#666';
                b.style.color = '#fff';
            });
            btn.style.background = '#1976d2';
            btn.style.color = '#fff';
            
            // Update filter mode
            currentFilterMode = btn.getAttribute('data-mode');
            
            // Re-render with current filter
            loadedCount = 0;
            renderItems(filterInput.value.trim());
        };
    });
    </script>
</body>
</html>
