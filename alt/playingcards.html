<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Playing Cards - Boardgames Hub</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: fixed;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        .container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        /* Login/Sort Selection Screen */
        .sort-selection {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
        }
        .sort-title {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 30px;
            text-align: center;
            color: #1e40af;
        }
        .sort-subtitle {
            font-size: 1.2em;
            color: #ccc;
            text-align: center;
            margin-bottom: 50px;
            line-height: 1.4;
        }
        .sort-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
            max-width: 300px;
        }
        .sort-button {
            background: linear-gradient(135deg, #1976d2 0%, #1565c0 100%);
            color: #fff;
            border: none;
            border-radius: 15px;
            padding: 20px;
            font-size: 1.3em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(25, 118, 210, 0.3);
        }
        .sort-button:hover, .sort-button:active {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(25, 118, 210, 0.4);
        }
        .sort-button.random {
            background: linear-gradient(135deg, #374151 0%, #1f2937 100%);
            box-shadow: 0 4px 15px rgba(55, 65, 81, 0.3);
        }
        .sort-button.random:hover, .sort-button.random:active {
            box-shadow: 0 6px 20px rgba(55, 65, 81, 0.4);
        }
        .sort-button.active {
            background: linear-gradient(135deg, #1e40af 0%, #1d4ed8 100%);
            box-shadow: 0 4px 15px rgba(30, 64, 175, 0.3);
            transform: translateY(-2px);
        }
        
        /* Card Viewing Screen */
        .card-viewer {
            width: 100%;
            height: 100%;
            display: none;
            position: relative;
            overflow: hidden;
        }
        .cards-stack {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .game-card {
            width: 90vw;
            max-width: 350px;
            height: 88vh;
            background: linear-gradient(135deg, #2c2c2c 0%, #1a1a1a 100%);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            text-align: center;
            padding: 20px 15px;
            box-sizing: border-box;
            position: absolute;
            cursor: grab;
            transition: transform 0.3s ease;
            transform-origin: center;
        }
        .game-card.dragging {
            cursor: grabbing;
            transition: none;
        }
        .game-card.swipe-left {
            transform: translateX(-100vw) rotate(-30deg);
            opacity: 0;
        }
        .game-card.swipe-right {
            transform: translateX(100vw) rotate(30deg);
            opacity: 0;
        }
        .player-count {
            font-size: 1.5em;
            font-weight: bold;
            color: #ff6b35;
            margin-bottom: 8px;
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 0 0 auto;
        }
        .player-numbers {
            display: flex;
            gap: 3px;
            align-items: center;
            justify-content: center;
            flex-wrap: nowrap;
            overflow-x: auto;
            padding: 0 10px;
            margin-bottom: 8px;
        }
        .player-number {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            border: 2px solid #374151;
            color: #9ca3af;
            background: transparent;
            flex-shrink: 0;
        }
        .player-number.active {
            background: transparent;
            color: #9ca3af;
            border-color: #374151;
        }
        .player-number.best {
            background: #22c55e;
            color: white;
            border-color: #16a34a;
        }
        .player-number.recommended {
            background: #eab308;
            color: white;
            border-color: #ca8a04;
        }
        .player-number.hidden {
            display: none;
        }
        .game-title {
            font-size: 1.4em;
            font-weight: 700;
            margin-bottom: 12px;
            line-height: 1.1;
            color: #fff;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
            flex: 0 0 auto;
        }
        .game-thumbnail {
            width: 140px;
            height: 140px;
            border-radius: 12px;
            object-fit: contain;
            margin-bottom: 12px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
            flex: 1;
            max-height: 180px;
            background: #333;
        }
        
        /* Thumbnail container with rating/rank circles */
        .thumbnail-container {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 12px;
        }
        
        /* BGG Rating circle (left edge of card) */
        .rating-circle {
            position: absolute;
            left: 15px;
            top: 45%;
            transform: translateY(-50%);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
            border: 2px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(5px);
            z-index: 10;
        }
        
        /* BGG Rank circle (right edge of card) */
        .rank-circle {
            position: absolute;
            right: 15px;
            top: 45%;
            transform: translateY(-50%);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
            border: 2px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(5px);
            z-index: 10;
        }
        .game-info {
            font-size: 0.85em;
            color: #ccc;
            line-height: 1.3;
            flex: 0 0 auto;
            width: 100%;
            max-height: 260px;
            overflow-y: auto;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 4px 6px;
        }
        .game-info .info-row {
            margin-bottom: 4px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        .info-label {
            color: #888;
            font-size: 0.8em;
            text-align: left;
            margin-bottom: 1px;
        }
        .info-value {
            color: #fff;
            font-weight: 500;
            text-align: left;
            font-size: 0.9em;
        }
        .year {
            color: #81c784;
        }
        .users-rated {
            color: #64b5f6;
        }
        .rank {
            color: #ffb74d;
            font-weight: 600;
        }
        .my-rating {
            color: #1e40af;
            font-weight: 600;
        }
        .plays {
            color: #e57373;
        }
        .weight {
            color: #ba68c8;
        }
        
        /* Back button for card view - now at bottom */
        .back-to-sort {
            position: absolute;
            bottom: 15px;
            left: 20px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .back-to-sort:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        /* Info button */
        .info-button {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        .info-button:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background: linear-gradient(135deg, #2c2c2c 0%, #1a1a1a 100%);
            margin: 10% auto;
            padding: 20px;
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            max-height: 70vh;
            overflow-y: auto;
            color: #fff;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #444;
        }
        .modal-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #fff;
        }
        .close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        .close:hover {
            color: #fff;
        }
        .modal-section {
            margin-bottom: 20px;
        }
        .modal-section h3 {
            color: #ff6b35;
            font-size: 1.1em;
            margin-bottom: 10px;
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
        }
        .modal-list {
            color: #ccc;
            line-height: 1.5;
        }
        .modal-list-item {
            margin-bottom: 5px;
            padding: 3px 0;
        }
        
        /* Progress indicator - adjusted for back button */
        .progress-indicator {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            font-size: 0.8em;
            color: #fff;
            z-index: 100;
            text-align: center;
            min-width: 120px;
        }
        
        /* Loading indicator - hidden, combined with progress */
        .loading-indicator {
            display: none !important;
        }
        
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-size: 1.5em;
            color: #666;
            flex-direction: column;
            gap: 20px;
        }
        .error {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-size: 1.2em;
            color: #f44336;
            text-align: center;
            padding: 20px;
        }
        
        /* iPhone specific optimizations */
        @media screen and (max-device-width: 414px) {
            .game-card {
                width: 95vw;
                height: 85vh;
                padding: 15px 12px;
            }
            .game-title {
                font-size: 1.2em;
            }
            .player-count {
                font-size: 1.4em;
                min-height: 25px;
            }
            .game-thumbnail {
                width: 120px;
                height: 120px;
                max-height: 140px;
            }
            .rating-circle, .rank-circle {
                width: 35px;
                height: 35px;
                font-size: 0.7em;
            }
            .rating-circle {
                left: 12px;
            }
            .rank-circle {
                right: 12px;
            }
            .game-info {
                font-size: 0.8em;
                max-height: 240px;
                gap: 3px 4px;
                grid-template-columns: 1fr 1fr 1fr;
            }
            .info-label {
                font-size: 0.75em;
            }
            .info-value {
                font-size: 0.85em;
            }
            .sort-title {
                font-size: 2em;
            }
            .sort-button {
                padding: 18px;
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Sort Selection Screen -->
        <div id="sortSelection" class="sort-selection">
            <div class="sort-title">üé≤ Playing Cards</div>
            <div class="sort-subtitle">Choose your sorting order, then view cards</div>
            <div class="sort-buttons">
                <button class="sort-button random active" onclick="selectSort('random')">üé≤ Random Order</button>
                <button class="sort-button" onclick="selectSort('rating')">‚≠ê BGG Average</button>
                <button class="sort-button" onclick="selectSort('rank')">üèÜ BGG Rank</button>
                <button class="sort-button" onclick="selectSort('year')">üìÖ Year Published</button>
                <button class="sort-button" onclick="selectSort('alpha')">üî§ Alphabetical</button>
            </div>
            <div style="margin-top: 30px;">
                <button class="sort-button" onclick="loadAndViewCards()" style="background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%); font-size: 1.4em; padding: 25px;">
                    üöÄ Load & View Cards
                </button>
            </div>
        </div>

        <!-- Loading Screen -->
        <div id="loadingDiv" class="loading" style="display:none;">
            <div>üéØ Loading your owned games...</div>
            <div style="font-size: 0.8em; color: #888;">This may take a moment</div>
        </div>
        
        <!-- Error Screen -->
        <div id="errorDiv" class="error" style="display:none;"></div>
        
        <!-- Card Viewer Screen -->
        <div id="cardViewer" class="card-viewer">
            <button class="back-to-sort" onclick="backToSort()">‚Üê</button>
            <button class="info-button" onclick="showGameInfo()">i</button>
            <div class="cards-stack" id="cardsStack">
                <!-- Cards will be dynamically inserted here -->
            </div>
            <div class="progress-indicator" id="progressIndicator">
                1 / 0
            </div>
        </div>
        
        <!-- Game Info Modal -->
        <div id="gameInfoModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 class="modal-title" id="modalGameTitle">Game Information</h2>
                    <span class="close" onclick="closeGameInfo()">&times;</span>
                </div>
                <div id="modalGameContent">
                    <!-- Content will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <script>
        let allGames = [];
        let currentCardIndex = 0;
        let selectedSortOrder = 'random';
        let isCardViewActive = false;
        let isDataLoaded = false;
        let totalGamesToLoad = 0;
        let gamesLoadedSoFar = 0;

        // Select sorting order (doesn't load data yet)
        function selectSort(sortOrder) {
            selectedSortOrder = sortOrder;
            
            // Update active button
            document.querySelectorAll('.sort-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            console.log(`Selected sort order: ${sortOrder}`);
        }

        // Load data and start card view
        async function loadAndViewCards() {
            if (!isDataLoaded) {
                // Reset allGames array for fresh load
                allGames = [];
                await loadUserCollection();
            } else {
                // Data already loaded, just start card view
                startCardView();
            }
        }

        // Load user collection (owned games only)
        async function loadUserCollection() {
            const username = 'sportomax';
            try {
                document.getElementById('sortSelection').style.display = 'none';
                document.getElementById('loadingDiv').style.display = 'flex';
                
                const response = await fetch(`https://boardgamegeek.com/xmlapi2/collection?username=${username}&stats=1&own=1`);
                const text = await response.text();
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, 'text/xml');
                
                const items = xml.querySelectorAll('item');
                
                // Initialize progress tracking
                totalGamesToLoad = items.length;
                gamesLoadedSoFar = 0;
                
                // Collect all game IDs first
                const gameIds = Array.from(items).map(item => item.getAttribute('objectid'));
                
                // Process games in batches of 20 for Thing API calls
                const batchSize = 20;
                const batchDelay = 3000; // 3 seconds between batches
                let isFirstBatch = true;
                
                // Start loading batches asynchronously
                loadBatchesAsync(items, gameIds, batchSize, batchDelay, isFirstBatch);
                
            } catch (error) {
                console.error('Error loading collection:', error);
                document.getElementById('loadingDiv').style.display = 'none';
                document.getElementById('errorDiv').style.display = 'flex';
                document.getElementById('errorDiv').textContent = 'Error loading your collection. Please try again later.';
            }
        }

        // Load batches asynchronously - start card view after first batch
        async function loadBatchesAsync(items, gameIds, batchSize, batchDelay, isFirstBatch) {
            try {
                for (let i = 0; i < items.length; i += batchSize) {
                    const batch = Array.from(items).slice(i, i + batchSize);
                    const batchIds = gameIds.slice(i, i + batchSize);
                    
                    // Update loading message with progress (only if still loading)
                    if (document.getElementById('loadingDiv').style.display !== 'none') {
                        const loadingDiv = document.getElementById('loadingDiv');
                        const progress = Math.round(((i + batch.length) / items.length) * 100);
                        loadingDiv.innerHTML = `
                            <div>üéØ Loading your owned games...</div>
                            <div style="font-size: 0.8em; color: #888;">Processing batch ${Math.floor(i/batchSize) + 1} of ${Math.ceil(items.length/batchSize)} (${progress}%)</div>
                            <div style="font-size: 0.7em; color: #666;">Fetching ${batch.length} games in this batch...</div>
                        `;
                    }
                    
                    // Get detailed info for entire batch in one API call
                    const batchDetails = await fetchGameDetailsBatch(batchIds);
                    
                    // Process current batch with the fetched details
                    const batchGames = [];
                    for (let j = 0; j < batch.length; j++) {
                        const item = batch[j];
                        const objectid = item.getAttribute('objectid');
                        const name = item.querySelector('name')?.textContent;
                        const thumbnail = item.querySelector('thumbnail')?.textContent;
                        const yearpublished = item.querySelector('yearpublished')?.textContent;
                        
                        const stats = item.querySelector('stats');
                        const rating = stats?.querySelector('rating')?.getAttribute('value');
                        const usersrated = stats?.querySelector('usersrated')?.getAttribute('value');
                        const rank = stats?.querySelector('ranks rank[name="boardgame"]')?.getAttribute('value');
                        
                        // Additional collection data
                        const myrating = item.querySelector('rating')?.getAttribute('value');
                        const numplays = parseInt(item.querySelector('numplays')?.textContent || '0');
                        
                        // Get player count and additional details from batch details
                        const gameDetails = batchDetails[objectid] || { 
                            minplayers: 0, 
                            maxplayers: 0,
                            minage: 0,
                            playingtime: 0,
                            minplaytime: 0,
                            maxplaytime: 0,
                            averageweight: 0,
                            average: 0,
                            numweights: 0,
                            playerRecommendations: {},
                            designer: '',
                            publisher: '',
                            category: '',
                            mechanic: '',
                            owned: 0,
                            wanting: 0,
                            wishing: 0,
                            trading: 0
                        };
                        
                        batchGames.push({
                            id: objectid,
                            name: name,
                            thumbnail: thumbnail,
                            year: yearpublished,
                            rating: parseFloat(rating) || 0,
                            usersrated: parseInt(usersrated) || 0,
                            rank: rank === 'Not Ranked' ? 999999 : parseInt(rank) || 999999,
                            minplayers: gameDetails.minplayers,
                            maxplayers: gameDetails.maxplayers,
                            myrating: parseFloat(myrating) || 0,
                            numplays: numplays,
                            minage: gameDetails.minage,
                            playingtime: gameDetails.playingtime,
                            minplaytime: gameDetails.minplaytime,
                            maxplaytime: gameDetails.maxplaytime,
                            averageweight: gameDetails.averageweight,
                            average: gameDetails.average,
                            numweights: gameDetails.numweights,
                            playerRecommendations: gameDetails.playerRecommendations,
                            designer: gameDetails.designer,
                            publisher: gameDetails.publisher,
                            category: gameDetails.category,
                            mechanic: gameDetails.mechanic,
                            allDesigners: gameDetails.allDesigners,
                            allPublishers: gameDetails.allPublishers,
                            allCategories: gameDetails.allCategories,
                            allMechanics: gameDetails.allMechanics,
                            owned: gameDetails.owned,
                            wanting: gameDetails.wanting,
                            wishing: gameDetails.wishing,
                            trading: gameDetails.trading
                        });
                    }
                    
                    // Add batch games to main array
                    allGames.push(...batchGames.filter(game => game.name));
                    
                    // Update progress counter
                    gamesLoadedSoFar = Math.min(i + batchSize, items.length);
                    
                    // After first batch, start showing cards!
                    if (isFirstBatch && allGames.length > 0) {
                        isFirstBatch = false;
                        isDataLoaded = true;
                        
                        console.log(`First batch loaded with ${allGames.length} games - starting card view!`);
                        
                        // Hide loading and start card view
                        document.getElementById('loadingDiv').style.display = 'none';
                        startCardView();
                        
                        // Continue loading remaining batches in background
                        if (i + batchSize < items.length) {
                            console.log('Continuing to load remaining batches in background...');
                            // Show subtle indicator that more games are loading
                            showBackgroundLoadingIndicator();
                        }
                    }
                    
                    // If not first batch, re-sort games with new additions
                    if (!isFirstBatch && allGames.length > 0) {
                        // Re-sort with new games added
                        sortGames();
                        // Update total count in progress indicator
                        updateProgressIndicator();
                        // Update loading progress
                        updateLoadingProgress();
                    }
                    
                    // Delay between batches (except for the last batch)
                    if (i + batchSize < items.length) {
                        await new Promise(resolve => setTimeout(resolve, batchDelay));
                    } else {
                        // All batches complete
                        hideBackgroundLoadingIndicator();
                        console.log(`All batches complete! Total games loaded: ${allGames.length}`);
                    }
                }
                
            } catch (error) {
                console.error('Error in batch loading:', error);
                if (allGames.length === 0) {
                    document.getElementById('loadingDiv').style.display = 'none';
                    document.getElementById('errorDiv').style.display = 'flex';
                    document.getElementById('errorDiv').textContent = 'Error loading your collection. Please try again later.';
                }
            }
        }

        // Show subtle indicator that background loading is happening
        function showBackgroundLoadingIndicator() {
            // Use the progress indicator to show loading info
            updateLoadingProgress();
        }

        // Update loading progress indicator
        function updateLoadingProgress() {
            const progressIndicator = document.getElementById('progressIndicator');
            if (totalGamesToLoad > 0 && gamesLoadedSoFar < totalGamesToLoad) {
                const percentage = Math.round((gamesLoadedSoFar / totalGamesToLoad) * 100);
                const cardInfo = allGames.length > 0 ? `${currentCardIndex + 1} / ${allGames.length} ‚Ä¢ ` : '';
                progressIndicator.innerHTML = `${cardInfo}Loading ${percentage}% (${gamesLoadedSoFar}/${totalGamesToLoad})`;
            } else if (allGames.length > 0) {
                // Show normal progress when not loading
                updateProgressIndicator();
            }
        }

        // Hide background loading indicator
        function hideBackgroundLoadingIndicator() {
            // Just update to show normal progress
            updateProgressIndicator();
        }

        // Fetch detailed game info for multiple games in one API call
        async function fetchGameDetailsBatch(gameIds, maxRetries = 3) {
            const idsString = gameIds.join(',');
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    console.log(`Fetching batch of ${gameIds.length} games: ${idsString.substring(0, 50)}...`);
                    const response = await fetch(`https://boardgamegeek.com/xmlapi2/thing?id=${idsString}&stats=1`);
                    
                    if (response.status === 429) {
                        // Rate limited - wait longer before retry
                        const waitTime = attempt * 2000; // 2s, 4s, 6s
                        console.log(`Rate limited for batch, waiting ${waitTime}ms before retry ${attempt}/${maxRetries}`);
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                        continue;
                    }
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const text = await response.text();
                    const parser = new DOMParser();
                    const xml = parser.parseFromString(text, 'text/xml');
                    
                    const items = xml.querySelectorAll('item');
                    const results = {};
                    
                    items.forEach(item => {
                        const id = item.getAttribute('id');
                        const minplayers = parseInt(item.querySelector('minplayers')?.getAttribute('value')) || 0;
                        const maxplayers = parseInt(item.querySelector('maxplayers')?.getAttribute('value')) || 0;
                        const minage = parseInt(item.querySelector('minage')?.getAttribute('value')) || 0;
                        const playingtime = parseInt(item.querySelector('playingtime')?.getAttribute('value')) || 0;
                        const minplaytime = parseInt(item.querySelector('minplaytime')?.getAttribute('value')) || 0;
                        const maxplaytime = parseInt(item.querySelector('maxplaytime')?.getAttribute('value')) || 0;
                        
                        // Parse player count recommendations
                        const playerPoll = item.querySelector('poll[name="suggested_numplayers"]');
                        const playerRecommendations = {};
                        if (playerPoll) {
                            const results = playerPoll.querySelectorAll('results');
                            results.forEach(result => {
                                const numplayers = result.getAttribute('numplayers');
                                const best = parseInt(result.querySelector('result[value="Best"]')?.getAttribute('numvotes')) || 0;
                                const recommended = parseInt(result.querySelector('result[value="Recommended"]')?.getAttribute('numvotes')) || 0;
                                const notRecommended = parseInt(result.querySelector('result[value="Not Recommended"]')?.getAttribute('numvotes')) || 0;
                                
                                // Determine recommendation level based on votes
                                let recommendation = 'none';
                                if (best > recommended && best > notRecommended) {
                                    recommendation = 'best';
                                } else if (recommended > notRecommended && (best + recommended) > notRecommended) {
                                    recommendation = 'recommended';
                                }
                                
                                playerRecommendations[numplayers] = recommendation;
                            });
                        }
                        
                        // Parse designer, publisher, category, and mechanic
                        const designer = item.querySelector('link[type="boardgamedesigner"]')?.getAttribute('value') || '';
                        const publisher = item.querySelector('link[type="boardgamepublisher"]')?.getAttribute('value') || '';
                        const category = item.querySelector('link[type="boardgamecategory"]')?.getAttribute('value') || '';
                        const mechanic = item.querySelector('link[type="boardgamemechanic"]')?.getAttribute('value') || '';
                        
                        // Collect ALL designers, publishers, categories, and mechanics
                        const allDesigners = Array.from(item.querySelectorAll('link[type="boardgamedesigner"]')).map(link => link.getAttribute('value')).filter(v => v);
                        const allPublishers = Array.from(item.querySelectorAll('link[type="boardgamepublisher"]')).map(link => link.getAttribute('value')).filter(v => v);
                        const allCategories = Array.from(item.querySelectorAll('link[type="boardgamecategory"]')).map(link => link.getAttribute('value')).filter(v => v);
                        const allMechanics = Array.from(item.querySelectorAll('link[type="boardgamemechanic"]')).map(link => link.getAttribute('value')).filter(v => v);
                        
                        const statistics = item.querySelector('statistics');
                        const ratings = statistics?.querySelector('ratings');
                        const averageweight = parseFloat(ratings?.querySelector('averageweight')?.getAttribute('value')) || 0;
                        const average = parseFloat(ratings?.querySelector('average')?.getAttribute('value')) || 0;
                        const numweights = parseInt(ratings?.querySelector('numweights')?.getAttribute('value')) || 0;
                        
                        // Parse community engagement stats
                        const owned = parseInt(ratings?.querySelector('owned')?.getAttribute('value')) || 0;
                        const wanting = parseInt(ratings?.querySelector('wanting')?.getAttribute('value')) || 0;
                        const wishing = parseInt(ratings?.querySelector('wishing')?.getAttribute('value')) || 0;
                        const trading = parseInt(ratings?.querySelector('trading')?.getAttribute('value')) || 0;
                        
                        results[id] = { 
                            minplayers, 
                            maxplayers,
                            minage,
                            playingtime,
                            minplaytime,
                            maxplaytime,
                            averageweight,
                            average,
                            numweights,
                            playerRecommendations,
                            designer,
                            publisher,
                            category,
                            mechanic,
                            allDesigners,
                            allPublishers,
                            allCategories,
                            allMechanics,
                            owned,
                            wanting,
                            wishing,
                            trading
                        };
                    });
                    
                    // Fill in missing games with defaults
                    gameIds.forEach(id => {
                        if (!results[id]) {
                            results[id] = { 
                                minplayers: 0, 
                                maxplayers: 0,
                                minage: 0,
                                playingtime: 0,
                                minplaytime: 0,
                                maxplaytime: 0,
                                averageweight: 0,
                                average: 0,
                                numweights: 0,
                                playerRecommendations: {},
                                designer: '',
                                publisher: '',
                                category: '',
                                mechanic: '',
                                allDesigners: [],
                                allPublishers: [],
                                allCategories: [],
                                allMechanics: [],
                                owned: 0,
                                wanting: 0,
                                wishing: 0,
                                trading: 0
                            };
                        }
                    });
                    
                    console.log(`Successfully fetched ${Object.keys(results).length} games in batch`);
                    return results;
                    
                } catch (error) {
                    console.error(`Attempt ${attempt} failed for batch:`, error);
                    
                    if (attempt === maxRetries) {
                        console.error(`All ${maxRetries} attempts failed for batch, using defaults`);
                        const results = {};
                        gameIds.forEach(id => {
                            results[id] = { 
                                minplayers: 0, 
                                maxplayers: 0,
                                minage: 0,
                                playingtime: 0,
                                minplaytime: 0,
                                maxplaytime: 0,
                                averageweight: 0,
                                average: 0,
                                numweights: 0,
                                playerRecommendations: {},
                                designer: '',
                                publisher: '',
                                category: '',
                                mechanic: '',
                                allDesigners: [],
                                allPublishers: [],
                                allCategories: [],
                                allMechanics: [],
                                owned: 0,
                                wanting: 0,
                                wishing: 0,
                                trading: 0
                            };
                        });
                        return results;
                    }
                    
                    // Wait before retry
                    await new Promise(resolve => setTimeout(resolve, attempt * 1000));
                }
            }
        }

        // Fetch detailed game info for player count with retry logic (legacy - for single games)
        async function fetchGameDetailsWithRetry(gameId, maxRetries = 3) {
            const batchResult = await fetchGameDetailsBatch([gameId], maxRetries);
            return batchResult[gameId] || { 
                minplayers: 0, 
                maxplayers: 0,
                minage: 0,
                playingtime: 0,
                minplaytime: 0,
                maxplaytime: 0,
                averageweight: 0,
                average: 0,
                numweights: 0,
                playerRecommendations: {},
                designer: '',
                publisher: '',
                category: '',
                mechanic: '',
                allDesigners: [],
                allPublishers: [],
                allCategories: [],
                allMechanics: [],
                owned: 0,
                wanting: 0,
                wishing: 0,
                trading: 0
            };
        }

        // Fetch detailed game info for player count (legacy function for compatibility)
        async function fetchGameDetails(gameId) {
            return await fetchGameDetailsWithRetry(gameId);
        }

        // Start card view with pre-selected sort order
        function startCardView() {
            sortGames();
            currentCardIndex = 0;
            isCardViewActive = true;
            
            document.getElementById('sortSelection').style.display = 'none';
            document.getElementById('errorDiv').style.display = 'none';
            document.getElementById('cardViewer').style.display = 'block';
            
            createCardStack();
            updateProgressIndicator();
        }

        // Go back to sort selection
        function backToSort() {
            isCardViewActive = false;
            document.getElementById('cardViewer').style.display = 'none';
            document.getElementById('sortSelection').style.display = 'flex';
            clearCardStack();
        }

        // Sort games based on selected sort order
        function sortGames() {
            console.log(`Sorting games by: ${selectedSortOrder}`);
            switch(selectedSortOrder) {
                case 'random':
                    shuffleArray(allGames);
                    break;
                case 'rating':
                    allGames.sort((a, b) => b.rating - a.rating);
                    break;
                case 'rank':
                    allGames.sort((a, b) => a.rank - b.rank);
                    break;
                case 'year':
                    allGames.sort((a, b) => b.year - a.year);
                    break;
                case 'alpha':
                    allGames.sort((a, b) => a.name.localeCompare(b.name));
                    break;
            }
        }

        // Shuffle array for random order
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // Create card stack (show current and next card)
        function createCardStack() {
            const cardsStack = document.getElementById('cardsStack');
            clearCardStack();
            
            // Create current card
            if (currentCardIndex < allGames.length) {
                const currentCard = createGameCard(allGames[currentCardIndex], 0);
                cardsStack.appendChild(currentCard);
                
                // Create next card (if exists) behind current card
                if (currentCardIndex + 1 < allGames.length) {
                    const nextCard = createGameCard(allGames[currentCardIndex + 1], 1);
                    nextCard.style.transform = 'scale(0.95) translateY(10px)';
                    nextCard.style.zIndex = -1;
                    cardsStack.appendChild(nextCard);
                }
            }
        }

        // Create individual game card element
        function createGameCard(game, index) {
            const card = document.createElement('div');
            card.className = 'game-card';
            card.dataset.gameIndex = currentCardIndex + index;
            
            // Get rating color (matches VFM getBayesGradientColor)
            function getRatingColor(rating) {
                if (rating <= 0) return 'linear-gradient(135deg, rgba(128,128,128,0.9) 0%, rgba(100,100,100,0.9) 100%)'; // Gray for no rating
                
                const ratingNum = parseFloat(rating);
                if (ratingNum >= 8.0) return 'linear-gradient(135deg, rgba(76,175,80,0.9) 0%, rgba(56,142,60,0.9) 100%)'; // Green for excellent (8.0+)
                if (ratingNum >= 7.5) return 'linear-gradient(135deg, rgba(139,195,74,0.9) 0%, rgba(104,159,56,0.9) 100%)'; // Light green for very good (7.5+)
                if (ratingNum >= 7.0) return 'linear-gradient(135deg, rgba(255,235,59,0.9) 0%, rgba(251,192,45,0.9) 100%)'; // Yellow for good (7.0+)
                if (ratingNum >= 6.0) return 'linear-gradient(135deg, rgba(255,152,0,0.9) 0%, rgba(230,81,0,0.9) 100%)'; // Orange for average (6.0+)
                return 'linear-gradient(135deg, rgba(244,67,54,0.9) 0%, rgba(198,40,40,0.9) 100%)'; // Red for below average
            }
            
            // Get rank color (matches VFM getRankGradientColor)
            function getRankColor(rank) {
                if (!rank || rank >= 999999) return 'linear-gradient(135deg, rgba(128,128,128,0.9) 0%, rgba(100,100,100,0.9) 100%)'; // Gray for unranked
                
                const rankNum = parseInt(rank);
                if (rankNum <= 100) return 'linear-gradient(135deg, rgba(76,175,80,0.9) 0%, rgba(56,142,60,0.9) 100%)'; // Green for top 100
                if (rankNum <= 500) return 'linear-gradient(135deg, rgba(139,195,74,0.9) 0%, rgba(104,159,56,0.9) 100%)'; // Light green for top 500
                if (rankNum <= 1000) return 'linear-gradient(135deg, rgba(255,235,59,0.9) 0%, rgba(251,192,45,0.9) 100%)'; // Yellow for top 1000
                if (rankNum <= 5000) return 'linear-gradient(135deg, rgba(255,152,0,0.9) 0%, rgba(230,81,0,0.9) 100%)'; // Orange for top 5000
                return 'linear-gradient(135deg, rgba(244,67,54,0.9) 0%, rgba(198,40,40,0.9) 100%)'; // Red for below 5000
            }
            
            // Format rank for display
            function formatRank(rank) {
                if (rank >= 999999) return 'NR';
                if (rank >= 1000) return `${Math.round(rank/1000)}k`;
                return rank.toString();
            }
            
            // Create player count display with individual numbered circles
            let playerCountHtml = '';
            if (game.minplayers > 0 && game.maxplayers > 0) {
                playerCountHtml = '<div class="player-numbers">';
                // Create circles for players 1-8 (reserved positions)
                for (let i = 1; i <= 8; i++) {
                    const isActive = i >= game.minplayers && i <= game.maxplayers;
                    
                    if (!isActive) {
                        // Hide unsupported player counts
                        playerCountHtml += `<div class="player-number hidden">${i}</div>`;
                        continue;
                    }
                    
                    // Determine recommendation class for supported player counts
                    let recommendationClass = ' active'; // Default: clear/transparent
                    if (game.playerRecommendations) {
                        const recommendation = game.playerRecommendations[i.toString()];
                        if (recommendation === 'best') {
                            recommendationClass = ' best';
                        } else if (recommendation === 'recommended') {
                            recommendationClass = ' recommended';
                        }
                    }
                    
                    playerCountHtml += `<div class="player-number${recommendationClass}">${i}</div>`;
                }
                // Handle 8+ display
                if (game.maxplayers > 8) {
                    // Check if 8+ has a recommendation
                    let recommendation8Plus = ' active'; // Default: clear/transparent
                    if (game.playerRecommendations && game.playerRecommendations['8+']) {
                        const rec = game.playerRecommendations['8+'];
                        if (rec === 'best') {
                            recommendation8Plus = ' best';
                        } else if (rec === 'recommended') {
                            recommendation8Plus = ' recommended';
                        }
                    }
                    
                    // Replace the last active 8 with 8+
                    const lastActiveIndex = playerCountHtml.lastIndexOf('<div class="player-number active">8</div>');
                    if (lastActiveIndex !== -1) {
                        playerCountHtml = playerCountHtml.substring(0, lastActiveIndex) + 
                                        `<div class="player-number${recommendation8Plus}">8+</div>` +
                                        playerCountHtml.substring(lastActiveIndex + '<div class="player-number active">8</div>'.length);
                    }
                }
                playerCountHtml += '</div>';
            }
            
            const thumbnailDisplay = game.thumbnail ? 
                `<img src="${game.thumbnail}" class="game-thumbnail" alt="${game.name}">` :
                `<div class="game-thumbnail" style="background: #333; display: flex; align-items: center; justify-content: center; color: #666;">No Image</div>`;
            
            // Create rating and rank circles
            const ratingValue = game.average || game.rating || 0;
            const ratingDisplay = ratingValue > 0 ? ratingValue.toFixed(1) : 'NR';
            const ratingColor = getRatingColor(ratingValue);
            
            const rankValue = game.rank < 999999 ? game.rank : 999999;
            const rankDisplay = formatRank(rankValue);
            const rankColor = getRankColor(rankValue);
            
            const thumbnailWithCircles = `
                <div class="thumbnail-container">
                    ${thumbnailDisplay}
                </div>
                <div class="rating-circle" style="background: ${ratingColor}">
                    ${ratingDisplay}
                </div>
                <div class="rank-circle" style="background: ${rankColor}">
                    ${rankDisplay}
                </div>
            `;
            
            // Format play time display
            let playTimeText = '';
            if (game.minplaytime > 0 && game.maxplaytime > 0) {
                if (game.minplaytime === game.maxplaytime) {
                    playTimeText = `${game.minplaytime} min`;
                } else {
                    playTimeText = `${game.minplaytime}-${game.maxplaytime} min`;
                }
            } else if (game.playingtime > 0) {
                playTimeText = `${game.playingtime} min`;
            }
            
            // Format weight display (complexity)
            const weightText = game.averageweight > 0 ? 
                `${game.averageweight.toFixed(2)}/5` : '';
            
            // Format weight vote count
            const weightVotesText = game.numweights > 0 ? 
                `${game.numweights.toLocaleString()} votes` : '';
            
            // Format BGG average rating
            const bggRatingText = game.average > 0 ? 
                `BGG Avg: ${game.average.toFixed(2)}` : '';
            
            // Format my rating
            const myRatingText = game.myrating > 0 ? 
                `My Rating: ${game.myrating}/10` : '';
            
            // Format play count
            const playCountText = game.numplays > 0 ? 
                `Plays: ${game.numplays}` : 'Never played';
            
            // Format rank
            const rankText = game.rank < 999999 ? `Rank: ${game.rank.toLocaleString()}` : 'Unranked';
            
            // Format age recommendation
            const ageText = game.minage > 0 ? `Age: ${game.minage}+` : '';
            
            card.innerHTML = `
                ${playerCountHtml}
                <div class="game-title">${game.name}</div>
                ${thumbnailWithCircles}
                <div class="game-info">
                    <div class="info-row">
                        <span class="info-label">Published:</span>
                        <span class="info-value">${game.year || 'Unknown'}</span>
                    </div>
                    ${myRatingText ? `
                    <div class="info-row">
                        <span class="info-label">My Rating:</span>
                        <span class="info-value">${game.myrating}/10</span>
                    </div>` : ''}
                    <div class="info-row">
                        <span class="info-label">Plays:</span>
                        <span class="info-value">${game.numplays || 0}</span>
                    </div>
                    ${bggRatingText ? `
                    <div class="info-row">
                        <span class="info-label">BGG Rating:</span>
                        <span class="info-value">${game.average.toFixed(2)}</span>
                    </div>` : ''}
                    <div class="info-row">
                        <span class="info-label">Users Rated:</span>
                        <span class="info-value">${game.usersrated.toLocaleString()}</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Rank:</span>
                        <span class="info-value">${game.rank < 999999 ? game.rank.toLocaleString() : 'Unranked'}</span>
                    </div>
                    ${ageText ? `
                    <div class="info-row">
                        <span class="info-label">Age:</span>
                        <span class="info-value">${game.minage}+</span>
                    </div>` : ''}
                    ${playTimeText ? `
                    <div class="info-row">
                        <span class="info-label">Play Time:</span>
                        <span class="info-value">${playTimeText}</span>
                    </div>` : ''}
                    ${weightText ? `
                    <div class="info-row">
                        <span class="info-label">Complexity:</span>
                        <span class="info-value">${weightText}</span>
                    </div>` : ''}
                    ${weightVotesText ? `
                    <div class="info-row">
                        <span class="info-label">Weight Votes:</span>
                        <span class="info-value">${weightVotesText}</span>
                    </div>` : ''}
                    ${game.designer ? `
                    <div class="info-row">
                        <span class="info-label">Designer:</span>
                        <span class="info-value">${game.designer}</span>
                    </div>` : ''}
                    ${game.publisher ? `
                    <div class="info-row">
                        <span class="info-label">Publisher:</span>
                        <span class="info-value">${game.publisher}</span>
                    </div>` : ''}
                    ${game.category ? `
                    <div class="info-row">
                        <span class="info-label">Category:</span>
                        <span class="info-value">${game.category}</span>
                    </div>` : ''}
                    ${game.mechanic ? `
                    <div class="info-row">
                        <span class="info-label">Mechanic:</span>
                        <span class="info-value">${game.mechanic}</span>
                    </div>` : ''}
                    ${game.owned > 0 ? `
                    <div class="info-row">
                        <span class="info-label">Owned:</span>
                        <span class="info-value">${game.owned.toLocaleString()}</span>
                    </div>` : ''}
                    ${game.wanting > 0 ? `
                    <div class="info-row">
                        <span class="info-label">Wanting:</span>
                        <span class="info-value">${game.wanting.toLocaleString()}</span>
                    </div>` : ''}
                    ${game.wishing > 0 ? `
                    <div class="info-row">
                        <span class="info-label">Wishing:</span>
                        <span class="info-value">${game.wishing.toLocaleString()}</span>
                    </div>` : ''}
                    ${game.trading > 0 ? `
                    <div class="info-row">
                        <span class="info-label">Trading:</span>
                        <span class="info-value">${game.trading.toLocaleString()}</span>
                    </div>` : ''}
                </div>
            `;
            
            // Add swipe functionality to current card only
            if (index === 0) {
                addSwipeListeners(card);
            }
            
            return card;
        }

        // Clear card stack
        function clearCardStack() {
            document.getElementById('cardsStack').innerHTML = '';
        }

        // Add swipe/drag listeners to a card
        function addSwipeListeners(card) {
            let startX = 0;
            let startY = 0;
            let currentX = 0;
            let currentY = 0;
            let isDragging = false;

            // Mouse events
            card.addEventListener('mousedown', handleStart);
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('mouseup', handleEnd);

            // Touch events
            card.addEventListener('touchstart', handleStart, { passive: false });
            document.addEventListener('touchmove', handleMove, { passive: false });
            document.addEventListener('touchend', handleEnd);

            function handleStart(e) {
                e.preventDefault();
                isDragging = true;
                card.classList.add('dragging');
                
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                startX = clientX;
                startY = clientY;
                currentX = clientX;
                currentY = clientY;
            }

            function handleMove(e) {
                if (!isDragging) return;
                e.preventDefault();
                
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                
                currentX = clientX;
                currentY = clientY;
                
                const deltaX = currentX - startX;
                const deltaY = currentY - startY;
                const rotation = deltaX * 0.1;
                
                card.style.transform = `translateX(${deltaX}px) translateY(${deltaY}px) rotate(${rotation}deg)`;
                card.style.opacity = Math.max(0.5, 1 - Math.abs(deltaX) / 300);
            }

            function handleEnd(e) {
                if (!isDragging) return;
                isDragging = false;
                card.classList.remove('dragging');
                
                const deltaX = currentX - startX;
                const threshold = 100;
                
                if (Math.abs(deltaX) > threshold) {
                    // Swipe detected
                    if (deltaX > 0) {
                        // Swipe right - next card
                        card.classList.add('swipe-right');
                    } else {
                        // Swipe left - next card  
                        card.classList.add('swipe-left');
                    }
                    
                    setTimeout(() => {
                        nextCard();
                    }, 300);
                } else {
                    // Snap back to center
                    card.style.transform = '';
                    card.style.opacity = '';
                }
            }
        }

        // Move to next card
        function nextCard() {
            if (currentCardIndex < allGames.length - 1) {
                currentCardIndex++;
                createCardStack();
                updateProgressIndicator();
            } else {
                // End of deck - go back to sort selection
                backToSort();
            }
        }

        // Update progress indicator
        function updateProgressIndicator() {
            const progressIndicator = document.getElementById('progressIndicator');
            if (gamesLoadedSoFar < totalGamesToLoad && totalGamesToLoad > 0) {
                // Still loading - show loading progress
                updateLoadingProgress();
            } else {
                // Show normal card progress
                progressIndicator.innerHTML = `<span id="currentCard">${currentCardIndex + 1}</span> / <span id="totalCards">${allGames.length}</span>`;
            }
        }

        // Keyboard navigation (for testing)
        document.addEventListener('keydown', function(e) {
            if (!isCardViewActive) return;
            
            if (e.key === 'ArrowRight' || e.key === ' ') {
                e.preventDefault();
                nextCard();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                backToSort();
            }
        });

        // Don't auto-load anything on page load
        window.addEventListener('load', function() {
            console.log('Playing Cards app ready - select sort order and click "Load & View Cards"');
        });

        // Show game info modal
        function showGameInfo(gameId = null) {
            let game;
            
            if (gameId) {
                // Find game by ID when called from info button
                game = allGames.find(g => g.id.toString() === gameId.toString());
            } else {
                // Use current card when called from main info button
                if (currentCardIndex < allGames.length) {
                    game = allGames[currentCardIndex];
                }
            }
            
            if (!game) return;
            
            const modal = document.getElementById('gameInfoModal');
            const modalTitle = document.getElementById('modalGameTitle');
            const modalContent = document.getElementById('modalGameContent');
            
            modalTitle.textContent = game.name;
            
            let content = '';
            
            // Designers
            if (game.allDesigners && game.allDesigners.length > 0) {
                content += '<div class="modal-section"><h3>Designers</h3><div class="modal-list">';
                game.allDesigners.forEach(designer => {
                    content += `<div class="modal-list-item">${designer}</div>`;
                });
                content += '</div></div>';
            }
            
            // Publishers
            if (game.allPublishers && game.allPublishers.length > 0) {
                content += '<div class="modal-section"><h3>Publishers</h3><div class="modal-list">';
                game.allPublishers.forEach(publisher => {
                    content += `<div class="modal-list-item">${publisher}</div>`;
                });
                content += '</div></div>';
            
            // Categories
            if (game.allCategories && game.allCategories.length > 0) {
                content += '<div class="modal-section"><h3>Categories</h3><div class="modal-list">';
                game.allCategories.forEach(category => {
                    content += `<div class="modal-list-item">${category}</div>`;
                });
                content += '</div></div>';
            }
            
            // Mechanics
            if (game.allMechanics && game.allMechanics.length > 0) {
                content += '<div class="modal-section"><h3>Mechanics</h3><div class="modal-list">';
                game.allMechanics.forEach(mechanic => {
                    content += `<div class="modal-list-item">${mechanic}</div>`;
                });
                content += '</div></div>';
            }
            
            if (content === '') {
                content = '<div class="modal-section">No additional information available.</div>';
            }
            
            modalContent.innerHTML = content;
            modal.style.display = 'block';
        }
        }

        // Close game info modal
        function closeGameInfo() {
            document.getElementById('gameInfoModal').style.display = 'none';
        }

        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const modal = document.getElementById('gameInfoModal');
            if (event.target == modal) {
                closeGameInfo();
            }
        }
    </script>
</body>
</html>