<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover">
    <title>BGG API Helper</title>
    <style>
        * { box-sizing: border-box; }
        body { 
            margin: 0; 
            padding: 0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif; 
            background: #f7f7fa; 
            color: #222; 
            font-size: 16px;
            line-height: 1.4;
            -webkit-text-size-adjust: 100%; /* Prevent text scaling on iPhone rotation */
            -webkit-font-smoothing: antialiased; /* Better font rendering on iOS */
            overscroll-behavior: none; /* Prevent bounce scrolling on iOS */
        }
        .container { 
            width: 100%;
            max-width: 430px; 
            margin: 0 auto; 
            padding: 0.75em; 
            box-sizing: border-box; 
            min-height: 100vh; 
            padding-bottom: env(safe-area-inset-bottom); 
        }
        
        h1 { font-size: 1.7em; margin-bottom: 0.5em; text-align: center; color: #1976d2; }
        h2 { font-size: 1.3em; margin: 1.5em 0 0.5em 0; color: #1976d2; }
        h3 { font-size: 1em; margin: 0.75em 0 0.4em 0; color: #333; }
        
        .section { 
            background: #fff; 
            border-radius: 8px; 
            box-shadow: 0 1px 8px rgba(0,0,0,0.08); 
            padding: 1em; 
            margin-bottom: 0.75em; 
        }
        
        /* Quick Actions Grid */
        .quick-actions {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.5em;
            margin-top: 0.75em;
        }
        
        /* Buttons */
        .btn { 
            width: 100%; 
            padding: 0.75em; 
            border: none; 
            border-radius: 6px; 
            font-size: 0.9em; 
            font-weight: 600; 
            cursor: pointer; 
            margin: 0.15em 0;
            text-align: center;
            transition: all 0.2s;
            min-height: 44px; /* Apple's minimum touch target size */
            min-width: 44px;
            touch-action: manipulation; /* Prevent double-tap zoom */
        }
        .btn-primary { background: #1976d2; color: white; }
        .btn-secondary { background: #4caf50; color: white; }
        .btn-warning { background: #ff9800; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn:hover { opacity: 0.9; transform: translateY(-1px); }
        .btn:disabled { background: #ccc; cursor: not-allowed; transform: none; }
        
        /* API Display */
        .api-display {
            background: #e3f2fd;
            border: 1px solid #1976d2;
            border-radius: 8px;
            padding: 1em;
            font-family: monospace;
            font-size: 0.85em;
            word-break: break-all;
            margin-bottom: 1em;
        }
        
        .api-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5em;
        }
        .api-actions .btn:last-child {
            grid-column: 1 / -1;
        }
        
        /* Response Display */
        .response-info {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 0.75em;
            margin-bottom: 1em;
            font-size: 0.9em;
        }
        
        .response-content {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1em;
            font-family: monospace;
            font-size: 0.8em;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }
        
        /* Modal Styles - iPhone Optimized */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            backdrop-filter: blur(3px);
        }
        
        .modal-content {
            position: relative;
            width: 100%;
            height: 100%;
            background: white;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .modal-header {
            background: #1976d2;
            color: white;
            padding: 0.75em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: max(0.75em, env(safe-area-inset-top));
        }
        
        .modal-title {
            font-size: 1em;
            font-weight: 600;
            margin: 0;
        }
        
        .modal-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.5em;
            cursor: pointer;
            padding: 0.5em; /* Increased for better touch targets */
            border-radius: 4px;
            width: 2.75em; /* Increased to meet 44px minimum */
            height: 2.75em;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 44px; /* Apple's minimum touch target */
            min-height: 44px;
            touch-action: manipulation;
        }
        
        .modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .modal-body {
            flex: 1;
            padding: 0.75em;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding-bottom: max(0.75em, env(safe-area-inset-bottom));
            overscroll-behavior: contain; /* Prevent background scrolling on iOS */
        }
        
        /* API Builder Modal Styles */
        .endpoint-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.5em;
            margin-bottom: 1em;
        }
        
        .endpoint-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 0.75em;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 44px; /* Ensure minimum touch target */
            touch-action: manipulation;
        }
        
        .endpoint-card:hover {
            border-color: #1976d2;
            transform: translateY(-1px);
        }
        
        .endpoint-card.selected {
            border-color: #1976d2;
            background: #e3f2fd;
        }
        
        .endpoint-name {
            font-weight: 600;
            color: #1976d2;
            margin-bottom: 0.15em;
            font-size: 0.8em;
            line-height: 1.2;
        }
        
        .endpoint-example {
            font-family: monospace;
            font-size: 0.65em;
            background: #e9ecef;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            color: #495057;
        }
        
        /* Form Styles */
        .form-group {
            margin-bottom: 0.4em;
        }
        
        .form-label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.15em;
            color: #333;
            font-size: 0.75em;
            line-height: 1.2;
        }
        
        .form-group.inline {
            display: flex;
            align-items: center;
            gap: 0.5em;
        }
        
        .form-group.inline .form-label {
            margin-bottom: 0;
            white-space: nowrap;
            min-width: fit-content;
        }
        
        .form-group.inline .form-input,
        .form-group.inline .form-select {
            flex: 1;
        }
        
        .form-input, .form-select {
            width: 100%;
            padding: 0.4em;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px; /* Smaller font but still prevents zoom on iOS */
            background: white;
            min-height: 36px; /* Reduced from 44px but still usable */
            touch-action: manipulation;
        }
        
        .form-input:focus, .form-select:focus {
            outline: none;
            border-color: #1976d2;
            box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.2);
        }
        
        .checkbox-group {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.25em;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            padding: 0.25em 0.5em;
            background: #f8f9fa;
            border-radius: 4px;
            min-height: 32px;
        }
        
        .checkbox-item input[type="checkbox"] {
            margin-right: 0.5em;
            transform: scale(1.1);
            min-width: 16px;
            min-height: 16px;
            flex-shrink: 0;
        }
        
        .checkbox-item label {
            font-size: 0.75em;
            cursor: pointer;
            flex: 1;
            line-height: 1.2;
        }
        
        /* API Reference Styles */
        .api-version-tabs {
            display: flex;
            background: #f0f0f0;
            border-radius: 6px;
            padding: 0.15em;
            margin-bottom: 1em;
        }
        
        .api-tab {
            flex: 1;
            padding: 0.5em;
            text-align: center;
            background: transparent;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
            min-height: 36px; /* Reduced from 44px */
            font-size: 14px; /* Smaller font */
            touch-action: manipulation;
        }
        
        .api-tab.active {
            background: white;
            color: #1976d2;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .api-section {
            margin-bottom: 1em;
        }
        
        .api-endpoint {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 0.75em;
            margin-bottom: 0.75em;
        }
        
        .api-endpoint-name {
            font-weight: 600;
            color: #1976d2;
            font-family: monospace;
            margin-bottom: 0.25em;
            font-size: 0.85em;
        }
        
        .api-endpoint-desc {
            color: #666;
            margin-bottom: 0.5em;
            font-size: 0.75em;
        }
        
        .api-filters {
            margin-top: 0.5em;
        }
        
        .filter-tag {
            display: inline-block;
            background: #007bff;
            color: white;
            padding: 0.15em 0.4em;
            border-radius: 2px;
            font-size: 0.65em;
            font-family: monospace;
            margin: 0.05em 0.2em 0.05em 0;
        }
        
        .required-filter {
            background: #dc3545;
        }
        
        .optional-filter {
            background: #28a745;
        }
        
        /* Examples Modal */
        .example-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1em;
        }
        
        .example-card {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 1em;
            min-height: 44px; /* Ensure adequate touch target for any interactive elements */
        }
        
        .example-title {
            font-weight: 600;
            margin-bottom: 0.5em;
            color: #333;
        }
        
        .example-url {
            font-family: monospace;
            background: #e9ecef;
            padding: 0.5em;
            border-radius: 4px;
            font-size: 0.8em;
            word-break: break-all;
            margin-bottom: 0.5em;
        }
        
        .example-desc {
            font-size: 0.85em;
            color: #666;
        }
        
        /* Utility Classes */
        .hidden { display: none !important; }
        .loading { text-align: center; padding: 2em; color: #1976d2; }
        .error { background: #f8d7da; color: #721c24; padding: 1em; border-radius: 6px; }
        .success { background: #d4edda; color: #155724; padding: 1em; border-radius: 6px; }
        
        /* Dynamic Cards Styles */
        .cards-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.75em;
            margin-top: 1em;
        }
        
        .result-card {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 1em;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }
        
        .result-card:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0,0,0,0.15);
        }
        
        .card-header {
            display: flex;
            align-items: flex-start;
            gap: 0.75em;
            margin-bottom: 0.75em;
        }
        
        .card-thumbnail {
            width: 60px;
            height: 60px;
            border-radius: 6px;
            object-fit: cover;
            background: #f0f0f0;
            flex-shrink: 0;
        }
        
        .card-main {
            flex: 1;
            min-width: 0;
        }
        
        .card-title {
            font-weight: 600;
            color: #1976d2;
            margin-bottom: 0.25em;
            font-size: 1em;
            line-height: 1.3;
        }
        
        .card-subtitle {
            color: #666;
            font-size: 0.85em;
            margin-bottom: 0.5em;
        }
        
        .card-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5em;
            margin-bottom: 0.75em;
        }
        
        .stat-item {
            background: #f8f9fa;
            padding: 0.4em 0.6em;
            border-radius: 4px;
            font-size: 0.8em;
            text-align: center;
        }
        
        .stat-label {
            display: block;
            color: #666;
            font-size: 0.75em;
            margin-bottom: 0.1em;
        }
        
        .stat-value {
            font-weight: 600;
            color: #333;
        }
        
        .card-details {
            font-size: 0.85em;
            color: #555;
            line-height: 1.4;
        }
        
        .card-actions {
            display: flex;
            gap: 0.5em;
            margin-top: 0.75em;
            flex-wrap: wrap;
        }
        
        .card-btn {
            background: #1976d2;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.4em 0.8em;
            font-size: 0.8em;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            min-height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
        }
        
        .card-btn:hover {
            background: #1565c0;
        }
        
        .card-btn.secondary {
            background: #4caf50;
        }
        
        .card-btn.secondary:hover {
            background: #43a047;
        }
        
        .cards-info {
            background: #e3f2fd;
            border: 1px solid #1976d2;
            border-radius: 6px;
            padding: 0.75em;
            font-size: 0.9em;
            color: #1976d2;
        }
        
        /* Fullscreen Cards Modal Styles */
        .fullscreen-cards-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1em;
            margin-top: 1em;
        }
        
        .fullscreen-cards-info {
            background: #e3f2fd;
            border: 1px solid #1976d2;
            border-radius: 6px;
            padding: 1em;
            font-size: 1em;
            color: #1976d2;
            text-align: center;
            font-weight: 600;
        }
        
        /* Enhanced card styles for fullscreen */
        .fullscreen-cards-container .result-card {
            min-height: auto;
        }
        
        .fullscreen-cards-container .card-thumbnail {
            width: 80px;
            height: 80px;
        }
        
        .fullscreen-cards-container .card-title {
            font-size: 1.1em;
        }
        
        .fullscreen-cards-container .card-stats {
            grid-template-columns: 1fr 1fr;
            gap: 0.75em;
        }
        
        .fullscreen-cards-container .stat-item {
            padding: 0.6em;
        }
        
        @media (max-width: 768px) {
            .fullscreen-cards-container {
                grid-template-columns: 1fr;
                gap: 0.75em;
            }
        }
        
        /* iPhone-Only Responsive Styles */
        @media (max-width: 430px) {
            .container { 
                padding: 0.5em; 
                padding-left: max(0.5em, env(safe-area-inset-left));
                padding-right: max(0.5em, env(safe-area-inset-right));
            }
            .modal-body { 
                padding: 0.5em; 
                padding-left: max(0.5em, env(safe-area-inset-left));
                padding-right: max(0.5em, env(safe-area-inset-right));
            }
            .api-actions { grid-template-columns: 1fr; }
            .section { padding: 0.75em; }
            h1 { font-size: 1.5em; }
            h2 { font-size: 1.2em; margin: 1em 0 0.5em 0; }
        }
        
        @media (orientation: landscape) and (max-height: 500px) {
            .modal-header { 
                padding: 0.4em 0.75em; 
                padding-top: max(0.4em, env(safe-area-inset-top));
            }
            .modal-body { 
                padding: 0.4em 0.75em; 
                padding-bottom: max(0.4em, env(safe-area-inset-bottom));
            }
            .container { padding: 0.4em; }
        }
        
        /* iPhone Safe Area Support */
        @supports (padding: max(0px)) {
            .container {
                padding-left: max(0.75em, env(safe-area-inset-left));
                padding-right: max(0.75em, env(safe-area-inset-right));
            }
            
            .modal-header {
                padding-left: max(0.75em, env(safe-area-inset-left));
                padding-right: max(0.75em, env(safe-area-inset-right));
            }
            
            .modal-body {
                padding-left: max(0.75em, env(safe-area-inset-left));
                padding-right: max(0.75em, env(safe-area-inset-right));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé≤ BGG API Helper</h1>
        
        <!-- Quick Start Section -->
        <div class="section">
            <h2>üöÄ Quick Start</h2>
            <p>Build and test BoardGameGeek API calls with comprehensive reference and examples.</p>
            
            <div class="quick-actions">
                <button class="btn btn-primary" onclick="openModal('apiBuilder')">
                    üõ†Ô∏è Build API Call
                </button>
                <button class="btn btn-secondary" onclick="openModal('apiReference')">
                    üìö API Reference & Filters
                </button>
                <button class="btn btn-warning" onclick="openModal('examples')">
                    üí° Examples Library
                </button>
            </div>
        </div>

        <!-- Current API Call Section -->
        <div class="section" id="currentApiSection" style="display: none;">
            <h2>üîó Current API Call</h2>
            <div id="currentApiDisplay" class="api-display"></div>
            <div class="api-actions">
                <button class="btn btn-primary" onclick="executeApiCall()" id="executeBtn">
                    üöÄ Execute
                </button>
                <button class="btn btn-secondary" onclick="copyCurrentUrl()">
                    üìã Copy
                </button>
                <button class="btn btn-danger" onclick="clearApiCall()">
                    üóëÔ∏è Clear
                </button>
            </div>
        </div>

        <!-- Response Section -->
        <div class="section" id="responseSection" style="display: none;">
            <h2>üìÑ API Response</h2>
            <div class="response-info" id="responseInfo"></div>
            <div class="response-content" id="responseContent"></div>
            <button class="btn btn-secondary" onclick="openModal('response')" id="viewFullResponseBtn" style="display: none;">
                üîç View Full Response
            </button>
        </div>

        <!-- Dynamic Cards Section -->
        <div class="section" id="cardsSection" style="display: none;">
            <h2>üé¥ Results Cards</h2>
            <div class="cards-info" id="cardsInfo"></div>
            <div class="cards-actions" style="margin-bottom: 1em;">
                <button class="btn btn-primary" onclick="openCardsFullscreen()" id="fullscreenCardsBtn" style="display: none;">
                    üîç View Fullscreen
                </button>
            </div>
            <div class="cards-container" id="cardsContainer"></div>
        </div>

        <!-- Footer Info -->
        <div class="section">
            <h2>‚ÑπÔ∏è About BGG API</h2>
            <p><strong>BGG XML API v2:</strong> Current recommended API with comprehensive game data</p>
            <p><strong>BGG XML API v1:</strong> Legacy API for compatibility and specialized features</p>
            <p><strong>Rate Limits:</strong> Be respectful with API calls. BGG recommends reasonable usage.</p>
            <p><strong>Documentation:</strong></p>
            <ul style="margin: 0.5em 0; padding-left: 1.5em; font-size: 0.9em;">
                <li><a href="https://boardgamegeek.com/wiki/page/BGG_XML_API2" target="_blank">BGG XML API v2 (Current)</a></li>
                <li><a href="https://boardgamegeek.com/wiki/page/BGG_XML_API" target="_blank">BGG XML API v1 (Legacy)</a></li>
            </ul>
        </div>
    </div>

    <!-- API Builder Modal -->
    <div id="apiBuilderModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">üõ†Ô∏è API Call Builder</h2>
                <button class="modal-close" onclick="closeModal('apiBuilder')">&times;</button>
            </div>
            <div class="modal-body">
                <h3>Select API Endpoint</h3>
                <div class="endpoint-grid" id="endpointGrid">
                    <!-- Endpoints will be populated by JavaScript -->
                </div>
                
                <div id="parameterForm" class="hidden">
                    <h3>Configure Parameters</h3>
                    <div id="formFields"></div>
                    <button class="btn btn-primary" onclick="buildApiCall()">
                        üîó Build API Call
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- API Reference Modal -->
    <div id="apiReferenceModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">üìö API Reference & Filters</h2>
                <button class="modal-close" onclick="closeModal('apiReference')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="api-version-tabs">
                    <button class="api-tab active" onclick="switchApiTab('v2')">API v2 (Current)</button>
                    <button class="api-tab" onclick="switchApiTab('v1')">API v1 (Legacy)</button>
                </div>
                
                <div id="apiReferenceContent">
                    <!-- API reference content will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <!-- Examples Modal -->
    <div id="examplesModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">üí° Examples Library</h2>
                <button class="modal-close" onclick="closeModal('examples')">&times;</button>
            </div>
            <div class="modal-body">
                <div id="examplesContent">
                    <!-- Examples will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <!-- Response Modal -->
    <div id="responseModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">üìÑ Full API Response</h2>
                <button class="modal-close" onclick="closeModal('response')">&times;</button>
            </div>
            <div class="modal-body">
                <div id="fullResponseContent" style="font-family: monospace; font-size: 0.8em; white-space: pre-wrap; word-break: break-all;"></div>
            </div>
        </div>
    </div>

    <!-- Fullscreen Cards Modal -->
    <div id="cardsFullscreenModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">üé¥ Results Cards - Fullscreen</h2>
                <button class="modal-close" onclick="closeModal('cardsFullscreen')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="fullscreen-cards-info" id="fullscreenCardsInfo"></div>
                <div class="fullscreen-cards-container" id="fullscreenCardsContainer"></div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentApiCall = null;
        let currentResponse = null;
        let selectedEndpoint = null;

        // API Endpoint Definitions
        const apiEndpoints = {
            v2: {
                thing: {
                    name: "üéØ Thing (Game Details)",
                    desc: "Get detailed information about games, expansions, accessories",
                    url: "https://boardgamegeek.com/xmlapi2/thing",
                    required: ["id"],
                    optional: ["type", "stats", "versions", "videos", "comments", "ratingcomments", "page", "pagesize"],
                    filters: {
                        "id": { type: "text", desc: "Game IDs (comma separated)", example: "174430,167791" },
                        "type": { type: "select", desc: "Item type", options: ["boardgame", "boardgameexpansion", "boardgameaccessory"], default: "boardgame" },
                        "stats": { type: "checkbox", desc: "Include statistics (ratings, ranks, etc.)" },
                        "versions": { type: "checkbox", desc: "Include version information" },
                        "videos": { type: "checkbox", desc: "Include video information" },
                        "comments": { type: "checkbox", desc: "Include user comments" },
                        "ratingcomments": { type: "checkbox", desc: "Include rating comments" },
                        "page": { type: "number", desc: "Page number for comments" },
                        "pagesize": { type: "number", desc: "Comments per page (max 100)", max: 100 }
                    }
                },
                collection: {
                    name: "üì¶ Collection",
                    desc: "Get a user's game collection with filtering options",
                    url: "https://boardgamegeek.com/xmlapi2/collection",
                    required: ["username"],
                    optional: ["version", "subtype", "excludesubtype", "id", "brief", "stats", "own", "rated", "played", "comment", "trade", "want", "wishlist", "wishlistpriority", "preordered", "wanttoplay", "wanttobuy", "prevowned", "hasparts", "wantparts", "minrating", "rating", "minbggrating", "bggrating", "minplays", "maxplays", "showprivate", "collid", "modifiedsince"],
                    filters: {
                        "username": { type: "text", desc: "BGG username", example: "sportomax" },
                        "version": { type: "checkbox", desc: "Return version info" },
                        "subtype": { type: "select", desc: "Subtype filter", options: ["boardgame", "boardgameexpansion"] },
                        "excludesubtype": { type: "select", desc: "Exclude subtype", options: ["boardgame", "boardgameexpansion"] },
                        "id": { type: "text", desc: "Filter by game IDs (comma separated)" },
                        "brief": { type: "checkbox", desc: "Return brief info only" },
                        "stats": { type: "checkbox", desc: "Include statistics" },
                        "own": { type: "checkbox", desc: "Include owned games" },
                        "rated": { type: "checkbox", desc: "Include rated games" },
                        "played": { type: "checkbox", desc: "Include played games" },
                        "comment": { type: "checkbox", desc: "Include games with comments" },
                        "trade": { type: "checkbox", desc: "Include games for trade" },
                        "want": { type: "checkbox", desc: "Include wanted games" },
                        "wishlist": { type: "checkbox", desc: "Include wishlist items" },
                        "wishlistpriority": { type: "select", desc: "Wishlist priority", options: ["1", "2", "3", "4", "5"] },
                        "preordered": { type: "checkbox", desc: "Include preordered games" },
                        "wanttoplay": { type: "checkbox", desc: "Include want to play" },
                        "wanttobuy": { type: "checkbox", desc: "Include want to buy" },
                        "prevowned": { type: "checkbox", desc: "Include previously owned" },
                        "hasparts": { type: "checkbox", desc: "Include games with parts" },
                        "wantparts": { type: "checkbox", desc: "Include games wanting parts" },
                        "minrating": { type: "number", desc: "Minimum user rating (1-10)", min: 1, max: 10 },
                        "rating": { type: "number", desc: "Exact user rating (1-10)", min: 1, max: 10 },
                        "minbggrating": { type: "number", desc: "Minimum BGG rating", min: 1, max: 10 },
                        "bggrating": { type: "number", desc: "Exact BGG rating", min: 1, max: 10 },
                        "minplays": { type: "number", desc: "Minimum play count" },
                        "maxplays": { type: "number", desc: "Maximum play count" },
                        "showprivate": { type: "checkbox", desc: "Show private collection info" },
                        "collid": { type: "text", desc: "Collection item ID" },
                        "modifiedsince": { type: "date", desc: "Modified since date (YYYY-MM-DD)" }
                    }
                },
                search: {
                    name: "üîç Search",
                    desc: "Search for games, expansions, and accessories by name",
                    url: "https://boardgamegeek.com/xmlapi2/search",
                    required: ["query"],
                    optional: ["type", "exact"],
                    filters: {
                        "query": { type: "text", desc: "Search query", example: "Catan" },
                        "type": { type: "select", desc: "Search type", options: ["boardgame", "boardgameexpansion", "boardgameaccessory", "videogame", "rpgitem", "rpgissue"], default: "boardgame" },
                        "exact": { type: "checkbox", desc: "Exact name match only" }
                    }
                },
                user: {
                    name: "üë§ User Info",
                    desc: "Get user profile information and optional data",
                    url: "https://boardgamegeek.com/xmlapi2/user",
                    required: ["name"],
                    optional: ["buddies", "guilds", "hot", "top", "domain"],
                    filters: {
                        "name": { type: "text", desc: "BGG username", example: "sportomax" },
                        "buddies": { type: "checkbox", desc: "Include buddy list" },
                        "guilds": { type: "checkbox", desc: "Include guild memberships" },
                        "hot": { type: "checkbox", desc: "Include user's hot list" },
                        "top": { type: "checkbox", desc: "Include user's top list" },
                        "domain": { type: "select", desc: "Domain filter", options: ["boardgame", "rpg", "videogame"] }
                    }
                },
                hot: {
                    name: "üî• Hot Items",
                    desc: "Get currently hot/trending items by type",
                    url: "https://boardgamegeek.com/xmlapi2/hot",
                    required: [],
                    optional: ["type"],
                    filters: {
                        "type": { type: "select", desc: "Hot list type", options: ["boardgame", "rpg", "videogame", "boardgameperson", "rpgperson", "boardgamecompany", "rpgcompany", "videogamecompany"], default: "boardgame" }
                    }
                },
                plays: {
                    name: "üìä Plays",
                    desc: "Get play data for a user with date and game filtering",
                    url: "https://boardgamegeek.com/xmlapi2/plays",
                    required: ["username"],
                    optional: ["id", "type", "mindate", "maxdate", "subtype", "page"],
                    filters: {
                        "username": { type: "text", desc: "BGG username", example: "sportomax" },
                        "id": { type: "text", desc: "Game ID to filter plays" },
                        "type": { type: "select", desc: "Thing type", options: ["thing", "family"] },
                        "mindate": { type: "date", desc: "Start date (YYYY-MM-DD)" },
                        "maxdate": { type: "date", desc: "End date (YYYY-MM-DD)" },
                        "subtype": { type: "select", desc: "Game subtype", options: ["boardgame", "boardgameexpansion"] },
                        "page": { type: "number", desc: "Page number (100 plays per page)" }
                    }
                }
            },
            v1: {
                boardgame: {
                    name: "üé≤ Game Info",
                    desc: "Get detailed game information by ID (legacy format)",
                    url: "https://boardgamegeek.com/xmlapi/boardgame",
                    required: ["id"],
                    optional: ["stats", "comments"],
                    filters: {
                        "id": { type: "text", desc: "Game ID", example: "13" },
                        "stats": { type: "checkbox", desc: "Include statistics" },
                        "comments": { type: "checkbox", desc: "Include user comments" }
                    }
                },
                search: {
                    name: "üîç Search Games",
                    desc: "Search for games by name (legacy format)",
                    url: "https://boardgamegeek.com/xmlapi/search",
                    required: ["search"],
                    optional: ["exact"],
                    filters: {
                        "search": { type: "text", desc: "Search query", example: "Wingspan" },
                        "exact": { type: "checkbox", desc: "Exact match only" }
                    }
                },
                collection: {
                    name: "üìö Collection",
                    desc: "Get user collection (legacy format)",
                    url: "https://boardgamegeek.com/xmlapi/collection",
                    required: ["username"],
                    optional: ["own", "played", "prevowned", "trade", "want", "wishlist"],
                    filters: {
                        "username": { type: "text", desc: "BGG username", example: "sportomax" },
                        "own": { type: "checkbox", desc: "Include owned games" },
                        "played": { type: "checkbox", desc: "Include played games" },
                        "prevowned": { type: "checkbox", desc: "Include previously owned" },
                        "trade": { type: "checkbox", desc: "Include games for trade" },
                        "want": { type: "checkbox", desc: "Include wanted games" },
                        "wishlist": { type: "checkbox", desc: "Include wishlist items" }
                    }
                },
                geeklist: {
                    name: "üìã GeekList",
                    desc: "Get GeekList contents and metadata",
                    url: "https://boardgamegeek.com/xmlapi/geeklist",
                    required: ["id"],
                    optional: ["comments"],
                    filters: {
                        "id": { type: "text", desc: "GeekList ID", example: "12345" },
                        "comments": { type: "checkbox", desc: "Include comments" }
                    }
                },
                boardgamefamily: {
                    name: "üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Game Family",
                    desc: "Get games in a family/series",
                    url: "https://boardgamegeek.com/xmlapi/boardgamefamily",
                    required: ["id"],
                    optional: [],
                    filters: {
                        "id": { type: "text", desc: "Family ID", example: "5666" }
                    }
                },
                boardgamepublisher: {
                    name: "üè≠ Publisher",
                    desc: "Get publisher information and games",
                    url: "https://boardgamegeek.com/xmlapi/boardgamepublisher",
                    required: ["id"],
                    optional: [],
                    filters: {
                        "id": { type: "text", desc: "Publisher ID", example: "267" }
                    }
                }
            }
        };

        // Examples data
        const examples = [
            {
                title: "Get Gloomhaven Details",
                desc: "Retrieve comprehensive information about Gloomhaven including statistics",
                url: "https://boardgamegeek.com/xmlapi2/thing?id=174430&stats=1",
                category: "Game Details"
            },
            {
                title: "User's Owned Collection",
                desc: "Get all games owned by a user with statistics",
                url: "https://boardgamegeek.com/xmlapi2/collection?username=sportomax&own=1&stats=1",
                category: "Collections"
            },
            {
                title: "Search for Catan Games",
                desc: "Find all board games with 'Catan' in the name",
                url: "https://boardgamegeek.com/xmlapi2/search?query=Catan&type=boardgame",
                category: "Search"
            },
            {
                title: "Current Hot Board Games",
                desc: "Get the current trending board games",
                url: "https://boardgamegeek.com/xmlapi2/hot?type=boardgame",
                category: "Hot Lists"
            },
            {
                title: "User Profile with Buddies",
                desc: "Get user information including their buddy list",
                url: "https://boardgamegeek.com/xmlapi2/user?name=sportomax&buddies=1",
                category: "User Data"
            },
            {
                title: "Recent Plays for User",
                desc: "Get plays from the last 30 days for a user",
                url: "https://boardgamegeek.com/xmlapi2/plays?username=sportomax&mindate=2024-09-01&maxdate=2024-09-30",
                category: "Play Data"
            },
            {
                title: "Wingspan Collection Items",
                desc: "Get all Wingspan-related items in a user's collection",
                url: "https://boardgamegeek.com/xmlapi2/collection?username=sportomax&search=wingspan",
                category: "Collections"
            },
            {
                title: "Legacy Game Search",
                desc: "Search using the original API v1 format",
                url: "https://boardgamegeek.com/xmlapi/search?search=wingspan&exact=1",
                category: "Legacy API"
            }
        ];

        // Modal management
        function openModal(modalId) {
            console.log('üîç Opening modal:', modalId);
            
            const modal = document.getElementById(modalId + 'Modal');
            if (modal) {
                modal.style.display = 'block';
                document.body.style.overflow = 'hidden';
                
                // Initialize modal content based on type
                switch (modalId) {
                    case 'apiBuilder':
                        initializeApiBuilder();
                        break;
                    case 'apiReference':
                        initializeApiReference();
                        break;
                    case 'examples':
                        initializeExamples();
                        break;
                    case 'response':
                        initializeResponseModal();
                        break;
                    case 'cardsFullscreen':
                        initializeCardsFullscreenModal();
                        break;
                }
                
                console.log('‚úÖ Modal opened successfully');
            }
        }

        function closeModal(modalId) {
            console.log('‚ùå Closing modal:', modalId);
            
            const modal = document.getElementById(modalId + 'Modal');
            if (modal) {
                modal.style.display = 'none';
                document.body.style.overflow = 'auto';
                console.log('‚úÖ Modal closed successfully');
            }
        }

        // Initialize API Builder
        function initializeApiBuilder() {
            const grid = document.getElementById('endpointGrid');
            grid.innerHTML = '';
            
            // Add API v2 endpoints
            const v2Section = document.createElement('div');
            v2Section.innerHTML = '<h4 style="margin: 0.5em 0 0.25em 0; color: #1976d2; font-size: 0.9em;">BGG XML API v2 (Current)</h4>';
            grid.appendChild(v2Section);
            
            Object.entries(apiEndpoints.v2).forEach(([key, endpoint]) => {
                const card = createEndpointCard(key, endpoint, 'v2');
                grid.appendChild(card);
            });
            
            // Add API v1 endpoints
            const v1Section = document.createElement('div');
            v1Section.innerHTML = '<h4 style="margin: 0.5em 0 0.25em 0; color: #666; font-size: 0.9em;">BGG XML API v1 (Legacy)</h4>';
            grid.appendChild(v1Section);
            
            Object.entries(apiEndpoints.v1).forEach(([key, endpoint]) => {
                const card = createEndpointCard(key, endpoint, 'v1');
                grid.appendChild(card);
            });
        }

        function createEndpointCard(key, endpoint, version) {
            const card = document.createElement('div');
            card.className = 'endpoint-card';
            card.onclick = () => selectEndpoint(key, endpoint, version);
            
            card.innerHTML = `
                <div class="endpoint-name">${endpoint.name} - ${endpoint.desc}</div>
                <div class="endpoint-example">${endpoint.url}</div>
            `;
            
            return card;
        }

        function selectEndpoint(key, endpoint, version) {
            console.log('üìç Selected endpoint:', key, version);
            
            // Remove previous selection
            document.querySelectorAll('.endpoint-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // Add selection to clicked card
            event.target.closest('.endpoint-card').classList.add('selected');
            
            selectedEndpoint = { key, endpoint, version };
            
            // Show parameter form
            showParameterForm(endpoint);
        }

        function showParameterForm(endpoint) {
            const formContainer = document.getElementById('parameterForm');
            const formFields = document.getElementById('formFields');
            
            formFields.innerHTML = '';
            
            // Create form fields for required and optional parameters
            const allParams = [...endpoint.required, ...endpoint.optional];
            
            allParams.forEach(paramName => {
                const filter = endpoint.filters[paramName];
                if (filter) {
                    const field = createFormField(paramName, filter, endpoint.required.includes(paramName));
                    formFields.appendChild(field);
                }
            });
            
            formContainer.classList.remove('hidden');
        }

        function createFormField(name, filter, isRequired) {
            const group = document.createElement('div');
            group.className = 'form-group';
            
            const label = document.createElement('label');
            label.className = 'form-label';
            const labelText = `${filter.desc}${isRequired ? ' (Required)' : ''}`;
            label.textContent = labelText;
            
            // Use inline layout for shorter labels (less than 25 characters)
            if (labelText.length < 25) {
                group.classList.add('inline');
            }
            
            let input;
            
            switch (filter.type) {
                case 'text':
                    input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'form-input';
                    input.placeholder = filter.example || '';
                    if (isRequired) input.required = true;
                    break;
                    
                case 'number':
                    input = document.createElement('input');
                    input.type = 'number';
                    input.className = 'form-input';
                    if (filter.min !== undefined) input.min = filter.min;
                    if (filter.max !== undefined) input.max = filter.max;
                    if (isRequired) input.required = true;
                    break;
                    
                case 'date':
                    input = document.createElement('input');
                    input.type = 'date';
                    input.className = 'form-input';
                    if (isRequired) input.required = true;
                    break;
                    
                case 'select':
                    input = document.createElement('select');
                    input.className = 'form-select';
                    if (!isRequired) {
                        const emptyOption = document.createElement('option');
                        emptyOption.value = '';
                        emptyOption.textContent = '-- Select --';
                        input.appendChild(emptyOption);
                    }
                    filter.options.forEach(option => {
                        const optionEl = document.createElement('option');
                        optionEl.value = option;
                        optionEl.textContent = option;
                        if (filter.default === option) optionEl.selected = true;
                        input.appendChild(optionEl);
                    });
                    if (isRequired) input.required = true;
                    break;
                    
                case 'checkbox':
                    const checkboxContainer = document.createElement('div');
                    checkboxContainer.className = 'checkbox-item';
                    
                    input = document.createElement('input');
                    input.type = 'checkbox';
                    input.id = `param_${name}`;
                    
                    const checkboxLabel = document.createElement('label');
                    checkboxLabel.htmlFor = input.id;
                    checkboxLabel.textContent = filter.desc + (isRequired ? ' (Required)' : '');
                    
                    checkboxContainer.appendChild(input);
                    checkboxContainer.appendChild(checkboxLabel);
                    
                    // For checkboxes, we don't need the separate label since it's inline
                    group.appendChild(checkboxContainer);
                    
                    input.dataset.paramName = name;
                    return group;
            }
            
            input.dataset.paramName = name;
            group.appendChild(label);
            group.appendChild(input);
            
            return group;
        }

        function buildApiCall() {
            if (!selectedEndpoint) {
                alert('Please select an endpoint first');
                return;
            }
            
            console.log('üîó Building API call for:', selectedEndpoint);
            
            const { endpoint, version } = selectedEndpoint;
            
            // Debug: Check if form fields exist
            const formFieldsContainer = document.getElementById('formFields');
            console.log('üìã Form fields container:', formFieldsContainer);
            console.log('üìã Form fields HTML:', formFieldsContainer ? formFieldsContainer.innerHTML.substring(0, 200) : 'NOT FOUND');
            
            // Collect parameters from form - Fixed approach
            const params = new URLSearchParams();
            const inputs = document.querySelectorAll('#formFields input, #formFields select');
            
            console.log('üìù Found inputs:', inputs.length);
            
            if (inputs.length === 0) {
                console.log('‚ùå No inputs found! Checking alternative selectors...');
                const allInputs = document.querySelectorAll('input, select');
                console.log('üîç All inputs in document:', allInputs.length);
                
                const modalInputs = document.querySelectorAll('#apiBuilderModal input, #apiBuilderModal select');
                console.log('üîç Inputs in modal:', modalInputs.length);
            }
            
            inputs.forEach((input, index) => {
                const paramName = input.dataset.paramName;
                let value = '';
                
                console.log(`üìã Processing input ${index + 1}:`, {
                    paramName: paramName,
                    type: input.type,
                    value: input.value,
                    checked: input.checked,
                    dataset: input.dataset
                });
                
                if (input.type === 'checkbox') {
                    if (input.checked) {
                        value = '1';
                        console.log('‚úÖ Checkbox checked:', paramName);
                    }
                } else {
                    value = input.value.trim();
                    console.log('üìÑ Input value:', paramName, '=', value);
                }
                
                if (value && paramName) {
                    params.append(paramName, value);
                    console.log('‚ûï Added param:', paramName, '=', value);
                } else if (!paramName) {
                    console.log('‚ùå Missing paramName for input:', input);
                }
            });
            
            console.log('üìä Total params collected:', params.toString());
            
            // Build URL
            let url = endpoint.url;
            
            // For v1 APIs that need ID in path
            if (version === 'v1' && (selectedEndpoint.key === 'boardgame' || selectedEndpoint.key === 'geeklist' || selectedEndpoint.key === 'boardgamefamily' || selectedEndpoint.key === 'boardgamepublisher')) {
                const idInput = document.querySelector('input[data-param-name="id"]');
                if (idInput && idInput.value) {
                    url += '/' + idInput.value;
                    params.delete('id');
                }
            }
            
            // For v1 collection API
            if (version === 'v1' && selectedEndpoint.key === 'collection') {
                const usernameInput = document.querySelector('input[data-param-name="username"]');
                if (usernameInput && usernameInput.value) {
                    url += '/' + usernameInput.value;
                    params.delete('username');
                }
            }
            
            if (params.toString()) {
                url += '?' + params.toString();
            }
            
            // Store current API call
            currentApiCall = {
                url: url,
                endpoint: selectedEndpoint,
                params: Object.fromEntries(params)
            };
            
            // Update UI
            updateCurrentApiDisplay();
            closeModal('apiBuilder');
            
            console.log('‚úÖ API call built:', url);
        }

        function updateCurrentApiDisplay() {
            const section = document.getElementById('currentApiSection');
            const display = document.getElementById('currentApiDisplay');
            
            if (currentApiCall) {
                display.textContent = currentApiCall.url;
                section.style.display = 'block';
            } else {
                section.style.display = 'none';
            }
        }

        async function executeApiCall() {
            if (!currentApiCall) {
                alert('No API call to execute');
                return;
            }
            
            console.log('üöÄ Executing API call:', currentApiCall.url);
            
            const responseSection = document.getElementById('responseSection');
            const responseInfo = document.getElementById('responseInfo');
            const responseContent = document.getElementById('responseContent');
            const viewFullBtn = document.getElementById('viewFullResponseBtn');
            
            // Show loading state
            responseSection.style.display = 'block';
            responseInfo.innerHTML = '<div class="loading">üîÑ Loading...</div>';
            responseContent.textContent = '';
            viewFullBtn.style.display = 'none';
            
            const maxRetries = 5;
            let attempt = 1;
            let lastError = null;
            
            while (attempt <= maxRetries) {
                const startTime = performance.now();
                
                try {
                    console.log(`üîÑ Attempt ${attempt}/${maxRetries} for API call`);
                    if (attempt > 1) {
                        responseInfo.innerHTML = `<div class="loading">üîÑ Retrying... (Attempt ${attempt}/${maxRetries})</div>`;
                    }
                    
                    const response = await fetch(currentApiCall.url);
                    const endTime = performance.now();
                    const duration = Math.round(endTime - startTime);
                    
                    console.log(`‚è±Ô∏è API call completed in ${duration}ms`);
                    console.log('üìä Response status:', response.status, response.statusText);
                    
                    // If we get a 202, BGG is preparing the data - wait and retry
                    if (response.status === 202 && attempt < maxRetries) {
                        console.log('üìÖ BGG returned 202 (Accepted) - data being prepared, will retry');
                        responseInfo.innerHTML = `
                            <div class="loading">
                                üîÑ BGG is preparing data... (Attempt ${attempt}/${maxRetries})<br>
                                Status: 202 Accepted - Retrying in ${attempt * 2} seconds
                            </div>
                        `;
                        
                        // Wait before retrying (exponential backoff: 2s, 4s, 6s, 8s)
                        await new Promise(resolve => setTimeout(resolve, attempt * 2000));
                        attempt++;
                        continue;
                    }
                    
                    // Success or final attempt - process the response
                    responseInfo.innerHTML = `
                        <strong>Status:</strong> ${response.status} ${response.statusText}<br>
                        <strong>Response Time:</strong> ${duration}ms<br>
                        <strong>Content-Type:</strong> ${response.headers.get('content-type') || 'Unknown'}<br>
                        <strong>Attempts:</strong> ${attempt}/${maxRetries}
                    `;
                    
                    const text = await response.text();
                    console.log('üìè Response size:', text.length, 'characters');
                    
                    currentResponse = text;
                    
                    // Show preview (first 1000 characters)
                    const preview = text.length > 1000 ? text.substring(0, 1000) + '...\n\n[Truncated - Click "View Full Response" to see complete data]' : text;
                    responseContent.textContent = preview;
                    
                    if (text.length > 1000) {
                        viewFullBtn.style.display = 'block';
                    }
                    
                    // Generate dynamic cards based on response
                    generateDynamicCards(text, currentApiCall);
                    
                    if (response.status === 202) {
                        console.log('‚ö†Ô∏è Final attempt still returned 202 - BGG data may not be ready yet');
                        responseInfo.innerHTML += '<br><div style="color: orange;">‚ö†Ô∏è BGG returned 202 after all retries - data may not be fully prepared</div>';
                    } else {
                        console.log('‚úÖ Response displayed successfully');
                    }
                    
                    return; // Success - exit the retry loop
                    
                } catch (error) {
                    console.log(`‚ùå Attempt ${attempt} failed:`, error.message);
                    lastError = error;
                    
                    if (attempt < maxRetries) {
                        responseInfo.innerHTML = `
                            <div class="loading">
                                ‚ùå Attempt ${attempt} failed: ${error.message}<br>
                                Retrying in ${attempt * 2} seconds...
                            </div>
                        `;
                        await new Promise(resolve => setTimeout(resolve, attempt * 2000));
                        attempt++;
                    } else {
                        // All retries failed
                        console.log('‚ùå All retry attempts failed');
                        responseInfo.innerHTML = `<div class="error">‚ùå Failed after ${maxRetries} attempts<br>Last error: ${error.message}</div>`;
                        responseContent.textContent = '';
                        return;
                    }
                }
            }
        }

        function copyCurrentUrl() {
            if (!currentApiCall) {
                alert('No API call to copy');
                return;
            }
            
            const btn = document.getElementById('copyBtn') || event.target;
            const originalText = btn.textContent;
            
            navigator.clipboard.writeText(currentApiCall.url).then(() => {
                btn.textContent = '‚úÖ Copied!';
                btn.style.background = '#4caf50';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '';
                }, 2000);
                console.log('üìã URL copied to clipboard');
            }).catch(error => {
                console.log('‚ùå Copy failed:', error);
                // Fallback for older browsers or HTTPS issues
                try {
                    const textArea = document.createElement('textarea');
                    textArea.value = currentApiCall.url;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    
                    btn.textContent = '‚úÖ Copied!';
                    btn.style.background = '#4caf50';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '';
                    }, 2000);
                    console.log('üìã URL copied using fallback method');
                } catch (fallbackError) {
                    console.log('‚ùå Fallback copy also failed:', fallbackError);
                    alert('Copy failed. URL: ' + currentApiCall.url);
                }
            });
        }

        function clearApiCall() {
            currentApiCall = null;
            currentResponse = null;
            selectedEndpoint = null;
            
            document.getElementById('currentApiSection').style.display = 'none';
            document.getElementById('responseSection').style.display = 'none';
            document.getElementById('cardsSection').style.display = 'none';
            
            // Hide fullscreen button
            const fullscreenBtn = document.getElementById('fullscreenCardsBtn');
            if (fullscreenBtn) {
                fullscreenBtn.style.display = 'none';
            }
            
            console.log('üóëÔ∏è API call cleared');
        }

        // Fullscreen Cards Functions
        function openCardsFullscreen() {
            console.log('üîç Opening cards in fullscreen');
            openModal('cardsFullscreen');
        }

        function initializeCardsFullscreenModal() {
            console.log('üé¥ Initializing fullscreen cards modal');
            
            const fullscreenInfo = document.getElementById('fullscreenCardsInfo');
            const fullscreenContainer = document.getElementById('fullscreenCardsContainer');
            const originalInfo = document.getElementById('cardsInfo');
            const originalContainer = document.getElementById('cardsContainer');
            
            // Copy content from original cards section
            if (originalInfo && originalContainer) {
                fullscreenInfo.innerHTML = originalInfo.innerHTML;
                fullscreenContainer.innerHTML = originalContainer.innerHTML;
                console.log('‚úÖ Cards content copied to fullscreen modal');
            } else {
                fullscreenInfo.innerHTML = 'No cards data available';
                fullscreenContainer.innerHTML = '';
                console.log('‚ùå No cards data to display in fullscreen');
            }
        }

        // Initialize API Reference
        function initializeApiReference() {
            switchApiTab('v2');
        }

        function switchApiTab(version) {
            // Update tab buttons
            document.querySelectorAll('.api-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Generate content
            const content = document.getElementById('apiReferenceContent');
            content.innerHTML = '';
            
            const endpoints = apiEndpoints[version];
            
            Object.entries(endpoints).forEach(([key, endpoint]) => {
                const section = document.createElement('div');
                section.className = 'api-section';
                
                section.innerHTML = `
                    <div class="api-endpoint">
                        <div class="api-endpoint-name">${endpoint.name}</div>
                        <div class="api-endpoint-desc">${endpoint.desc}</div>
                        <div style="font-family: monospace; background: #e9ecef; padding: 0.5em; border-radius: 4px; margin: 0.5em 0; font-size: 0.8em;">
                            ${endpoint.url}
                        </div>
                        <div class="api-filters">
                            <strong>Required Parameters:</strong><br>
                            ${endpoint.required.length ? endpoint.required.map(param => 
                                `<span class="filter-tag required-filter">${param}</span> ${endpoint.filters[param]?.desc || ''}`
                            ).join('<br>') : 'None'}
                            <br><br>
                            <strong>Optional Parameters:</strong><br>
                            ${endpoint.optional.length ? endpoint.optional.map(param => 
                                `<span class="filter-tag optional-filter">${param}</span> ${endpoint.filters[param]?.desc || ''}`
                            ).join('<br>') : 'None'}
                        </div>
                    </div>
                `;
                
                content.appendChild(section);
            });
        }

        // Initialize Examples
        function initializeExamples() {
            const content = document.getElementById('examplesContent');
            content.innerHTML = '';
            
            const grid = document.createElement('div');
            grid.className = 'example-grid';
            
            examples.forEach(example => {
                const card = document.createElement('div');
                card.className = 'example-card';
                
                card.innerHTML = `
                    <div class="example-title">${example.title}</div>
                    <div class="example-desc">${example.desc}</div>
                    <div class="example-url">${example.url}</div>
                    <button class="btn btn-primary" onclick="useExample('${example.url}', '${example.title}')">
                        üîó Use This Example
                    </button>
                `;
                
                grid.appendChild(card);
            });
            
            content.appendChild(grid);
        }

        function useExample(url, title) {
            console.log('üí° Using example:', title);
            
            currentApiCall = {
                url: url,
                endpoint: { name: title, desc: 'From examples library' },
                params: {}
            };
            
            updateCurrentApiDisplay();
            closeModal('examples');
            
            console.log('‚úÖ Example loaded:', url);
        }

        // Initialize Response Modal
        function initializeResponseModal() {
            console.log('üìÑ Initializing response modal, currentResponse length:', currentResponse ? currentResponse.length : 0);
            const content = document.getElementById('fullResponseContent');
            if (currentResponse) {
                content.textContent = currentResponse;
                console.log('‚úÖ Response content loaded into modal');
            } else {
                content.textContent = 'No response data available';
                console.log('‚ùå No response data available');
            }
        }

        // Close modals when clicking outside
        document.addEventListener('click', function(event) {
            if (event.target.classList.contains('modal')) {
                const modalId = event.target.id.replace('Modal', '');
                closeModal(modalId);
            }
        });

        // Close modals with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const openModal = document.querySelector('.modal[style*="block"]');
                if (openModal) {
                    const modalId = openModal.id.replace('Modal', '');
                    closeModal(modalId);
                }
            }
        });

        // Initialize page
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üé≤ BGG API Helper initialized');
            updateCurrentApiDisplay();
        });

        // Dynamic Cards Generation
        function generateDynamicCards(xmlText, apiCall) {
            console.log('üé¥ Generating dynamic cards for API response');
            
            const cardsSection = document.getElementById('cardsSection');
            const cardsInfo = document.getElementById('cardsInfo');
            const cardsContainer = document.getElementById('cardsContainer');
            
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                
                // Check for XML parsing errors
                const parseError = xmlDoc.querySelector('parsererror');
                if (parseError) {
                    console.log('‚ùå XML parsing error:', parseError.textContent);
                    cardsSection.style.display = 'none';
                    return;
                }
                
                // Determine endpoint type and generate appropriate cards
                let cards = [];
                let cardType = 'unknown';
                
                if (apiCall.endpoint.key === 'thing' || xmlDoc.querySelector('items')) {
                    cards = generateThingCards(xmlDoc);
                    cardType = 'games';
                } else if (apiCall.endpoint.key === 'collection' || xmlDoc.querySelector('items item[objecttype]')) {
                    cards = generateCollectionCards(xmlDoc);
                    cardType = 'collection';
                } else if (apiCall.endpoint.key === 'search' || xmlDoc.querySelector('items item[type]')) {
                    cards = generateSearchCards(xmlDoc);
                    cardType = 'search';
                } else if (apiCall.endpoint.key === 'hot' || xmlDoc.querySelector('items item[rank]')) {
                    cards = generateHotCards(xmlDoc);
                    cardType = 'hot';
                } else if (apiCall.endpoint.key === 'user' || xmlDoc.querySelector('user')) {
                    cards = generateUserCards(xmlDoc);
                    cardType = 'user';
                } else if (apiCall.endpoint.key === 'plays' || xmlDoc.querySelector('plays')) {
                    cards = generatePlaysCards(xmlDoc);
                    cardType = 'plays';
                } else if (apiCall.endpoint.key === 'geeklist' || xmlDoc.querySelector('geeklist')) {
                    cards = generateGeeklistCards(xmlDoc);
                    cardType = 'geeklist';
                }
                
                if (cards.length > 0) {
                    cardsInfo.innerHTML = `üìä Found ${cards.length} ${cardType} items`;
                    cardsContainer.innerHTML = cards.join('');
                    cardsSection.style.display = 'block';
                    
                    // Show fullscreen button
                    const fullscreenBtn = document.getElementById('fullscreenCardsBtn');
                    if (fullscreenBtn) {
                        fullscreenBtn.style.display = 'inline-block';
                    }
                    
                    console.log(`‚úÖ Generated ${cards.length} ${cardType} cards`);
                } else {
                    console.log('‚ùå No cards generated - unsupported data format');
                    cardsSection.style.display = 'none';
                }
                
            } catch (error) {
                console.log('‚ùå Error generating cards:', error);
                cardsSection.style.display = 'none';
            }
        }

        function generateThingCards(xmlDoc) {
            const items = xmlDoc.querySelectorAll('item');
            const cards = [];
            
            items.forEach(item => {
                const id = item.getAttribute('id');
                const type = item.getAttribute('type') || 'boardgame';
                const name = item.querySelector('name[type="primary"]')?.getAttribute('value') || 
                           item.querySelector('name')?.getAttribute('value') || 'Unknown';
                const image = item.querySelector('image')?.textContent || '';
                const thumbnail = item.querySelector('thumbnail')?.textContent || image;
                const yearPublished = item.querySelector('yearpublished')?.getAttribute('value') || '';
                const description = item.querySelector('description')?.textContent || '';
                
                // Stats
                const stats = item.querySelector('statistics ratings');
                const rating = stats?.querySelector('average')?.getAttribute('value') || '';
                const bayesAverage = stats?.querySelector('bayesaverage')?.getAttribute('value') || '';
                const rank = stats?.querySelector('rank[name="boardgame"]')?.getAttribute('value') || '';
                const numPlayers = item.querySelector('minplayers')?.getAttribute('value') + 
                                 (item.querySelector('maxplayers')?.getAttribute('value') ? 
                                  '-' + item.querySelector('maxplayers')?.getAttribute('value') : '') || '';
                
                cards.push(`
                    <div class="result-card">
                        <div class="card-header">
                            ${thumbnail ? `<img src="${thumbnail}" alt="${name}" class="card-thumbnail" loading="lazy">` : '<div class="card-thumbnail" style="background: #e0e0e0; display: flex; align-items: center; justify-content: center; color: #999; font-size: 0.7em;">No Image</div>'}
                            <div class="card-main">
                                <div class="card-title">${name}</div>
                                <div class="card-subtitle">${type.charAt(0).toUpperCase() + type.slice(1)} ${yearPublished ? `(${yearPublished})` : ''}</div>
                            </div>
                        </div>
                        ${rating || rank || numPlayers ? `
                            <div class="card-stats">
                                ${rating ? `<div class="stat-item"><span class="stat-label">Rating</span><span class="stat-value">${parseFloat(rating).toFixed(1)}</span></div>` : ''}
                                ${rank && rank !== 'Not Ranked' ? `<div class="stat-item"><span class="stat-label">BGG Rank</span><span class="stat-value">#${rank}</span></div>` : ''}
                                ${numPlayers ? `<div class="stat-item"><span class="stat-label">Players</span><span class="stat-value">${numPlayers}</span></div>` : ''}
                                ${bayesAverage ? `<div class="stat-item"><span class="stat-label">Bayes Avg</span><span class="stat-value">${parseFloat(bayesAverage).toFixed(1)}</span></div>` : ''}
                            </div>
                        ` : ''}
                        ${description ? `<div class="card-details">${description.substring(0, 150)}${description.length > 150 ? '...' : ''}</div>` : ''}
                        <div class="card-actions">
                            <a href="https://boardgamegeek.com/${type}/${id}" target="_blank" class="card-btn">üîó View on BGG</a>
                            ${image ? `<a href="${image}" target="_blank" class="card-btn secondary">üñºÔ∏è Full Image</a>` : ''}
                        </div>
                    </div>
                `);
            });
            
            return cards;
        }

        function generateCollectionCards(xmlDoc) {
            const items = xmlDoc.querySelectorAll('item');
            const cards = [];
            
            items.forEach(item => {
                const objectid = item.getAttribute('objectid');
                const objecttype = item.getAttribute('objecttype') || 'boardgame';
                const name = item.querySelector('name')?.textContent || 'Unknown';
                const image = item.querySelector('image')?.textContent || '';
                const thumbnail = item.querySelector('thumbnail')?.textContent || image;
                const yearPublished = item.querySelector('yearpublished')?.textContent || '';
                
                // Collection specific data
                const owned = item.querySelector('status')?.getAttribute('own') === '1';
                const played = item.querySelector('status')?.getAttribute('played') === '1';
                const rating = item.querySelector('stats rating')?.getAttribute('value') || '';
                const numPlays = item.querySelector('numplays')?.textContent || '0';
                
                const statusTags = [];
                if (owned) statusTags.push('üëç Owned');
                if (played) statusTags.push('üéØ Played');
                if (item.querySelector('status')?.getAttribute('fortrade') === '1') statusTags.push('üí± For Trade');
                if (item.querySelector('status')?.getAttribute('want') === '1') statusTags.push('üíù Want');
                
                cards.push(`
                    <div class="result-card">
                        <div class="card-header">
                            ${thumbnail ? `<img src="${thumbnail}" alt="${name}" class="card-thumbnail" loading="lazy">` : '<div class="card-thumbnail" style="background: #e0e0e0; display: flex; align-items: center; justify-content: center; color: #999; font-size: 0.7em;">No Image</div>'}
                            <div class="card-main">
                                <div class="card-title">${name}</div>
                                <div class="card-subtitle">${objecttype.charAt(0).toUpperCase() + objecttype.slice(1)} ${yearPublished ? `(${yearPublished})` : ''}</div>
                            </div>
                        </div>
                        ${rating || numPlays ? `
                            <div class="card-stats">
                                ${rating ? `<div class="stat-item"><span class="stat-label">My Rating</span><span class="stat-value">${rating}</span></div>` : ''}
                                <div class="stat-item"><span class="stat-label">Plays</span><span class="stat-value">${numPlays}</span></div>
                            </div>
                        ` : ''}
                        ${statusTags.length ? `<div class="card-details">${statusTags.join(' ‚Ä¢ ')}</div>` : ''}
                        <div class="card-actions">
                            <a href="https://boardgamegeek.com/${objecttype}/${objectid}" target="_blank" class="card-btn">üîó View Game</a>
                        </div>
                    </div>
                `);
            });
            
            return cards;
        }

        function generateSearchCards(xmlDoc) {
            const items = xmlDoc.querySelectorAll('item');
            const cards = [];
            
            items.forEach(item => {
                const id = item.getAttribute('id');
                const type = item.getAttribute('type') || 'boardgame';
                const name = item.querySelector('name')?.getAttribute('value') || 'Unknown';
                const yearPublished = item.querySelector('yearpublished')?.getAttribute('value') || '';
                
                cards.push(`
                    <div class="result-card">
                        <div class="card-header">
                            <div class="card-thumbnail" style="background: #e3f2fd; display: flex; align-items: center; justify-content: center; color: #1976d2; font-size: 1.2em;">üîç</div>
                            <div class="card-main">
                                <div class="card-title">${name}</div>
                                <div class="card-subtitle">${type.charAt(0).toUpperCase() + type.slice(1)} ${yearPublished ? `(${yearPublished})` : ''}</div>
                            </div>
                        </div>
                        <div class="card-actions">
                            <a href="https://boardgamegeek.com/${type}/${id}" target="_blank" class="card-btn">üîó View on BGG</a>
                            <button onclick="loadGameDetails('${id}')" class="card-btn secondary">üìÑ Get Details</button>
                        </div>
                    </div>
                `);
            });
            
            return cards;
        }

        function generateHotCards(xmlDoc) {
            const items = xmlDoc.querySelectorAll('item');
            const cards = [];
            
            items.forEach(item => {
                const id = item.getAttribute('id');
                const rank = item.getAttribute('rank');
                const name = item.querySelector('name')?.getAttribute('value') || 'Unknown';
                const thumbnail = item.querySelector('thumbnail')?.getAttribute('value') || '';
                const yearPublished = item.querySelector('yearpublished')?.getAttribute('value') || '';
                
                cards.push(`
                    <div class="result-card">
                        <div class="card-header">
                            ${thumbnail ? `<img src="${thumbnail}" alt="${name}" class="card-thumbnail" loading="lazy">` : '<div class="card-thumbnail" style="background: #ff5722; display: flex; align-items: center; justify-content: center; color: white; font-size: 1em;">üî•</div>'}
                            <div class="card-main">
                                <div class="card-title">#${rank} ${name}</div>
                                <div class="card-subtitle">Hot Item ${yearPublished ? `(${yearPublished})` : ''}</div>
                            </div>
                        </div>
                        <div class="card-actions">
                            <a href="https://boardgamegeek.com/boardgame/${id}" target="_blank" class="card-btn">üîó View on BGG</a>
                            <button onclick="loadGameDetails('${id}')" class="card-btn secondary">üìÑ Get Details</button>
                        </div>
                    </div>
                `);
            });
            
            return cards;
        }

        function generateUserCards(xmlDoc) {
            const user = xmlDoc.querySelector('user');
            if (!user) return [];
            
            const id = user.getAttribute('id');
            const name = user.getAttribute('name');
            const firstname = user.querySelector('firstname')?.getAttribute('value') || '';
            const lastname = user.querySelector('lastname')?.getAttribute('value') || '';
            const avatarlink = user.querySelector('avatarlink')?.getAttribute('value') || '';
            const country = user.querySelector('country')?.getAttribute('value') || '';
            const state = user.querySelector('state')?.getAttribute('value') || '';
            
            const cards = [`
                <div class="result-card">
                    <div class="card-header">
                        ${avatarlink ? `<img src="${avatarlink}" alt="${name}" class="card-thumbnail" loading="lazy">` : '<div class="card-thumbnail" style="background: #4caf50; display: flex; align-items: center; justify-content: center; color: white; font-size: 1.2em;">üë§</div>'}
                        <div class="card-main">
                            <div class="card-title">${name} (ID: ${id})</div>
                            <div class="card-subtitle">${firstname} ${lastname}</div>
                        </div>
                    </div>
                    ${country || state ? `<div class="card-details">üìç ${state ? state + ', ' : ''}${country}</div>` : ''}
                    <div class="card-actions">
                        <a href="https://boardgamegeek.com/user/${name}" target="_blank" class="card-btn">üë§ View Profile</a>
                        <button onclick="loadUserCollection('${name}')" class="card-btn secondary">üì¶ View Collection</button>
                    </div>
                </div>
            `];
            
            return cards;
        }

        function generatePlaysCards(xmlDoc) {
            const plays = xmlDoc.querySelectorAll('play');
            const cards = [];
            
            plays.forEach(play => {
                const id = play.getAttribute('id');
                const date = play.getAttribute('date');
                const quantity = play.getAttribute('quantity') || '1';
                const length = play.getAttribute('length') || '';
                const location = play.getAttribute('location') || '';
                
                const item = play.querySelector('item');
                const gameName = item?.getAttribute('name') || 'Unknown Game';
                const gameId = item?.getAttribute('objectid') || '';
                
                const players = play.querySelectorAll('players player');
                const playerCount = players.length;
                
                cards.push(`
                    <div class="result-card">
                        <div class="card-header">
                            <div class="card-thumbnail" style="background: #9c27b0; display: flex; align-items: center; justify-content: center; color: white; font-size: 1em;">üé≤</div>
                            <div class="card-main">
                                <div class="card-title">${gameName}</div>
                                <div class="card-subtitle">Played on ${date}</div>
                            </div>
                        </div>
                        <div class="card-stats">
                            <div class="stat-item"><span class="stat-label">Players</span><span class="stat-value">${playerCount || 'N/A'}</span></div>
                            ${length ? `<div class="stat-item"><span class="stat-label">Duration</span><span class="stat-value">${length} min</span></div>` : ''}
                            <div class="stat-item"><span class="stat-label">Plays</span><span class="stat-value">${quantity}</span></div>
                            ${location ? `<div class="stat-item"><span class="stat-label">Location</span><span class="stat-value">${location}</span></div>` : ''}
                        </div>
                        <div class="card-actions">
                            ${gameId ? `<a href="https://boardgamegeek.com/boardgame/${gameId}" target="_blank" class="card-btn">üîó View Game</a>` : ''}
                        </div>
                    </div>
                `);
            });
            
            return cards;
        }

        function generateGeeklistCards(xmlDoc) {
            const items = xmlDoc.querySelectorAll('item');
            const cards = [];
            
            items.forEach(item => {
                const id = item.getAttribute('id');
                const objecttype = item.getAttribute('objecttype') || 'thing';
                const objectid = item.getAttribute('objectid') || '';
                const objectname = item.getAttribute('objectname') || 'Unknown';
                const username = item.getAttribute('username') || '';
                const postdate = item.getAttribute('postdate') || '';
                const body = item.querySelector('body')?.textContent || '';
                
                cards.push(`
                    <div class="result-card">
                        <div class="card-header">
                            <div class="card-thumbnail" style="background: #ff9800; display: flex; align-items: center; justify-content: center; color: white; font-size: 1em;">üìã</div>
                            <div class="card-main">
                                <div class="card-title">${objectname}</div>
                                <div class="card-subtitle">by ${username} ‚Ä¢ ${postdate}</div>
                            </div>
                        </div>
                        ${body ? `<div class="card-details">${body.substring(0, 200)}${body.length > 200 ? '...' : ''}</div>` : ''}
                        <div class="card-actions">
                            ${objectid ? `<a href="https://boardgamegeek.com/${objecttype}/${objectid}" target="_blank" class="card-btn">üîó View Item</a>` : ''}
                        </div>
                    </div>
                `);
            });
            
            return cards;
        }

        // Helper functions for card actions
        function loadGameDetails(gameId) {
            console.log('üéØ Loading details for game:', gameId);
            
            currentApiCall = {
                url: `https://boardgamegeek.com/xmlapi2/thing?id=${gameId}&stats=1`,
                endpoint: { name: 'Game Details', desc: 'Auto-generated from search result' },
                params: { id: gameId, stats: '1' }
            };
            
            updateCurrentApiDisplay();
            executeApiCall();
        }

        function loadUserCollection(username) {
            console.log('üë§ Loading collection for user:', username);
            
            currentApiCall = {
                url: `https://boardgamegeek.com/xmlapi2/collection?username=${username}&own=1&stats=1`,
                endpoint: { name: 'User Collection', desc: 'Auto-generated from user result' },
                params: { username: username, own: '1', stats: '1' }
            };
            
            updateCurrentApiDisplay();
            executeApiCall();
        }
    </script>
</body>
</html>