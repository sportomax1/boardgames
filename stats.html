<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BGG Collection Stats Dashboard</title>
    <!-- Load Tailwind CSS from CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a cleaner dashboard look */
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s;
        }
        /* Simple spinner animation */
        .spinner {
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        /* Style for the debug log area */
        #debugLogContainer {
            max-height: 400px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.85rem;
            line-height: 1.4;
        }
        .log-item {
            padding: 4px 0;
            border-bottom: 1px solid #2d3748;
        }
        .log-error { color: #f56565; }
        .log-success { color: #48bb78; }
        .log-info { color: #63b3ed; }
        .log-warning { color: #f6e05e; }

        /* Style for the detailed stat lists */
        .detailed-stat-list {
            max-height: 300px; /* Limit height for better layout management */
            overflow-y: auto;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        
        <!-- Header and Controls -->
        <header class="mb-8">
            <h1 class="text-3xl md:text-4xl font-extrabold text-blue-400 mb-4 tracking-tight">BGG Collection Stats Dashboard</h1>
            <p class="text-gray-400 mb-6">Analyze your collection with core metrics and detailed BGG data.</p>
            
            <div class="bg-gray-800 p-6 rounded-xl shadow-2xl mb-6">
                <div class="flex flex-col sm:flex-row gap-4 mb-6">
                    <input 
                        type="text" 
                        id="usernameInput" 
                        value="sportomax" 
                        class="flex-grow bg-gray-700 text-white border border-gray-600 rounded-xl px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500 shadow-inner"
                        placeholder="Enter YOUR BGG Username"
                        aria-label="BGG Username"
                    >
                    <button 
                        id="fetchButton" 
                        class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-xl transition duration-300 shadow-xl active:scale-95"
                    >
                        Fetch Stats
                    </button>
                </div>
                
                <!-- Filter Checkboxes -->
                <h3 class="text-lg font-semibold text-gray-300 mb-3 border-b border-gray-700 pb-2">Collection Filters (What to Analyze)</h3>
                <div id="filterContainer" class="grid grid-cols-2 sm:grid-cols-4 md:grid-cols-6 gap-3">
                    <label class="flex items-center space-x-2 cursor-pointer">
                        <input type="checkbox" id="filter-own" value="1" class="form-checkbox text-blue-500 rounded bg-gray-700 border-gray-600 focus:ring-blue-500" checked>
                        <span class="text-sm text-gray-300">Owned</span>
                    </label>
                    <label class="flex items-center space-x-2 cursor-pointer">
                        <input type="checkbox" id="filter-prevowned" value="1" class="form-checkbox text-blue-500 rounded bg-gray-700 border-gray-600 focus:ring-blue-500">
                        <span class="text-sm text-gray-300">Previously Owned</span>
                    </label>
                    <label class="flex items-center space-x-2 cursor-pointer">
                        <input type="checkbox" id="filter-fortrade" value="1" class="form-checkbox text-blue-500 rounded bg-gray-700 border-gray-600 focus:ring-blue-500">
                        <span class="text-sm text-gray-300">For Trade</span>
                    </label>
                    <label class="flex items-center space-x-2 cursor-pointer">
                        <input type="checkbox" id="filter-want" value="1" class="form-checkbox text-blue-500 rounded bg-gray-700 border-gray-600 focus:ring-blue-500">
                        <span class="text-sm text-gray-300">Want In Trade</span>
                    </label>
                    <label class="flex items-center space-x-2 cursor-pointer">
                        <input type="checkbox" id="filter-wanttoplay" value="1" class="form-checkbox text-blue-500 rounded bg-gray-700 border-gray-600 focus:ring-blue-500">
                        <span class="text-sm text-gray-300">Want To Play (WTP)</span>
                    </label>
                    <label class="flex items-center space-x-2 cursor-pointer">
                        <input type="checkbox" id="filter-wishlist" value="1" class="form-checkbox text-blue-500 rounded bg-gray-700 border-gray-600 focus:ring-blue-500">
                        <span class="text-sm text-gray-300">Wishlist</span>
                    </label>
                </div>
                <p class="text-xs text-blue-300 mt-4">Selected filters are used to query the BGG API. Only items matching **any** checked status will be returned.</p>
            </div>
        </header>

        <!-- Loading Indicator -->
        <div id="loading" class="hidden flex-col items-center justify-center py-16 bg-gray-800 rounded-xl shadow-2xl mt-4">
            <div class="spinner w-12 h-12 border-4 border-gray-600 border-t-blue-500 rounded-full mb-4"></div>
            <p id="loadingMessage" class="text-lg text-blue-300 font-medium">Loading collection...</p>
        </div>

        <!-- Message Area (Updated to handle success and error) -->
        <div id="messageBox" class="hidden bg-red-800 border-l-4 border-red-500 text-red-100 px-4 py-3 rounded-lg my-6 shadow-xl" role="alert">
            <div class="flex items-center">
                <svg class="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                <strong id="messageType" class="font-bold">Error:</strong>
                <span id="messageContent" class="block sm:inline ml-2"></span>
            </div>
        </div>

        <!-- Stats Grid (Core Metrics) -->
        <div id="statsGrid" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 md:gap-6 mt-6">
            <!-- Stat cards will be injected here by JavaScript -->
        </div>

        <!-- Detailed Statistics Buckets (NEW SECTION) -->
        <h2 id="detailedStatsHeader" class="text-3xl font-extrabold text-white mt-10 mb-4 border-b border-gray-700 pb-2 hidden">Detailed Distribution Statistics</h2>
        <div id="detailedStatsContainer" class="mt-4 grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-6">
            <!-- Detailed stat charts/lists will be injected here by JavaScript -->
        </div>
        
        <!-- Game List (Optional detailed view) -->
        <div id="detailedList" class="hidden mt-10">
            <h2 class="text-2xl font-bold text-white mb-4 border-b border-gray-700 pb-2">Most Rated Items in this Selection</h2>
            <ul id="topPlayedList" class="space-y-3">
                <!-- Top played games will be listed here -->
            </div>
        </div>
        
        <!-- Detailed Troubleshooting Log -->
        <div class="mt-10 p-6 bg-gray-800 rounded-xl shadow-2xl">
            <h2 class="text-xl font-bold text-gray-300 mb-3 border-b border-gray-700 pb-2">Troubleshooting & API Log</h2>
            <div id="debugLogContainer" class="bg-gray-900 p-3 rounded-lg border border-gray-700">
                <p class="text-gray-500">Log will appear here after clicking "Fetch Stats".</p>
            </div>
        </div>

    </div>

    <script>
        // --- DOM Elements ---
        const usernameInput = document.getElementById('usernameInput');
        const fetchButton = document.getElementById('fetchButton');
        const loading = document.getElementById('loading');
        const loadingMessage = document.getElementById('loadingMessage');
        const messageBox = document.getElementById('messageBox');
        const messageContent = document.getElementById('messageContent');
        const messageType = document.getElementById('messageType');
        const statsGrid = document.getElementById('statsGrid');
        const detailedList = document.getElementById('detailedList');
        const topPlayedList = document.getElementById('topPlayedList');
        const debugLogContainer = document.getElementById('debugLogContainer');
        const detailedStatsContainer = document.getElementById('detailedStatsContainer');
        const detailedStatsHeader = document.getElementById('detailedStatsHeader');

        // --- BGG API Config ---
        const BGG_COLLECTION_URL = 'https://boardgamegeek.com/xmlapi2/collection';
        const BGG_THING_URL = 'https://boardgamegeek.com/xmlapi2/thing';
        
        // CRITICAL FIX: CORS Proxy to allow browser fetching
        const CORS_PROXY = 'https://corsproxy.io/?'; 

        const THING_BATCH_SIZE = 100; 
        const POLL_INTERVAL = 3000; 
        const MAX_POLL_ATTEMPTS = 15; 

        // --- Utility Function: UI Logger ---
        /**
         * Logs messages to the console AND the dedicated UI log area for mobile troubleshooting.
         * @param {string} message The message content.
         * @param {('info'|'success'|'error'|'warning')} type The type of log message for styling.
         */
        function logToUI(message, type = 'info') {
            const now = new Date().toLocaleTimeString();
            const logItem = document.createElement('div');
            logItem.className = `log-item log-${type}`;
            logItem.innerHTML = `[${now}] <span class="uppercase font-bold">${type}</span>: ${message}`;
            
            // Clear the initial message if this is the first real log
            if (debugLogContainer.children.length === 1 && debugLogContainer.children[0].className.includes('text-gray-500')) {
                 debugLogContainer.innerHTML = '';
            }
            
            debugLogContainer.appendChild(logItem);
            debugLogContainer.scrollTop = debugLogContainer.scrollHeight; // Scroll to bottom
            
            // Also log to console for good measure
            if (type === 'error') {
                console.error(`[UI Log] ${message}`);
            } else if (type === 'warning') {
                console.warn(`[UI Log] ${message}`);
            } else {
                console.log(`[UI Log] ${message}`);
            }
        }

        // --- Event Listener ---
        fetchButton.addEventListener('click', handleFetchStats);
        usernameInput.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                handleFetchStats();
            }
        });

        // Get all filter checkboxes
        const filterCheckboxes = document.querySelectorAll('#filterContainer input[type="checkbox"]');
        
        /**
         * Builds the BGG API query parameters based on checked filters.
         * @returns {string} The URL parameter string (e.g., '&wishlist=1&wanttoplay=1').
         */
        function getFilterParams() {
            let params = '';
            let activeFilters = [];

            filterCheckboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    // Filter IDs map directly to BGG API parameters (own, wishlist, wanttoplay, etc.)
                    const filterName = checkbox.id.replace('filter-', '');
                    params += `&${filterName}=1`;
                    activeFilters.push(filterName.toUpperCase());
                }
            });
            
            if (activeFilters.length === 0) {
                 showMessage('Please select at least one Collection Filter (e.g., Owned, Wishlist, Want To Play).', 'warning');
                 return null;
            }
            
            logToUI(`Active Filters: ${activeFilters.join(', ')}`, 'info');
            return params;
        }
        
        /**
         * Main function to orchestrate the fetching and processing
         */
        async function handleFetchStats() {
            const username = usernameInput.value.trim();
            if (!username) {
                showMessage('Please enter a BGG username.');
                return;
            }
            
            const filterParams = getFilterParams();
            if (!filterParams) {
                return; // Stop if no filters are selected
            }

            // Reset UI and Log
            showLoading(true, 'Initiating fetch process...');
            showMessage(false); // Clear previous messages
            statsGrid.innerHTML = '';
            detailedList.classList.add('hidden');
            detailedStatsContainer.classList.add('hidden');
            detailedStatsHeader.classList.add('hidden');
            debugLogContainer.innerHTML = ''; // Clear log on new request

            try {
                logToUI(`Starting collection fetch for user: ${username} with filters: ${filterParams}`, 'info');

                // 1. Get the source XML (either local file or BGG API)
                const collectionXmlDoc = await getCollectionXml(username, filterParams);
                if (!collectionXmlDoc) {
                    logToUI('Collection XML fetch failed, stopping process.', 'error');
                    return; 
                }

                // IMPORTANT: collectionItems now ONLY contains items matching the filters
                const collectionItems = Array.from(collectionXmlDoc.querySelectorAll('item'));
                const totalItems = collectionItems.length;

                if (totalItems === 0) {
                    showMessage(`BGG API reports 0 items for user '${username}' matching your selected filters. Try different filters or check the username.`);
                    showLoading(false);
                    return;
                }
                
                logToUI(`Filtered Collection Size: Found ${totalItems} items matching selected statuses.`, 'success');

                showLoading(true, `Found ${totalItems} items. Fetching detailed data...`);

                // 2. Extract Game IDs (for mechanics, complexity, etc.)
                const gameIds = collectionItems
                    .filter(item => {
                        const subtype = item.getAttribute('subtype');
                        // Filter for only valid boardgame types for 'thing' API lookup
                        return subtype === 'boardgame' || subtype === 'boardgameexpansion';
                    })
                    .map(item => item.getAttribute('objectid'));
                
                logToUI(`Extracted ${gameIds.length} game/expansion IDs for detailed 'thing' API query.`, 'info');


                // 3. Fetch 'thing' data (for mechanics, complexity) in batches
                const thingItems = await fetchThingsInBatches(gameIds);
                
                showLoading(true, 'Calculating statistics...');

                // 4. Process all data and render stats
                processAndRenderStats(collectionItems, thingItems);
                
                logToUI('Statistics calculation and rendering complete.', 'success');


            } catch (err) {
                console.error('Error in handleFetchStats:', err);
                logToUI(`An unexpected error occurred: ${err.message}`, 'error');
                showMessage(`An unexpected error occurred: ${err.message}`);
            } finally {
                showLoading(false);
            }
        }

        /**
         * Fetches collection from BGG via CORS proxy, now including filter parameters.
         */
        async function getCollectionXml(username, filterParams, attempt = 0) {
            // Build the BGG API target URL
            // We MUST request stats=1 here to get the rank/rating data in the collection call
            const bggTargetUrl = `${BGG_COLLECTION_URL}?username=${username}&stats=1${filterParams}`;
            
            // URL encoding is necessary for the proxy to work reliably
            const url = `${CORS_PROXY}${encodeURIComponent(bggTargetUrl)}`;
            
            logToUI(`Collection URL (Target): ${bggTargetUrl}`, 'info');
            logToUI(`Proxy URL (Fetch): ${url}`, 'info');

            try {
                const response = await fetch(url);
                logToUI(`API Response Status: ${response.status} (${response.statusText})`, response.status >= 400 ? 'error' : 'info');

                if (response.status === 202) {
                    if (attempt >= MAX_POLL_ATTEMPTS) { 
                        throw new Error("BGG API collection request timed out after too many retries (max 15 attempts).");
                    }
                    
                    showLoading(true, `BGG is preparing the filtered collection (v2 API). Retrying in ${POLL_INTERVAL / 1000}s (Attempt ${attempt + 1}/${MAX_POLL_ATTEMPTS})...`);
                    logToUI(`Status 202 received. Retrying in ${POLL_INTERVAL}ms. (Attempt ${attempt + 1}/${MAX_POLL_ATTEMPTS})`, 'warning');
                    await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));
                    
                    return getCollectionXml(username, filterParams, attempt + 1); 
                }

                if (!response.ok) {
                    throw new Error(`API returned status ${response.status}: ${response.statusText}`);
                }

                const xmlText = await response.text();
                logToUI(`Successfully received XML text (length: ${xmlText.length.toLocaleString()} bytes).`, 'success');

                const xmlDoc = parseXml(xmlText);
                
                const allItems = xmlDoc.querySelectorAll('item'); 
                const rawItemCount = allItems.length;

                // --- PROOF POINT: Display success message on the UI ---
                showMessage(`Successfully connected and received collection XML from BGG. Found ${rawItemCount} items matching your filter.`, 'success');
                // ------------------------------------------------------
                
                logToUI(`XML parsed. Found ${rawItemCount} 'item' elements.`, 'success');

                const errorElement = xmlDoc.querySelector('errors > error');
                if (errorElement) {
                    const errorMessage = `BGG API Error within XML: ${errorElement.textContent}`;
                    logToUI(errorMessage, 'error');
                    throw new Error(errorMessage);
                }

                return xmlDoc;

            } catch (err) {
                logToUI(`Connection/Request Failed: ${err.message}`, 'error');
                showMessage(err.message);
                showLoading(false);
                return null;
            }
        }

        /**
         * Fetches 'thing' data for all game IDs, in batches via CORS proxy.
         */
        async function fetchThingsInBatches(gameIds) {
            const allThingItems = [];
            const numBatches = Math.ceil(gameIds.length / THING_BATCH_SIZE);
            
            logToUI(`Beginning 'thing' API fetch in ${numBatches} batches.`, 'info');
            
            for (let i = 0; i < numBatches; i++) {
                const batchIds = gameIds.slice(i * THING_BATCH_SIZE, (i + 1) * THING_BATCH_SIZE);
                
                showLoading(true, `Fetching game details (batch ${i + 1} of ${numBatches}, ${batchIds.length} IDs) via proxy...`);
                
                try {
                    // We only need stats=1 for complexity (averageweight)
                    const bggTargetUrl = `${BGG_THING_URL}?id=${batchIds.join(',')}&stats=1`; 
                    const url = `${CORS_PROXY}${encodeURIComponent(bggTargetUrl)}`;
                    
                    logToUI(`Batch ${i + 1}/${numBatches} (IDs: ${batchIds.length}): fetching...`, 'info');
                    
                    const response = await fetch(url);
                    logToUI(`Batch ${i + 1} Status: ${response.status}.`, response.status >= 400 ? 'warning' : 'info');

                    if (!response.ok) {
                        console.warn(`Batch ${i+1} fetch failed: ${response.status}. Skipping batch.`);
                        logToUI(`Batch ${i+1} fetch failed (Status ${response.status}). Skipping.`, 'warning');
                        continue;
                    }

                    const xmlText = await response.text();
                    const xmlDoc = parseXml(xmlText);
                    // Filter down to only boardgames/expansions for accurate stats population
                    const items = xmlDoc.querySelectorAll('item[type="boardgame"], item[type="boardgameexpansion"]');
                    allThingItems.push(...items);
                    
                    logToUI(`Batch ${i + 1} succeeded. Retrieved ${items.length} game details.`, 'success');

                    // Throttle requests slightly
                    await new Promise(resolve => setTimeout(resolve, 500)); 

                } catch (err) {
                    console.warn(`Error fetching batch ${i+1}: ${err.message}. Skipping batch.`);
                    logToUI(`Error during Batch ${i+1} fetch: ${err.message}. Skipping.`, 'error');
                }
            }
            
            logToUI(`Finished 'thing' API fetch. Successfully collected details for ${allThingItems.length} items.`, 'success');
            return allThingItems;
        }

        /**
         * Main processing function. Calculates all stats and renders them.
         */
        function processAndRenderStats(collectionItems, thingItems) {
            // NOTE: collectionItems is the FILTERED list.
            
            const stats = {
                totalItems: 0, 
                ratedItems: 0, // items rated by user
                sumUserRatings: 0,
                bggRatedGames: 0, // games with BGG ratings
                sumBggRatings: 0,
                weightedGames: 0,
                sumWeight: 0,
                minYear: Infinity,
                maxYear: -Infinity,
                topRatedItems: [], // Used for the list display
            };

            const mechanicCounts = new Map();
            const categoryCounts = new Map();
            const designerCounts = new Map();
            const thingMap = new Map();
            thingItems.forEach(item => {
                thingMap.set(item.getAttribute('id'), item);
            });
            
            // --- DETAILED STAT MAPS ---
            const startingCharCounts = new Map();
            const yearPublishedCounts = new Map();
            const playerCountCounts = new Map();
            const playingTimeCounts = new Map();
            const averageRatingCounts = new Map();
            const bayesAverageCounts = new Map();
            const stdDevCounts = new Map();
            const rankGroupCounts = new Map();
            const userRatedCounts = new Map();
            const lastModifiedCounts = new Map();
            // --------------------------

            logToUI(`Beginning statistical calculation on ${collectionItems.length} filtered collection items.`, 'info');


            // --- Loop 1: Process Collection Items (User-specific data + Last Modified) ---
            for (const item of collectionItems) {
                stats.totalItems++;
                const gameName = item.querySelector('name')?.textContent || 'Unknown Item';
                const subtype = item.getAttribute('subtype'); 
                
                // User Rating
                const userRatingStr = item.querySelector('stats > rating')?.getAttribute('value');
                let userRating = 0;
                if (userRatingStr && userRatingStr !== 'N/A') {
                    userRating = parseFloat(userRatingStr);
                    if (userRating > 0) {
                        stats.ratedItems++;
                        stats.sumUserRatings += userRating;
                    }
                }
                
                stats.topRatedItems.push({ name: gameName, userRating: userRating, subtype: subtype });


                // 10. Count per lastmodified (from collection XML)
                const lastModifiedStr = item.querySelector('status')?.getAttribute('lastmodified');
                if (lastModifiedStr) {
                    incrementMap(lastModifiedCounts, groupLastModified(lastModifiedStr));
                }

                // --- Process STATS Data (from collection item) ---
                
                // 1. Count per starting letter or character
                const char = gameName.trim().toUpperCase().charAt(0);
                const firstChar = char.match(/[A-Z]/) ? char : '# (Non-Alpha)';
                incrementMap(startingCharCounts, firstChar);
                
                // 2. Count per year published
                const yearStr = item.querySelector('yearpublished')?.textContent; // Use textContent for <yearpublished>
                if (yearStr && yearStr !== '0' && yearStr !== '9999') {
                    const year = parseInt(yearStr);
                    incrementMap(yearPublishedCounts, yearStr);
                    
                    // Update min/max year for core stats
                    if (year < stats.minYear) stats.minYear = year;
                    if (year > stats.maxYear) stats.maxYear = year;
                }
                
                // Get the <stats> tag from the collection item
                const statsTag = item.querySelector('stats');
                
                if (statsTag) {
                    // 4. Playing Time
                    const playingTime = parseInt(statsTag.getAttribute('playingtime') || '0');
                    incrementMap(playingTimeCounts, groupPlayingTime(playingTime));
                    
                    // 3. Count of games playable at each player count (Min/Max Players)
                    const minPlayers = parseInt(statsTag.getAttribute('minplayers') || '0');
                    const maxPlayers = parseInt(statsTag.getAttribute('maxplayers') || '0');
                    const maxP = Math.min(maxPlayers, 10); 
                    for (let p = minPlayers; p > 0 && p <= maxP; p++) {
                        incrementMap(playerCountCounts, p.toString());
                    }
                    if (maxPlayers > 10) {
                        incrementMap(playerCountCounts, '10+');
                    }
                    
                    // Get ratings/stats container (this is <rating> *inside* <stats>)
                    const ratings = statsTag.querySelector('rating'); // This is the <rating> tag *inside* <stats>
                    
                    if (ratings) {
                        // BGG Rating
                        const bggRatingStr = ratings.querySelector('average')?.getAttribute('value');
                        if (bggRatingStr) {
                            const bggRating = parseFloat(bggRatingStr);
                            if (bggRating > 0) {
                                stats.bggRatedGames++;
                                stats.sumBggRatings += bggRating;
                            }
                            
                            // 5. Count of games at each average rating (rounded down)
                            incrementMap(averageRatingCounts, Math.floor(bggRating).toString());
                        }
                        
                        // 6. Count users rated (make local groupings)
                        const usersRated = parseInt(ratings.querySelector('usersrated')?.getAttribute('value') || '0');
                        incrementMap(userRatedCounts, groupUsersRated(usersRated));

                        // 7. Count per bayesaverage (rounded down)
                        const bayesAvgStr = ratings.querySelector('bayesaverage')?.getAttribute('value');
                        if (bayesAvgStr) {
                            const bayesAvg = parseFloat(bayesAvgStr);
                            if (bayesAvg > 0) {
                                incrementMap(bayesAverageCounts, Math.floor(bayesAvg).toString());
                            }
                        }

                        // 8. Count per stddev (logical groupings)
                        const stdDev = parseFloat(ratings.querySelector('stddev')?.getAttribute('value') || '0');
                        incrementMap(stdDevCounts, groupStdDev(stdDev));

                        // 9. Count per boardgamerank groupings
                        const rankElement = ratings.querySelector('rank[type="subtype"][id="1"]'); // Target primary boardgame rank
                        let rank = 0;
                        if (rankElement) {
                            const rankValue = rankElement.getAttribute('value');
                            if (rankValue && rankValue !== 'Not Ranked') {
                                rank = parseInt(rankValue);
                            }
                        }
                        incrementMap(rankGroupCounts, groupRank(rank));
                    }
                }

                // --- Process 'Thing' Data (Complexity & Links) ---
                const gameId = item.getAttribute('objectid');
                const thing = thingMap.get(gameId);

                if (thing) {
                    // This section is now *only* for data NOT in the collection call.
                    // 1. Complexity (Average Weight)
                    // 2. Links (Mechanics, Categories, Designers)
                    
                    // Get ratings/stats container
                    const thingRatings = thing.querySelector('statistics > ratings');
                    if (thingRatings) {
                         // Core Weight (Complexity)
                        const weightStr = thingRatings.querySelector('averageweight')?.getAttribute('value');
                        if (weightStr) {
                            const weight = parseFloat(weightStr);
                            if (weight > 0) {
                                stats.weightedGames++;
                                stats.sumWeight += weight;
                            }
                        }
                    }

                    // Links (Mechanics, Categories, Designers)
                    const links = thing.querySelectorAll('link');
                    links.forEach(link => {
                        const type = link.getAttribute('type');
                        const value = link.getAttribute('value');
                        switch (type) {
                            case 'boardgamemechanic':
                                incrementMap(mechanicCounts, value);
                                break;
                            case 'boardgamecategory':
                                incrementMap(categoryCounts, value);
                                break;
                            case 'boardgamedesigner':
                                incrementMap(designerCounts, value);
                                break;
                        }
                    });
                }
            }
            
            // --- Calculate Final Core Stats ---
            const avgUserRating = stats.ratedItems > 0 ? (stats.sumUserRatings / stats.ratedItems) : 0;
            const avgBggRating = stats.bggRatedGames > 0 ? (stats.sumBggRatings / stats.bggRatedGames) : 0;
            const avgWeight = stats.weightedGames > 0 ? (stats.sumWeight / stats.weightedGames) : 0;
            
            // Get Top 1s
            const topMechanic = getTopFromMap(mechanicCounts, 1)[0] || 'N/A';
            const topCategory = getTopFromMap(categoryCounts, 1)[0] || 'N/A';
            const topDesigner = getTopFromMap(designerCounts, 1)[0] || 'N/A';
            
            // Find most rated item (by user)
            const sortedRatedItems = stats.topRatedItems
                .filter(g => g.userRating > 0) // Only show items the user has rated
                .sort((a, b) => b.userRating - a.userRating);


            // --- Render Stat Cards ---
            statsGrid.innerHTML = ''; // Clear again just in case
            
            // Row 1: Core Stats
            renderStatCard('Total Items in Selection', stats.totalItems.toLocaleString(), 'Count matching BGG filters (e.g., Wishlist)');
            renderStatCard('Avg. BGG Rating', avgBggRating.toFixed(2), `Community Avg. of ${stats.bggRatedGames} filtered titles`);
            renderStatCard('Avg. User Rating', avgUserRating.toFixed(2), `From your ${stats.ratedItems} ratings in this selection`);
            renderStatCard('Avg. Complexity', avgWeight.toFixed(2) + ' / 5', `Based on ${stats.weightedGames} filtered titles`);

            // Row 2: Collection Breadth
            renderStatCard('Min Year Published', stats.minYear === Infinity ? 'N/A' : stats.minYear, 'Oldest game in this selection');
            renderStatCard('Max Year Published', stats.maxYear === -Infinity ? 'N/A' : stats.maxYear, 'Newest game in this selection');
            renderStatCard('Total Designers Tracked', designerCounts.size.toLocaleString(), 'Unique designers in filtered items');
            renderStatCard('Total Categories Tracked', categoryCounts.size.toLocaleString(), 'Unique categories in filtered items');

            // Row 3: Top Links
            renderStatCard('Top Mechanic', topMechanic, `Found in ${mechanicCounts.get(topMechanic) || 0} games`);
            renderStatCard('Top Category', topCategory, `Found in ${categoryCounts.get(topCategory) || 0} games`);
            renderStatCard('Top Designer', topDesigner, `Found in ${designerCounts.get(topDesigner) || 0} games`);
            renderStatCard('Item Types Found', thingItems.length === 0 ? '0' : thingItems.length.toLocaleString(), 'Number of games/expansions with full detail');
            
            // Render detailed list
            renderTopRatedList(sortedRatedItems.slice(0, 5));

            // --- Render Detailed Stat Buckets ---
            renderDetailedStats({
                startingChar: startingCharCounts,
                yearPublished: yearPublishedCounts,
                playerCount: playerCountCounts,
                playingTime: playingTimeCounts,
                averageRating: averageRatingCounts,
                bayesAverage: bayesAverageCounts,
                stdDev: stdDevCounts,
                rankGroup: rankGroupCounts,
                userRated: userRatedCounts,
                lastModified: lastModifiedCounts,
                mechanic: mechanicCounts, // ADDED MECHANIC COUNT
            });
        }

        // --- Helper Functions ---

        /**
         * Renders a single stat card and appends it to the grid.
         */
        function renderStatCard(title, value, subtitle = '') {
            const card = document.createElement('div');
            card.className = 'bg-gray-800 p-5 rounded-xl shadow-2xl transition duration-300 hover:shadow-blue-500/50 hover:scale-[1.02]';
            
            let valueClass = 'text-3xl md:text-4xl font-extrabold text-white';
            if (typeof value === 'string' && value.length > 15) {
                valueClass = 'text-2xl font-extrabold text-white'; // Shrink text if it's a long string
            }

            card.innerHTML = `
                <div class="text-sm font-medium text-blue-400 uppercase tracking-wider">${title}</div>
                <div class="${valueClass} mt-2 truncate" title="${value}">${value}</div>
                ${subtitle ? `<div class="text-sm text-gray-400 mt-2 truncate" title="${subtitle}">${subtitle}</div>` : ''}
            `;
            statsGrid.appendChild(card);
        }
        
        /**
         * Renders a detailed list of the top N most highly user-rated games in the selection.
         */
        function renderTopRatedList(topGames) {
            topPlayedList.innerHTML = '';
            
            // Update the list header based on what we're displaying
            const listHeader = document.querySelector('#detailedList h2');
            listHeader.textContent = 'Top 5 User-Rated Items in Selection (Out of your rated items)';

            if (topGames.length === 0) {
                detailedList.classList.add('hidden');
                return;
            }
            detailedList.classList.remove('hidden');

            topGames.forEach((game, index) => {
                const listItem = document.createElement('li');
                listItem.className = 'bg-gray-800 p-4 rounded-lg flex justify-between items-center shadow-lg';
                listItem.innerHTML = `
                    <div class="flex items-center">
                        <span class="text-xl font-bold text-blue-400 mr-3">${index + 1}.</span>
                        <span class="text-white font-medium truncate">${game.name}</span>
                    </div>
                    <span class="text-xs text-gray-400 mr-2 uppercase">${game.subtype || 'Item'}</span>
                    <span class="text-lg font-bold bg-blue-600 text-white rounded-full px-4 py-1">${game.userRating.toFixed(1)} / 10</span>
                `;
                topPlayedList.appendChild(listItem);
            });
        }

        /**
         * Toggles the loading indicator.
         */
        function showLoading(isLoading, message = '') {
            if (isLoading) {
                loading.classList.remove('hidden');
                loading.classList.add('flex');
                loadingMessage.textContent = message;
                fetchButton.disabled = true;
                fetchButton.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                loading.classList.add('hidden');
                loading.classList.remove('flex');
                fetchButton.disabled = false;
                fetchButton.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        /**
         * Shows or hides a message box (error or success).
         */
        function showMessage(message, type = 'error') {
            const errorIconPath = "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z";
            const successIconPath = "M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z";
            
            // Clear all previous coloring classes
            messageBox.classList.remove('bg-red-800', 'border-red-500', 'text-red-100', 'bg-green-800', 'border-green-500', 'text-green-100', 'bg-yellow-800', 'border-yellow-500', 'text-yellow-100');
            
            const svgPath = messageBox.querySelector('svg path');

            if (message) {
                messageContent.textContent = message;
                messageBox.classList.remove('hidden');
                
                // Set colors and icon based on type
                if (type === 'success') {
                    messageBox.classList.add('bg-green-800', 'border-green-500', 'text-green-100');
                    messageType.textContent = 'Success:';
                    svgPath.setAttribute('d', successIconPath);
                } else if (type === 'warning') {
                    messageBox.classList.add('bg-yellow-800', 'border-yellow-500', 'text-yellow-100');
                    messageType.textContent = 'Warning:';
                    svgPath.setAttribute('d', errorIconPath); // Reusing error icon path for simplicity
                } 
                else {
                    messageBox.classList.add('bg-red-800', 'border-red-500', 'text-red-100');
                    messageType.textContent = 'Error:';
                    svgPath.setAttribute('d', errorIconPath);
                }
            } else {
                messageBox.classList.add('hidden');
            }
        }

        /**
         * Parses XML text into a DOM document.
         */
        function parseXml(xmlText) {
            const parser = new DOMParser();
            return parser.parseFromString(xmlText, 'text/xml');
        }

        /**
         * Helper to increment a value in a Map.
         */
        function incrementMap(map, key) {
            map.set(key, (map.get(key) || 0) + 1);
        }

        /**
         * Helper to get the top N keys from a count map.
         */
        function getTopFromMap(map, n = 1) {
            return Array.from(map.entries())
                .sort((a, b) => b[1] - a[1]) // Sort descending by count
                .slice(0, n)
                .map(entry => entry[0]); // Get just the key (name)
        }

        // --- Grouping Functions ---

        /**
         * Groups playing time into logical buckets.
         */
        function groupPlayingTime(time) {
            if (time <= 30) return '30 min or less';
            if (time <= 60) return '31 - 60 min';
            if (time <= 90) return '61 - 90 min';
            if (time <= 120) return '91 - 120 min (2h)';
            if (time <= 180) return '121 - 180 min (3h)';
            return '180 min (3h) +';
        }

        /**
         * Groups users rated into logical buckets.
         */
        function groupUsersRated(count) {
            if (count < 100) return '< 100 Ratings';
            if (count < 500) return '100 - 499 Ratings';
            if (count < 1000) return '500 - 999 Ratings';
            if (count < 5000) return '1K - 4.9K Ratings';
            if (count < 10000) return '5K - 9.9K Ratings';
            if (count < 25000) return '10K - 24.9K Ratings';
            return '25K + Ratings';
        }

        /**
         * Groups standard deviation (rating variance) into logical buckets.
         */
        function groupStdDev(stddev) {
            if (stddev < 0.5) return '< 0.5 (High Consensus)';
            if (stddev <= 1.0) return '0.5 - 1.0 (Normal)';
            if (stddev <= 1.5) return '1.0 - 1.5 (Moderate Variance)';
            return '1.5 + (High Variance)';
        }

        /**
         * Groups BoardGameGeek rank into logical buckets.
         * Rank 0 is Unranked or not a primary boardgame.
         */
        function groupRank(rank) {
            if (rank === 0) return 'Unranked/N/A';
            if (rank <= 10) return 'Top 10';
            if (rank <= 100) return 'Top 100';
            if (rank <= 500) return 'Top 500';
            if (rank <= 1000) return 'Top 1000';
            if (rank <= 5000) return '1001 - 5000';
            return '5000+';
        }

        /**
         * Groups last modified date into time-based buckets.
         */
        function groupLastModified(dateString) {
            const now = new Date();
            // BGG format is YYYY-MM-DD HH:mm:ss
            const modifiedDate = new Date(dateString.replace(' ', 'T')); 
            const diffTime = Math.abs(now - modifiedDate);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

            if (diffDays <= 30) return 'Last 30 Days';
            if (diffDays <= 90) return '1 - 3 Months Ago';
            if (diffDays <= 182) return '3 - 6 Months Ago'; // ~6 months
            if (diffDays <= 365) return '6 - 12 Months Ago'; // ~1 year
            return 'Over 1 Year Ago';
        }

        /**
         * Renders the detailed statistical buckets.
         */
        function renderDetailedStats(data) {
            const container = document.getElementById('detailedStatsContainer');
            container.innerHTML = '';

            const statConfigs = [
                // 1. name (Starting Letter)
                { title: '1. Count by Starting Letter/Character', map: data.startingChar, sort: (a, b) => a[0].localeCompare(b[0]) },
                // 2. yearpublished
                { title: '2. Count by Year Published', map: data.yearPublished, sort: (a, b) => parseInt(a[0]) - parseInt(b[0]) },
                // 3. minplayers - maxplayers
                { title: '3. Count by Playable Player Count', map: data.playerCount, sort: (a, b) => {
                    // Custom sort to handle the '10+' bucket correctly
                    if (a[0] === '10+') return 1;
                    if (b[0] === '10+') return -1;
                    return parseInt(a[0]) - parseInt(b[0]);
                }, description: 'Number of items playable at this count (up to 10+).', limit: null },
                // 4. playingtime
                { title: '4. Count by Playing Time', map: data.playingTime, sort: (a, b) => b[1] - a[1] },
                // 5. average (BGG Average Rating)
                { title: '5. Count by BGG Average Rating (Rounded Down)', map: data.averageRating, sort: (a, b) => parseInt(a[0]) - parseInt(b[0]) },
                // 6. usersrated
                { title: '6. Count by Users Rated Group', map: data.userRated, sort: (a, b) => b[1] - a[1] },
                // 7. bayesaverage
                { title: '7. Count per Bayesaverage (Rounded Down)', map: data.bayesAverage, sort: (a, b) => parseInt(a[0]) - parseInt(b[0]) },
                // 8. stddev
                { title: '8. Count per Standard Deviation Group', map: data.stdDev, sort: (a, b) => b[1] - a[1] },
                // 9. rank / Board Game Rank
                { title: '9. Count per Board Game Rank Group', map: data.rankGroup, sort: (a, b) => b[1] - a[1] },
                // 10. lastmodified
                { title: '10. Count per Last Modified Group', map: data.lastModified, sort: (a, b) => b[1] - a[1], description: 'When the item status was last modified on BGG.' },
                // 11. Mechanic (New addition to satisfy 11 distinct stats)
                { title: '11. Count by Mechanic', map: data.mechanic, sort: (a, b) => b[1] - a[1], description: 'Top 50 most common mechanics in this selection.', limit: 50 }, 
            ];

            let contentGenerated = false;

            // Only consider configs that actually have data
            const configsWithData = statConfigs.filter(config => Array.from(config.map.entries()).length > 0);

            configsWithData.forEach(config => {
                // Convert map to array and sort
                let sortedData = Array.from(config.map.entries()).sort(config.sort);

                // Apply limit if specified (used for Mechanics)
                if (config.limit) {
                    sortedData = sortedData.slice(0, config.limit);
                }

                const card = document.createElement('div');
                card.className = 'bg-gray-800 p-6 rounded-xl shadow-2xl';

                let contentHTML = sortedData.map(([key, count]) => `
                    <li class="flex justify-between items-center py-1 border-b border-gray-700 last:border-b-0">
                        <span class="text-gray-300 font-medium">${key}</span>
                        <span class="text-blue-400 font-bold">${count.toLocaleString()}</span>
                    </li>
                `).join('');

                card.innerHTML = `
                    <h3 class="text-xl font-bold text-white mb-3 border-b border-gray-700 pb-2">${config.title}</h3>
                    ${config.description ? `<p class="text-sm text-gray-500 mb-3">${config.description}</p>` : ''}
                    <ul class="space-y-1 detailed-stat-list">${contentHTML}</ul>
                `;
                container.appendChild(card);
                contentGenerated = true;
            });

            if (contentGenerated) {
                container.classList.remove('hidden');
                detailedStatsHeader.classList.remove('hidden');
            } else {
                 container.classList.add('hidden');
                 detailedStatsHeader.classList.add('hidden');
            }
        }
    </script>
</body>
</html>

