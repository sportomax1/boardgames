<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>BGG Collection Stats</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .spinner {
            border-top-color: #3b82f6;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        button, input {
            min-height: 44px;
            -webkit-tap-highlight-color: transparent;
        }
        button:active {
            transform: scale(0.98);
        }
        html {
            scroll-behavior: smooth;
        }
        .stat-card {
            touch-action: manipulation;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen">

    <div class="max-w-7xl mx-auto p-4 pb-8">
        
        <!-- Header -->
        <header class="mb-6">
            <h1 class="text-2xl sm:text-3xl font-bold text-white mb-4">BGG Collection Stats</h1>
            <div class="space-y-3">
                <input 
                    type="text" 
                    id="usernameInput" 
                    value="sportomax" 
                    class="w-full bg-gray-800 text-white text-lg border-2 border-gray-700 rounded-xl px-4 py-3 focus:outline-none focus:border-blue-500 focus:ring-0"
                    placeholder="Enter BGG Username"
                >
                <button 
                    id="fetchButton" 
                    class="w-full bg-blue-600 hover:bg-blue-700 active:bg-blue-800 text-white font-semibold py-3.5 px-6 rounded-xl transition-all duration-150 shadow-lg text-lg"
                >
                    Fetch Stats
                </button>
            </div>
        </header>

        <!-- Loading -->
        <div id="loading" class="hidden flex-col items-center justify-center py-12">
            <div class="spinner w-16 h-16 border-4 border-gray-700 rounded-full mb-4"></div>
            <p id="loadingMessage" class="text-base text-gray-400 text-center px-4">Loading collection...</p>
        </div>

        <!-- Error -->
        <div id="error" class="hidden bg-red-900 border-2 border-red-700 text-red-100 px-4 py-3 rounded-xl my-4">
            <strong class="font-bold">Error:</strong>
            <span id="errorMessage" class="block mt-1"></span>
        </div>

        <!-- Stats Grid -->
        <div id="statsGrid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-3">
        </div>

    </div>

    <script>
        const usernameInput = document.getElementById('usernameInput');
        const fetchButton = document.getElementById('fetchButton');
        const loading = document.getElementById('loading');
        const loadingMessage = document.getElementById('loadingMessage');
        const error = document.getElementById('error');
        const errorMessage = document.getElementById('errorMessage');
        const statsGrid = document.getElementById('statsGrid');

        const BGG_COLLECTION_URL = 'https://boardgamegeek.com/xmlapi2/collection';
        const BGG_THING_URL = 'https://boardgamegeek.com/xmlapi2/thing';
        const THING_BATCH_SIZE = 100;
        const POLL_INTERVAL = 4000;

        fetchButton.addEventListener('click', handleFetchStats);
        usernameInput.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                usernameInput.blur(); // Close keyboard on iPhone
                handleFetchStats();
            }
        });

        async function handleFetchStats() {
            const username = usernameInput.value.trim();
            if (!username) {
                showError('Please enter a BGG username.');
                return;
            }

            showLoading(true, 'Fetching collection...');
            showError(false);
            statsGrid.innerHTML = '';

            try {
                const collectionXmlDoc = await getCollectionXml(username);
                if (!collectionXmlDoc) return;

                const collectionItems = Array.from(collectionXmlDoc.querySelectorAll('item'))
                    .filter(item => item.querySelector('status[own="1"]'));
                
                const totalGames = collectionItems.length;

                if (totalGames === 0) {
                    showError(`No owned games found for user '${username}'.`);
                    showLoading(false);
                    return;
                }
                
                showLoading(true, `Found ${totalGames} games. Fetching details...`);

                const gameIds = Array.from(collectionItems).map(item => item.getAttribute('objectid'));
                const thingItems = await fetchThingsInBatches(gameIds);
                
                showLoading(true, 'Processing stats...');
                processAndRenderStats(collectionItems, thingItems);

            } catch (err) {
                console.error('Error:', err);
                showError(`An unexpected error occurred: ${err.message}`);
            } finally {
                showLoading(false);
            }
        }

        async function getCollectionXml(username) {
            if (username.toLowerCase() === 'sportomax') {
                try {
                    console.log('Attempting to fetch local private_all.xml...');
                    const response = await fetch('private_all.xml');
                    if (response.ok) {
                        console.log('Successfully loaded private_all.xml.');
                        const xmlText = await response.text();
                        return parseXml(xmlText);
                    } else {
                        console.warn(`private_all.xml not found. Falling back to BGG API.`);
                    }
                } catch (err) {
                    console.warn(`Error fetching private_all.xml. Falling back to BGG API.`);
                }
            }

            return fetchCollectionFromBGG(username);
        }

        async function fetchCollectionFromBGG(username) {
            const url = `${BGG_COLLECTION_URL}?username=${username}&stats=1&own=1`;
            
            try {
                const response = await fetch(url);

                if (response.status === 202) {
                    showLoading(true, `BGG is preparing collection. Please wait...`);
                    await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));
                    return fetchCollectionFromBGG(username);
                }

                if (!response.ok) {
                    throw new Error(`BGG API returned status ${response.status}`);
                }

                const xmlText = await response.text();
                const xmlDoc = parseXml(xmlText);
                
                const errorElement = xmlDoc.querySelector('error > message');
                if (errorElement) {
                    throw new Error(`BGG API Error: ${errorElement.textContent}`);
                }

                return xmlDoc;

            } catch (err) {
                console.error('Error fetching BGG collection:', err);
                showError(err.message);
                showLoading(false);
                return null;
            }
        }

        async function fetchThingsInBatches(gameIds) {
            const allThingItems = [];
            const numBatches = Math.ceil(gameIds.length / THING_BATCH_SIZE);
            
            for (let i = 0; i < numBatches; i++) {
                const batchIds = gameIds.slice(i * THING_BATCH_SIZE, (i + 1) * THING_BATCH_SIZE);
                showLoading(true, `Fetching details (${i + 1}/${numBatches})...`);
                
                try {
                    const url = `${BGG_THING_URL}?id=${batchIds.join(',')}&stats=1`;
                    const response = await fetch(url);

                    if (!response.ok) {
                        console.warn(`Batch ${i+1} fetch failed: ${response.status}`);
                        continue;
                    }

                    const xmlText = await response.text();
                    const xmlDoc = parseXml(xmlText);
                    const items = xmlDoc.querySelectorAll('item');
                    allThingItems.push(...items);
                } catch (err) {
                    console.warn(`Error fetching batch ${i+1}: ${err.message}`);
                }
            }
            
            console.log(`Fetched details for ${allThingItems.length} games.`);
            return allThingItems;
        }

        function processAndRenderStats(collectionItems, thingItems) {
            const stats = {
                totalGames: 0,
                totalPlays: 0,
                gamesWith0Plays: 0,
                ratedGames: 0,
                sumUserRatings: 0,
                bggRatedGames: 0,
                sumBggRatings: 0,
                weightedGames: 0,
                sumWeight: 0,
                minYear: Infinity,
                maxYear: -Infinity,
                playsList: [],
                mostPlayed: { name: 'N/A', plays: 0 },
            };

            const mechanicCounts = new Map();
            const categoryCounts = new Map();
            const designerCounts = new Map();
            const publisherCounts = new Map();

            const thingMap = new Map();
            thingItems.forEach(item => {
                thingMap.set(item.getAttribute('id'), item);
            });

            for (const item of collectionItems) {
                stats.totalGames++;
                const gameName = item.querySelector('name')?.textContent || 'Unknown Game';
                
                const numPlays = parseInt(item.querySelector('numplays')?.textContent || '0');
                stats.totalPlays += numPlays;
                if (numPlays === 0) {
                    stats.gamesWith0Plays++;
                } else {
                    stats.playsList.push(numPlays);
                }

                if (numPlays > stats.mostPlayed.plays) {
                    stats.mostPlayed = { name: gameName, plays: numPlays };
                }

                const userRatingStr = item.querySelector('stats > rating')?.getAttribute('value');
                if (userRatingStr && userRatingStr !== 'N/A') {
                    const userRating = parseFloat(userRatingStr);
                    if (userRating > 0) {
                        stats.ratedGames++;
                        stats.sumUserRatings += userRating;
                    }
                }

                const gameId = item.getAttribute('objectid');
                const thing = thingMap.get(gameId);

                if (thing) {
                    const bggRatingStr = thing.querySelector('statistics > ratings > average')?.getAttribute('value');
                    if (bggRatingStr) {
                        const bggRating = parseFloat(bggRatingStr);
                        if (bggRating > 0) {
                            stats.bggRatedGames++;
                            stats.sumBggRatings += bggRating;
                        }
                    }

                    const weightStr = thing.querySelector('statistics > ratings > averageweight')?.getAttribute('value');
                    if (weightStr) {
                        const weight = parseFloat(weightStr);
                        if (weight > 0) {
                            stats.weightedGames++;
                            stats.sumWeight += weight;
                        }
                    }

                    const yearStr = thing.querySelector('yearpublished')?.getAttribute('value');
                    if (yearStr) {
                        const year = parseInt(yearStr);
                        if (year !== 0) {
                            if (year < stats.minYear) stats.minYear = year;
                            if (year > stats.maxYear) stats.maxYear = year;
                        }
                    }

                    const links = thing.querySelectorAll('link');
                    links.forEach(link => {
                        const type = link.getAttribute('type');
                        const value = link.getAttribute('value');
                        switch (type) {
                            case 'boardgamemechanic':
                                incrementMap(mechanicCounts, value);
                                break;
                            case 'boardgamecategory':
                                incrementMap(categoryCounts, value);
                                break;
                            case 'boardgamedesigner':
                                incrementMap(designerCounts, value);
                                break;
                            case 'boardgamepublisher':
                                incrementMap(publisherCounts, value);
                                break;
                        }
                    });
                }
            }
            
            const avgPlays = stats.totalGames > 0 ? (stats.totalPlays / stats.totalGames) : 0;
            const avgUserRating = stats.ratedGames > 0 ? (stats.sumUserRatings / stats.ratedGames) : 0;
            const avgBggRating = stats.bggRatedGames > 0 ? (stats.sumBggRatings / stats.bggRatedGames) : 0;
            const avgWeight = stats.weightedGames > 0 ? (stats.sumWeight / stats.weightedGames) : 0;
            const percentUnplayed = stats.totalGames > 0 ? (stats.gamesWith0Plays / stats.totalGames) * 100 : 0;

            const sortedPlays = stats.playsList.sort((a, b) => b - a);
            let hIndex = 0;
            for (let i = 0; i < sortedPlays.length; i++) {
                if (sortedPlays[i] >= i + 1) {
                    hIndex = i + 1;
                } else {
                    break;
                }
            }
            
            const topMechanic = getTopFromMap(mechanicCounts, 1)[0] || 'N/A';
            const topCategory = getTopFromMap(categoryCounts, 1)[0] || 'N/A';
            const topDesigner = getTopFromMap(designerCounts, 1)[0] || 'N/A';
            const topPublisher = getTopFromMap(publisherCounts, 1)[0] || 'N/A';

            statsGrid.innerHTML = '';
            
            renderStatCard('Total Games', stats.totalGames.toLocaleString(), 'Owned in collection');
            renderStatCard('Total Plays', stats.totalPlays.toLocaleString(), `Avg ${avgPlays.toFixed(1)} per game`);
            renderStatCard('H-Index', hIndex, 'Based on plays');
            renderStatCard('Most Played', stats.mostPlayed.plays, stats.mostPlayed.name);

            renderStatCard('Unplayed', stats.gamesWith0Plays.toLocaleString(), `${percentUnplayed.toFixed(1)}% of collection`);
            renderStatCard('Played', (stats.totalGames - stats.gamesWith0Plays).toLocaleString(), `${(100-percentUnplayed).toFixed(1)}% of collection`);
            renderStatCard('Oldest Game', stats.minYear === Infinity ? 'N/A' : stats.minYear, 'Year Published');
            renderStatCard('Newest Game', stats.maxYear === -Infinity ? 'N/A' : stats.maxYear, 'Year Published');

            renderStatCard('Avg Rating', avgUserRating.toFixed(2), `${stats.ratedGames} games rated`);
            renderStatCard('Avg BGG Rating', avgBggRating.toFixed(2), `${stats.bggRatedGames} games`);
            renderStatCard('Avg Complexity', avgWeight.toFixed(2), 'Out of 5.0');
            renderStatCard('Weighted Games', stats.weightedGames, `${((stats.weightedGames/stats.totalGames)*100).toFixed(0)}% of collection`);
            
            renderStatCard('Top Mechanic', topMechanic, `${mechanicCounts.get(topMechanic) || 0} games`);
            renderStatCard('Top Category', topCategory, `${categoryCounts.get(topCategory) || 0} games`);
            renderStatCard('Top Designer', topDesigner, `${designerCounts.get(topDesigner) || 0} games`);
            renderStatCard('Top Publisher', topPublisher, `${publisherCounts.get(topPublisher) || 0} games`);
        }

        function renderStatCard(title, value, subtitle = '') {
            const card = document.createElement('div');
            card.className = 'stat-card bg-gray-800 p-4 rounded-xl shadow-lg border border-gray-700';
            
            let valueClass = 'text-3xl sm:text-4xl font-bold text-white mt-2';
            if (typeof value === 'string' && value.length > 15) {
                valueClass = 'text-xl sm:text-2xl font-bold text-white mt-2';
            }

            card.innerHTML = `
                <div class="text-xs sm:text-sm font-semibold text-blue-400 uppercase tracking-wide">${title}</div>
                <div class="${valueClass} break-words" title="${value}">${value}</div>
                ${subtitle ? `<div class="text-sm text-gray-400 mt-2 break-words" title="${subtitle}">${subtitle}</div>` : ''}
            `;
            statsGrid.appendChild(card);
        }

        function showLoading(isLoading, message = '') {
            if (isLoading) {
                loading.classList.remove('hidden');
                loading.classList.add('flex');
                loadingMessage.textContent = message;
                fetchButton.disabled = true;
                fetchButton.classList.add('opacity-50');
            } else {
                loading.classList.add('hidden');
                loading.classList.remove('flex');
                fetchButton.disabled = false;
                fetchButton.classList.remove('opacity-50');
            }
        }

        function showError(message) {
            if (message) {
                errorMessage.textContent = message;
                error.classList.remove('hidden');
            } else {
                error.classList.add('hidden');
            }
        }

        function parseXml(xmlText) {
            const parser = new DOMParser();
            return parser.parseFromString(xmlText, 'text/xml');
        }

        function incrementMap(map, key) {
            map.set(key, (map.get(key) || 0) + 1);
        }

        function getTopFromMap(map, n = 1) {
            return Array.from(map.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, n)
                .map(entry => entry[0]);
        }

    </script>
</body>
</html>