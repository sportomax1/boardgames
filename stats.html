<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BGG Collection Stats Dashboard</title>
    <!-- Load Tailwind CSS from CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a cleaner dashboard look */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Simple spinner animation */
        .spinner {
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        
        <!-- Header and Controls -->
        <header class="mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-white mb-4">BGG Collection Stats Dashboard</h1>
            <div class="flex flex-col sm:flex-row gap-4">
                <input 
                    type="text" 
                    id="usernameInput" 
                    value="sportomax" 
                    class="flex-grow bg-gray-800 text-white border border-gray-700 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                    placeholder="Enter BGG Username"
                >
                <button 
                    id="fetchButton" 
                    class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition duration-200 shadow-lg"
                >
                    Fetch Stats
                </button>
            </div>
        </header>

        <!-- Loading Indicator -->
        <div id="loading" class="hidden flex-col items-center justify-center py-16">
            <div class="spinner w-12 h-12 border-4 border-gray-700 rounded-full mb-4"></div>
            <p id="loadingMessage" class="text-lg text-gray-400">Loading collection...</p>
        </div>

        <!-- Error Message Area -->
        <div id="error" class="hidden bg-red-900 border border-red-700 text-red-100 px-4 py-3 rounded-lg my-4" role="alert">
            <strong class="font-bold">Error:</strong>
            <span id="errorMessage" class="block sm:inline"></span>
        </div>

        <!-- Stats Grid -->
        <div id="statsGrid" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 md:gap-6">
            <!-- Stat cards will be injected here by JavaScript -->
        </div>

    </div>

    <script>
        // --- DOM Elements ---
        const usernameInput = document.getElementById('usernameInput');
        const fetchButton = document.getElementById('fetchButton');
        const loading = document.getElementById('loading');
        const loadingMessage = document.getElementById('loadingMessage');
        const error = document.getElementById('error');
        const errorMessage = document.getElementById('errorMessage');
        const statsGrid = document.getElementById('statsGrid');

        // --- BGG API Config ---
        const BGG_COLLECTION_URL = 'https://boardgamegeek.com/xmlapi2/collection';
        const BGG_THING_URL = 'https://boardgamegeek.com/xmlapi2/thing';
        const THING_BATCH_SIZE = 100; // Batch size for 'thing' API calls
        const POLL_INTERVAL = 4000; // 4 seconds polling for 202 response

        // --- Event Listener ---
        fetchButton.addEventListener('click', handleFetchStats);
        // Allow pressing Enter to fetch
        usernameInput.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                handleFetchStats();
            }
        });

        /**
         * Main function to orchestrate the fetching and processing
         */
        async function handleFetchStats() {
            const username = usernameInput.value.trim();
            if (!username) {
                showError('Please enter a BGG username.');
                return;
            }

            // Reset UI
            showLoading(true, 'Fetching collection...');
            showError(false);
            statsGrid.innerHTML = '';

            try {
                // 1. Get the source XML (either local file or BGG API)
                const collectionXmlDoc = await getCollectionXml(username);
                if (!collectionXmlDoc) return; // Error already shown in getCollectionXml

                const collectionItems = collectionXmlDoc.querySelectorAll('item[own="1"]');
                const totalGames = collectionItems.length;

                if (totalGames === 0) {
                    showError(`No games found in the 'owned' collection for user '${username}'.`);
                    showLoading(false);
                    return;
                }
                
                showLoading(true, `Found ${totalGames} games. Fetching details...`);

                // 2. Extract Game IDs
                const gameIds = Array.from(collectionItems).map(item => item.getAttribute('objectid'));

                // 3. Fetch 'thing' data in batches
                const thingItems = await fetchThingsInBatches(gameIds);
                
                showLoading(true, 'Processing stats...');

                // 4. Process all data and render stats
                processAndRenderStats(collectionItems, thingItems);

            } catch (err) {
                console.error('Error in handleFetchStats:', err);
                showError(`An unexpected error occurred: ${err.message}`);
            } finally {
                showLoading(false);
            }
        }

        /**
         * Tries to fetch the special private_all.xml, falls back to BGG API.
         * Handles BGG API 202 polling.
         */
        async function getCollectionXml(username) {
            // Special case for 'sportomax'
            if (username.toLowerCase() === 'sportomax') {
                try {
                    console.log('Attempting to fetch local private_all.xml...');
                    const response = await fetch('private_all.xml');
                    if (response.ok) {
                        console.log('Successfully loaded private_all.xml.');
                        const xmlText = await response.text();
                        return parseXml(xmlText);
                    } else {
                        console.warn(`private_all.xml not found (${response.status}). Falling back to BGG API.`);
                    }
                } catch (err) {
                    console.warn(`Error fetching private_all.xml: ${err.message}. Falling back to BGG API.`);
                }
            }

            // Standard BGG API fetch
            return fetchCollectionFromBGG(username);
        }

        /**
         * Fetches collection from BGG, handling the 202 (Accepted) polling.
         */
        async function fetchCollectionFromBGG(username) {
            const url = `${BGG_COLLECTION_URL}?username=${username}&stats=1&own=1`;
            
            try {
                const response = await fetch(url);

                if (response.status === 202) {
                    // BGG is processing, we need to poll
                    showLoading(true, `BGG is preparing the collection for '${username}'. Please wait...`);
                    await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));
                    return fetchCollectionFromBGG(username); // Recurse
                }

                if (!response.ok) {
                    throw new Error(`BGG API returned status ${response.status}: ${response.statusText}`);
                }

                const xmlText = await response.text();

                // Check for API-level errors in the XML response
                const xmlDoc = parseXml(xmlText);
                const errorElement = xmlDoc.querySelector('error > message');
                if (errorElement) {
                    throw new Error(`BGG API Error: ${errorElement.textContent}`);
                }

                return xmlDoc;

            } catch (err) {
                console.error('Error fetching BGG collection:', err);
                showError(err.message);
                showLoading(false);
                return null;
            }
        }

        /**
         * Fetches 'thing' data for all game IDs, in batches.
         */
        async function fetchThingsInBatches(gameIds) {
            const allThingItems = [];
            const numBatches = Math.ceil(gameIds.length / THING_BATCH_SIZE);
            
            for (let i = 0; i < numBatches; i++) {
                const batchIds = gameIds.slice(i * THING_BATCH_SIZE, (i + 1) * THING_BATCH_SIZE);
                showLoading(true, `Fetching game details (batch ${i + 1} of ${numBatches})...`);
                
                try {
                    const url = `${BGG_THING_URL}?id=${batchIds.join(',')}&stats=1`;
                    const response = await fetch(url);

                    if (!response.ok) {
                        console.warn(`Batch ${i+1} fetch failed: ${response.status}`);
                        continue; // Skip this batch on error
                    }

                    const xmlText = await response.text();
                    const xmlDoc = parseXml(xmlText);
                    const items = xmlDoc.querySelectorAll('item');
                    allThingItems.push(...items);
                } catch (err) {
                    console.warn(`Error fetching batch ${i+1}: ${err.message}`);
                }
            }
            
            console.log(`Fetched details for ${allThingItems.length} out of ${gameIds.length} games.`);
            return allThingItems;
        }

        /**
         * Main processing function. Calculates all stats and renders them.
         */
        function processAndRenderStats(collectionItems, thingItems) {
            const stats = {
                totalGames: 0,
                totalPlays: 0,
                gamesWith0Plays: 0,
                ratedGames: 0,
                sumUserRatings: 0,
                bggRatedGames: 0,
                sumBggRatings: 0,
                weightedGames: 0,
                sumWeight: 0,
                minYear: Infinity,
                maxYear: -Infinity,
                playsList: [],
                mostPlayed: { name: 'N/A', plays: 0 },
            };

            // Counters for categorical data
            const mechanicCounts = new Map();
            const categoryCounts = new Map();
            const designerCounts = new Map();
            const publisherCounts = new Map();

            // Create a lookup map for 'thing' items by objectid
            const thingMap = new Map();
            thingItems.forEach(item => {
                thingMap.set(item.getAttribute('id'), item);
            });

            // --- Loop 1: Process Collection Items (User-specific data) ---
            for (const item of collectionItems) {
                stats.totalGames++;
                const gameName = item.querySelector('name')?.textContent || 'Unknown Game';
                
                // Plays
                const numPlays = parseInt(item.querySelector('numplays')?.textContent || '0');
                stats.totalPlays += numPlays;
                if (numPlays === 0) {
                    stats.gamesWith0Plays++;
                } else {
                    stats.playsList.push(numPlays);
                }

                if (numPlays > stats.mostPlayed.plays) {
                    stats.mostPlayed = { name: gameName, plays: numPlays };
                }

                // User Rating
                const userRatingStr = item.querySelector('stats > rating')?.getAttribute('value');
                if (userRatingStr && userRatingStr !== 'N/A') {
                    const userRating = parseFloat(userRatingStr);
                    if (userRating > 0) {
                        stats.ratedGames++;
                        stats.sumUserRatings += userRating;
                    }
                }

                // --- Process 'Thing' Data (Global game data) ---
                const gameId = item.getAttribute('objectid');
                const thing = thingMap.get(gameId);

                if (thing) {
                    // BGG Rating
                    const bggRatingStr = thing.querySelector('statistics > ratings > average')?.getAttribute('value');
                    if (bggRatingStr) {
                        const bggRating = parseFloat(bggRatingStr);
                        if (bggRating > 0) {
                            stats.bggRatedGames++;
                            stats.sumBggRatings += bggRating;
                        }
                    }

                    // Weight (Complexity)
                    const weightStr = thing.querySelector('statistics > ratings > averageweight')?.getAttribute('value');
                    if (weightStr) {
                        const weight = parseFloat(weightStr);
                        if (weight > 0) {
                            stats.weightedGames++;
                            stats.sumWeight += weight;
                        }
                    }

                    // Year Published
                    const yearStr = thing.querySelector('yearpublished')?.getAttribute('value');
                    if (yearStr) {
                        const year = parseInt(yearStr);
                        if (year !== 0) {
                            if (year < stats.minYear) stats.minYear = year;
                            if (year > stats.maxYear) stats.maxYear = year;
                        }
                    }

                    // Links (Mechanics, Categories, etc.)
                    const links = thing.querySelectorAll('link');
                    links.forEach(link => {
                        const type = link.getAttribute('type');
                        const value = link.getAttribute('value');
                        switch (type) {
                            case 'boardgamemechanic':
                                incrementMap(mechanicCounts, value);
                                break;
                            case 'boardgamecategory':
                                incrementMap(categoryCounts, value);
                                break;
                            case 'boardgamedesigner':
                                incrementMap(designerCounts, value);
                                break;
                            case 'boardgamepublisher':
                                incrementMap(publisherCounts, value);
                                break;
                        }
                    });
                }
            }
            
            // --- Calculate Final Stats ---
            const avgPlays = stats.totalGames > 0 ? (stats.totalPlays / stats.totalGames) : 0;
            const avgUserRating = stats.ratedGames > 0 ? (stats.sumUserRatings / stats.ratedGames) : 0;
            const avgBggRating = stats.bggRatedGames > 0 ? (stats.sumBggRatings / stats.bggRatedGames) : 0;
            const avgWeight = stats.weightedGames > 0 ? (stats.sumWeight / stats.weightedGames) : 0;
            const percentUnplayed = stats.totalGames > 0 ? (stats.gamesWith0Plays / stats.totalGames) * 100 : 0;

            // H-Index Calculation
            const sortedPlays = stats.playsList.sort((a, b) => b - a);
            let hIndex = 0;
            for (let i = 0; i < sortedPlays.length; i++) {
                if (sortedPlays[i] >= i + 1) {
                    hIndex = i + 1;
                } else {
                    break;
                }
            }
            
            // Get Top 3s
            const topMechanic = getTopFromMap(mechanicCounts, 1)[0] || 'N/A';
            const topCategory = getTopFromMap(categoryCounts, 1)[0] || 'N/A';
            const topDesigner = getTopFromMap(designerCounts, 1)[0] || 'N/A';
            const topPublisher = getTopFromMap(publisherCounts, 1)[0] || 'N/A';

            // --- Render Stat Cards ---
            statsGrid.innerHTML = ''; // Clear again just in case
            
            // Row 1: Core Stats
            renderStatCard('Total Games', stats.totalGames.toLocaleString(), 'Owned games in collection');
            renderStatCard('Total Plays', stats.totalPlays.toLocaleString(), `Avg ${avgPlays.toFixed(2)} per game`);
            renderStatCard('H-Index (Plays)', hIndex, 'Based on recorded plays');
            renderStatCard('Most Played', stats.mostPlayed.plays, stats.mostPlayed.name);

            // Row 2: Play Status
            renderStatCard('Unplayed Games', stats.gamesWith0Plays.toLocaleString(), `${percentUnplayed.toFixed(1)}% of collection`);
            renderStatCard('Games Played', (stats.totalGames - stats.gamesWith0Plays).toLocaleString(), `Avg ${avgPlays.toFixed(2)} plays`);
            renderStatCard('Oldest Game', stats.minYear === Infinity ? 'N/A' : stats.minYear, 'Year Published');
            renderStatCard('Newest Game', stats.maxYear === -Infinity ? 'N/A' : stats.maxYear, 'Year Published');

            // Row 3: Ratings
            renderStatCard('Avg. User Rating', avgUserRating.toFixed(2), `Based on ${stats.ratedGames} rated games`);
            renderStatCard('Avg. BGG Rating', avgBggRating.toFixed(2), `Based on ${stats.bggRatedGames} BGG-rated games`);
            renderStatCard('Avg. Complexity', avgWeight.toFixed(2) + ' / 5', `Based on ${stats.weightedGames} weighted games`);
            
            // Row 4: Top Links
            renderStatCard('Top Mechanic', topMechanic, `Found in ${mechanicCounts.get(topMechanic) || 0} games`);
            renderStatCard('Top Category', topCategory, `Found in ${categoryCounts.get(topCategory) || 0} games`);
            renderStatCard('Top Designer', topDesigner, `Found in ${designerCounts.get(topDesigner) || 0} games`);
            renderStatCard('Top Publisher', topPublisher, `Found in ${publisherCounts.get(topPublisher) || 0} games`);
        }

        // --- Helper Functions ---

        /**
         * Renders a single stat card and appends it to the grid.
         */
        function renderStatCard(title, value, subtitle = '') {
            const card = document.createElement('div');
            card.className = 'bg-gray-800 p-5 rounded-lg shadow-lg';
            
            let valueClass = 'text-3xl md:text-4xl font-bold text-white';
            if (typeof value === 'string' && value.length > 15) {
                valueClass = 'text-2xl font-bold text-white'; // Shrink text if it's a long string
            }

            card.innerHTML = `
                <div class="text-sm font-medium text-blue-300 uppercase tracking-wider">${title}</div>
                <div class="${valueClass} mt-2 truncate" title="${value}">${value}</div>
                ${subtitle ? `<div class="text-sm text-gray-400 mt-2 truncate" title="${subtitle}">${subtitle}</div>` : ''}
            `;
            statsGrid.appendChild(card);
        }

        /**
         * Toggles the loading indicator.
         */
        function showLoading(isLoading, message = '') {
            if (isLoading) {
                loading.classList.remove('hidden');
                loading.classList.add('flex');
                loadingMessage.textContent = message;
                fetchButton.disabled = true;
                fetchButton.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                loading.classList.add('hidden');
                loading.classList.remove('flex');
                fetchButton.disabled = false;
                fetchButton.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        /**
         * Shows or hides the error message box.
         */
        function showError(message) {
            if (message) {
                errorMessage.textContent = message;
                error.classList.remove('hidden');
            } else {
                error.classList.add('hidden');
            }
        }

        /**
         * Parses XML text into a DOM document.
         */
        function parseXml(xmlText) {
            const parser = new DOMParser();
            return parser.parseFromString(xmlText, 'text/xml');
        }

        /**
         * Helper to increment a value in a Map.
         */
        function incrementMap(map, key) {
            map.set(key, (map.get(key) || 0) + 1);
        }

        /**
         * Helper to get the top N keys from a count map.
         */
        function getTopFromMap(map, n = 1) {
            return Array.from(map.entries())
                .sort((a, b) => b[1] - a[1]) // Sort descending by count
                .slice(0, n)
                .map(entry => entry[0]); // Get just the key (name)
        }

    </script>
</body>
</html>

