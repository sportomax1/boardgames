<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BGG Collection Stats Dashboard</title>
    <!-- Load Tailwind CSS from CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for a cleaner dashboard look */
        body {
            font-family: 'Inter', sans-serif;
            transition: background-color 0.3s;
        }
        /* Simple spinner animation */
        .spinner {
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        /* Style for the debug log area */
        #debugLogContainer {
            max-height: 400px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.85rem;
            line-height: 1.4;
        }
        .log-item {
            padding: 4px 0;
            border-bottom: 1px solid #2d3748;
        }
        .log-error { color: #f56565; }
        .log-success { color: #48bb78; }
        .log-info { color: #63b3ed; }
        .log-warning { color: #f6e05e; }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen p-4 md:p-8">

    <div class="max-w-7xl mx-auto">
        
        <!-- Header and Controls -->
        <header class="mb-8">
            <h1 class="text-3xl md:text-4xl font-extrabold text-blue-400 mb-4 tracking-tight">BGG Collection Stats Dashboard</h1>
            <p class="text-gray-400 mb-6">Analyze your collection with core metrics and detailed BGG data.</p>
            <div class="flex flex-col sm:flex-row gap-4">
                <input 
                    type="text" 
                    id="usernameInput" 
                    value="sportomax" 
                    class="flex-grow bg-gray-800 text-white border border-gray-700 rounded-xl px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500 shadow-inner"
                    placeholder="Enter BGG Username"
                    aria-label="BGG Username"
                >
                <button 
                    id="fetchButton" 
                    class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-xl transition duration-300 shadow-xl active:scale-95"
                >
                    Fetch Stats
                </button>
            </div>
        </header>

        <!-- Loading Indicator -->
        <div id="loading" class="hidden flex-col items-center justify-center py-16 bg-gray-800 rounded-xl shadow-2xl mt-4">
            <div class="spinner w-12 h-12 border-4 border-gray-600 border-t-blue-500 rounded-full mb-4"></div>
            <p id="loadingMessage" class="text-lg text-blue-300 font-medium">Loading collection...</p>
        </div>

        <!-- Message Area (Updated to handle success and error) -->
        <div id="messageBox" class="hidden bg-red-800 border-l-4 border-red-500 text-red-100 px-4 py-3 rounded-lg my-6 shadow-xl" role="alert">
            <div class="flex items-center">
                <svg class="w-6 h-6 mr-3" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                <strong id="messageType" class="font-bold">Error:</strong>
                <span id="messageContent" class="block sm:inline ml-2"></span>
            </div>
        </div>

        <!-- Stats Grid -->
        <div id="statsGrid" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 md:gap-6 mt-6">
            <!-- Stat cards will be injected here by JavaScript -->
        </div>
        
        <!-- Detailed Troubleshooting Log (NEW) -->
        <div class="mt-10 p-6 bg-gray-800 rounded-xl shadow-2xl">
            <h2 class="text-xl font-bold text-gray-300 mb-3 border-b border-gray-700 pb-2">Troubleshooting & API Log</h2>
            <div id="debugLogContainer" class="bg-gray-900 p-3 rounded-lg border border-gray-700">
                <p class="text-gray-500">Log will appear here after clicking "Fetch Stats".</p>
            </div>
        </div>

        <!-- Game List (Optional detailed view) -->
        <div id="detailedList" class="hidden mt-10">
            <h2 class="text-2xl font-bold text-white mb-4 border-b border-gray-700 pb-2">Top 5 Most Played</h2>
            <ul id="topPlayedList" class="space-y-3">
                <!-- Top played games will be listed here -->
            </ul>
        </div>

    </div>

    <script>
        // --- DOM Elements ---
        const usernameInput = document.getElementById('usernameInput');
        const fetchButton = document.getElementById('fetchButton');
        const loading = document.getElementById('loading');
        const loadingMessage = document.getElementById('loadingMessage');
        const messageBox = document.getElementById('messageBox');
        const messageContent = document.getElementById('messageContent');
        const messageType = document.getElementById('messageType');
        const statsGrid = document.getElementById('statsGrid');
        const detailedList = document.getElementById('detailedList');
        const topPlayedList = document.getElementById('topPlayedList');
        const debugLogContainer = document.getElementById('debugLogContainer'); // NEW

        // --- BGG API Config ---
        const BGG_COLLECTION_URL = 'https://boardgamegeek.com/xmlapi2/collection';
        const BGG_THING_URL = 'https://boardgamegeek.com/xmlapi2/thing';
        
        // CRITICAL FIX: CORS Proxy to allow browser fetching
        const CORS_PROXY = 'https://corsproxy.io/?'; 

        const THING_BATCH_SIZE = 100; // Max recommended batch size for 'thing' API
        const POLL_INTERVAL = 3000; // Fixed 3-second delay for BGG 202 polling
        const MAX_POLL_ATTEMPTS = 15; 

        // --- Utility Function: UI Logger (NEW) ---
        /**
         * Logs messages to the console AND the dedicated UI log area for mobile troubleshooting.
         * @param {string} message The message content.
         * @param {('info'|'success'|'error'|'warning')} type The type of log message for styling.
         */
        function logToUI(message, type = 'info') {
            const now = new Date().toLocaleTimeString();
            const logItem = document.createElement('div');
            logItem.className = `log-item log-${type}`;
            logItem.innerHTML = `[${now}] <span class="uppercase font-bold">${type}</span>: ${message}`;
            
            // Clear the initial message if this is the first real log
            if (debugLogContainer.children.length === 1 && debugLogContainer.children[0].className.includes('text-gray-500')) {
                 debugLogContainer.innerHTML = '';
            }
            
            debugLogContainer.appendChild(logItem);
            debugLogContainer.scrollTop = debugLogContainer.scrollHeight; // Scroll to bottom
            
            // Also log to console for good measure
            if (type === 'error') {
                console.error(`[UI Log] ${message}`);
            } else if (type === 'warning') {
                console.warn(`[UI Log] ${message}`);
            } else {
                console.log(`[UI Log] ${message}`);
            }
        }

        // --- Event Listener ---
        fetchButton.addEventListener('click', handleFetchStats);
        usernameInput.addEventListener('keyup', (e) => {
            if (e.key === 'Enter') {
                handleFetchStats();
            }
        });
        
        /**
         * Main function to orchestrate the fetching and processing
         */
        async function handleFetchStats() {
            const username = usernameInput.value.trim();
            if (!username) {
                showMessage('Please enter a BGG username.');
                return;
            }

            // Reset UI and Log
            showLoading(true, 'Initiating fetch process...');
            showMessage(false); // Clear previous messages
            statsGrid.innerHTML = '';
            detailedList.classList.add('hidden');
            debugLogContainer.innerHTML = ''; // Clear log on new request

            try {
                logToUI(`Starting collection fetch for user: ${username}`, 'info');

                // 1. Get the source XML (either local file or BGG API)
                const collectionXmlDoc = await getCollectionXml(username);
                if (!collectionXmlDoc) {
                    logToUI('Collection XML fetch failed, stopping process.', 'error');
                    return; 
                }

                // --- NEW FILTERING: Now selecting ALL items from the BGG response. ---
                // The API URL no longer filters by 'own=1', so we must manually filter on the result.
                // However, since the user requested no filtering, we will now look for any item element.
                // NOTE: The previous code was looking for 'item[own="1"]' which matched the old API parameter.
                // Now, we look for ALL 'item' nodes, which matches the new API parameter, and honors the "don't filter" request.
                const collectionItems = Array.from(collectionXmlDoc.querySelectorAll('item'));
                const totalItems = collectionItems.length; // This is the RAW count of ALL items returned.

                if (totalItems === 0) {
                    showMessage(`BGG API reports 0 items for user '${username}'. Check your BGG profile and collection visibility.`);
                    showLoading(false);
                    return;
                }
                
                logToUI(`Raw Collection Size: Found ${totalItems} total items in the collection (no BGG status filter applied).`, 'success');

                showLoading(true, `Found ${totalItems} items. Fetching detailed data...`);

                // 2. Extract Game IDs (We MUST filter here for 'thing' API, otherwise 'thing' API will break or return irrelevant data)
                // We will only query BGG for details on actual games/expansions for performance.
                const gameIds = collectionItems
                    .filter(item => {
                        const subtype = item.getAttribute('subtype');
                        // Filter for only valid boardgame types for 'thing' API lookup
                        return subtype === 'boardgame' || subtype === 'boardgameexpansion';
                    })
                    .map(item => item.getAttribute('objectid'));
                
                logToUI(`Extracted ${gameIds.length} game/expansion IDs for detailed 'thing' API query.`, 'info');


                // 3. Fetch 'thing' data in batches
                const thingItems = await fetchThingsInBatches(gameIds);
                
                showLoading(true, 'Calculating statistics...');

                // 4. Process all data and render stats
                processAndRenderStats(collectionItems, thingItems);
                
                logToUI('Statistics calculation and rendering complete.', 'success');


            } catch (err) {
                console.error('Error in handleFetchStats:', err);
                logToUI(`An unexpected error occurred: ${err.message}`, 'error');
                showMessage(`An unexpected error occurred: ${err.message}`);
            } finally {
                showLoading(false);
            }
        }

        /**
         * Tries to fetch the special private_all.xml, falls back to BGG API.
         */
        async function getCollectionXml(username) {
            // Local file fallback kept for completeness
            if (username.toLowerCase() === 'sportomax') {
                try {
                    const response = await fetch('private_all.xml');
                    if (response.ok) {
                        logToUI('Local file fallback successful (private_all.xml).', 'info');
                        const xmlText = await response.text();
                        return parseXml(xmlText);
                    }
                } catch (err) {
                    logToUI('Local file fallback failed (expected if file is missing). Proceeding to BGG API.', 'info');
                }
            }
            
            // Standard BGG API fetch via CORS proxy
            return fetchCollectionFromBGG(username);
        }

        /**
         * Fetches collection from BGG via CORS proxy, using a fixed 3s delay for 202 polling.
         * The '&own=1' filter has been removed from the BGG API request URL.
         */
        async function fetchCollectionFromBGG(username, attempt = 0) {
            // Build the BGG API target URL (REMOVED: &own=1 to ensure all items are returned)
            const bggTargetUrl = `${BGG_COLLECTION_URL}?username=${username}&stats=1`;
            
            // URL encoding is necessary for the proxy to work reliably
            const url = `${CORS_PROXY}${encodeURIComponent(bggTargetUrl)}`;
            
            logToUI(`Collection URL (Target): ${bggTargetUrl}`, 'info');
            logToUI(`Proxy URL (Fetch): ${url}`, 'info');

            try {
                const response = await fetch(url);
                logToUI(`API Response Status: ${response.status} (${response.statusText})`, response.status >= 400 ? 'error' : 'info');

                if (response.status === 202) {
                    if (attempt >= MAX_POLL_ATTEMPTS) { 
                        throw new Error("BGG API collection request timed out after too many retries (max 15 attempts).");
                    }
                    
                    showLoading(true, `BGG is preparing the collection (v2 API). Retrying in ${POLL_INTERVAL / 1000}s (Attempt ${attempt + 1}/${MAX_POLL_ATTEMPTS})...`);
                    logToUI(`Status 202 received. Retrying in ${POLL_INTERVAL}ms. (Attempt ${attempt + 1}/${MAX_POLL_ATTEMPTS})`, 'warning');
                    await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));
                    
                    return fetchCollectionFromBGG(username, attempt + 1); 
                }

                if (!response.ok) {
                    throw new Error(`API returned status ${response.status}: ${response.statusText}`);
                }

                const xmlText = await response.text();
                logToUI(`Successfully received XML text (length: ${xmlText.length.toLocaleString()} bytes).`, 'success');

                // Check for API-level errors in the XML response
                const xmlDoc = parseXml(xmlText);
                
                const allItems = xmlDoc.querySelectorAll('item'); // Now looking for ALL item tags
                const rawItemCount = allItems.length;

                // --- PROOF POINT: Display success message on the UI ---
                showMessage(`Successfully connected and received collection XML from BGG. Found ${rawItemCount} total raw items (All Statuses).`, 'success');
                // ------------------------------------------------------
                
                logToUI(`XML parsed. Found ${rawItemCount} 'item' elements.`, 'success');

                const errorElement = xmlDoc.querySelector('errors > error');
                if (errorElement) {
                    const errorMessage = `BGG API Error within XML: ${errorElement.textContent}`;
                    logToUI(errorMessage, 'error');
                    throw new Error(errorMessage);
                }

                return xmlDoc;

            } catch (err) {
                logToUI(`Connection/Request Failed: ${err.message}`, 'error');
                showMessage(err.message);
                showLoading(false);
                return null;
            }
        }

        /**
         * Fetches 'thing' data for all game IDs, in batches via CORS proxy.
         */
        async function fetchThingsInBatches(gameIds) {
            const allThingItems = [];
            const numBatches = Math.ceil(gameIds.length / THING_BATCH_SIZE);
            
            logToUI(`Beginning 'thing' API fetch in ${numBatches} batches.`, 'info');
            
            for (let i = 0; i < numBatches; i++) {
                const batchIds = gameIds.slice(i * THING_BATCH_SIZE, (i + 1) * THING_BATCH_SIZE);
                
                showLoading(true, `Fetching game details (batch ${i + 1} of ${numBatches}, ${batchIds.length} IDs) via proxy...`);
                
                try {
                    const bggTargetUrl = `${BGG_THING_URL}?id=${batchIds.join(',')}&stats=1`; 
                    const url = `${CORS_PROXY}${encodeURIComponent(bggTargetUrl)}`;
                    
                    logToUI(`Batch ${i + 1}/${numBatches} (IDs: ${batchIds.length}): fetching...`, 'info');
                    
                    const response = await fetch(url);
                    logToUI(`Batch ${i + 1} Status: ${response.status}.`, response.status >= 400 ? 'warning' : 'info');

                    if (!response.ok) {
                        console.warn(`Batch ${i+1} fetch failed: ${response.status}. Skipping batch.`);
                        logToUI(`Batch ${i+1} fetch failed (Status ${response.status}). Skipping.`, 'warning');
                        continue;
                    }

                    const xmlText = await response.text();
                    const xmlDoc = parseXml(xmlText);
                    // Filter down to only boardgames/expansions for accurate stats population
                    const items = xmlDoc.querySelectorAll('item[type="boardgame"], item[type="boardgameexpansion"]');
                    allThingItems.push(...items);
                    
                    logToUI(`Batch ${i + 1} succeeded. Retrieved ${items.length} game details.`, 'success');

                    // Throttle requests slightly
                    await new Promise(resolve => setTimeout(resolve, 500)); 

                } catch (err) {
                    console.warn(`Error fetching batch ${i+1}: ${err.message}. Skipping batch.`);
                    logToUI(`Error during Batch ${i+1} fetch: ${err.message}. Skipping.`, 'error');
                }
            }
            
            logToUI(`Finished 'thing' API fetch. Successfully collected details for ${allThingItems.length} items.`, 'success');
            return allThingItems;
        }

        /**
         * Main processing function. Calculates all stats and renders them.
         */
        function processAndRenderStats(collectionItems, thingItems) {
            // NOTE: collectionItems is the RAW owned list (all item types), so totalGames reflects this.
            // Stats derived from BGG API ('thing' data) will only be for actual games/expansions.
            
            const stats = {
                totalGames: 0, // This is now total ALL ITEMS
                totalPlays: 0,
                gamesWith0Plays: 0,
                ratedGames: 0,
                sumUserRatings: 0,
                bggRatedGames: 0,
                sumBggRatings: 0,
                weightedGames: 0,
                sumWeight: 0,
                minYear: Infinity,
                maxYear: -Infinity,
                playsList: [],
                mostPlayedGames: [], 
            };

            const mechanicCounts = new Map();
            const categoryCounts = new Map();
            const designerCounts = new Map();
            const thingMap = new Map();
            thingItems.forEach(item => {
                thingMap.set(item.getAttribute('id'), item);
            });
            
            logToUI(`Beginning statistical calculation on ${collectionItems.length} raw collection items.`, 'info');


            // --- Loop 1: Process Collection Items (User-specific data) ---
            for (const item of collectionItems) {
                stats.totalGames++;
                const gameName = item.querySelector('name')?.textContent || 'Unknown Item';
                const subtype = item.getAttribute('subtype'); // Check subtype for logging/debug context
                
                // Plays (available for all types of items)
                const numPlays = parseInt(item.querySelector('numplays')?.textContent || '0');
                stats.totalPlays += numPlays;
                if (numPlays === 0) {
                    stats.gamesWith0Plays++;
                } 
                
                stats.mostPlayedGames.push({ name: gameName, plays: numPlays, subtype: subtype });

                // User Rating (available for all types of items)
                const userRatingStr = item.querySelector('stats > rating')?.getAttribute('value');
                if (userRatingStr && userRatingStr !== 'N/A') {
                    const userRating = parseFloat(userRatingStr);
                    if (userRating > 0) {
                        stats.ratedGames++;
                        stats.sumUserRatings += userRating;
                    }
                }

                // --- Process 'Thing' Data (Global game data - ONLY available for games/expansions) ---
                const gameId = item.getAttribute('objectid');
                const thing = thingMap.get(gameId);

                // Only calculate BGG stats for items we successfully fetched detailed data for (i.e. games/expansions)
                if (thing) {
                    // BGG Rating
                    const bggRatingStr = thing.querySelector('statistics > ratings > average')?.getAttribute('value');
                    if (bggRatingStr) {
                        const bggRating = parseFloat(bggRatingStr);
                        if (bggRating > 0) {
                            stats.bggRatedGames++;
                            stats.sumBggRatings += bggRating;
                        }
                    }

                    // Weight (Complexity)
                    const weightStr = thing.querySelector('statistics > ratings > averageweight')?.getAttribute('value');
                    if (weightStr) {
                        const weight = parseFloat(weightStr);
                        if (weight > 0) {
                            stats.weightedGames++;
                            stats.sumWeight += weight;
                        }
                    }

                    // Year Published
                    const yearStr = thing.querySelector('yearpublished')?.getAttribute('value');
                    if (yearStr) {
                        const year = parseInt(yearStr);
                        if (year > 0 && year !== 9999) { 
                            if (year < stats.minYear) stats.minYear = year;
                            if (year > stats.maxYear) stats.maxYear = year;
                        }
                    }

                    // Links (Mechanics, Categories, Designers)
                    const links = thing.querySelectorAll('link');
                    links.forEach(link => {
                        const type = link.getAttribute('type');
                        const value = link.getAttribute('value');
                        switch (type) {
                            case 'boardgamemechanic':
                                incrementMap(mechanicCounts, value);
                                break;
                            case 'boardgamecategory':
                                incrementMap(categoryCounts, value);
                                break;
                            case 'boardgamedesigner':
                                incrementMap(designerCounts, value);
                                break;
                        }
                    });
                }
            }
            
            // --- Calculate Final Stats ---
            const avgPlays = stats.totalGames > 0 ? (stats.totalPlays / stats.totalGames) : 0;
            const avgUserRating = stats.ratedGames > 0 ? (stats.sumUserRatings / stats.ratedGames) : 0;
            const avgBggRating = stats.bggRatedGames > 0 ? (stats.sumBggRatings / stats.bggRatedGames) : 0;
            const avgWeight = stats.weightedGames > 0 ? (stats.sumWeight / stats.weightedGames) : 0;
            const percentUnplayed = stats.totalGames > 0 ? (stats.gamesWith0Plays / stats.totalGames) * 100 : 0;
            
            // H-Index Calculation
            const sortedPlays = stats.mostPlayedGames.map(g => g.plays).sort((a, b) => b - a);
            let hIndex = 0;
            for (let i = 0; i < sortedPlays.length; i++) {
                if (sortedPlays[i] >= i + 1) {
                    hIndex = i + 1;
                } else {
                    break;
                }
            }
            
            // Get Top 1s
            const topMechanic = getTopFromMap(mechanicCounts, 1)[0] || 'N/A';
            const topCategory = getTopFromMap(categoryCounts, 1)[0] || 'N/A';
            const topDesigner = getTopFromMap(designerCounts, 1)[0] || 'N/A';
            
            // Find most played game
            const sortedPlayedGames = stats.mostPlayedGames.sort((a, b) => b.plays - a.plays);


            // --- Render Stat Cards ---
            statsGrid.innerHTML = ''; // Clear again just in case
            
            // Row 1: Core Stats
            renderStatCard('Total Collection Items (RAW)', stats.totalGames.toLocaleString(), 'Includes all items regardless of BGG status.');
            renderStatCard('Total Plays (All Items)', stats.totalPlays.toLocaleString(), `Avg ${avgPlays.toFixed(2)} plays per item`);
            renderStatCard('H-Index (Plays)', hIndex, 'Your personal play metric');
            renderStatCard('Avg. Complexity', avgWeight.toFixed(2) + ' / 5', `Based on ${stats.weightedGames} filtered titles`);

            // Row 2: Play Status
            renderStatCard('Unplayed Items', stats.gamesWith0Plays.toLocaleString(), `${percentUnplayed.toFixed(1)}% of collection`);
            renderStatCard('Items Played', (stats.totalGames - stats.gamesWith0Plays).toLocaleString(), 'Have at least 1 recorded play');
            renderStatCard('Oldest Game', stats.minYear === Infinity ? 'N/A' : stats.minYear, `Year of oldest known game (${stats.weightedGames} tracked)`);
            renderStatCard('Newest Game', stats.maxYear === -Infinity ? 'N/A' : stats.maxYear, `Year of newest known game (${stats.weightedGames} tracked)`);

            // Row 3: Ratings
            renderStatCard('Avg. User Rating', avgUserRating.toFixed(2), `From your ${stats.ratedGames} ratings on any item type`);
            renderStatCard('Avg. BGG Rating', avgBggRating.toFixed(2), `Community Avg. of ${stats.bggRatedGames} filtered titles`);
            
            // Row 4: Top Links
            renderStatCard('Top Mechanic (Filtered)', topMechanic, `Found in ${mechanicCounts.get(topMechanic) || 0} games`);
            renderStatCard('Top Category (Filtered)', topCategory, `Found in ${categoryCounts.get(topCategory) || 0} games`);
            renderStatCard('Top Designer (Filtered)', topDesigner, `Found in ${designerCounts.get(topDesigner) || 0} games`);
            
            // Render detailed list
            renderTopPlayedList(sortedPlayedGames.slice(0, 5));
        }

        // --- Helper Functions ---

        /**
         * Renders a single stat card and appends it to the grid.
         */
        function renderStatCard(title, value, subtitle = '') {
            const card = document.createElement('div');
            card.className = 'bg-gray-800 p-5 rounded-xl shadow-2xl transition duration-300 hover:shadow-blue-500/50 hover:scale-[1.02]';
            
            let valueClass = 'text-3xl md:text-4xl font-extrabold text-white';
            if (typeof value === 'string' && value.length > 15) {
                valueClass = 'text-2xl font-extrabold text-white'; // Shrink text if it's a long string
            }

            card.innerHTML = `
                <div class="text-sm font-medium text-blue-400 uppercase tracking-wider">${title}</div>
                <div class="${valueClass} mt-2 truncate" title="${value}">${value}</div>
                ${subtitle ? `<div class="text-sm text-gray-400 mt-2 truncate" title="${subtitle}">${subtitle}</div>` : ''}
            `;
            statsGrid.appendChild(card);
        }
        
        /**
         * Renders a detailed list of the top N most played games.
         */
        function renderTopPlayedList(topGames) {
            topPlayedList.innerHTML = '';
            if (topGames.length === 0 || topGames[0]?.plays === 0) {
                detailedList.classList.add('hidden');
                return;
            }
            detailedList.classList.remove('hidden');

            topGames.forEach((game, index) => {
                const listItem = document.createElement('li');
                listItem.className = 'bg-gray-800 p-4 rounded-lg flex justify-between items-center shadow-lg';
                listItem.innerHTML = `
                    <div class="flex items-center">
                        <span class="text-xl font-bold text-blue-400 mr-3">${index + 1}.</span>
                        <span class="text-white font-medium truncate">${game.name}</span>
                    </div>
                    <span class="text-xs text-gray-400 mr-2 uppercase">${game.subtype || 'Item'}</span>
                    <span class="text-lg font-bold bg-blue-600 text-white rounded-full px-4 py-1">${game.plays} Plays</span>
                `;
                topPlayedList.appendChild(listItem);
            });
        }

        /**
         * Toggles the loading indicator.
         */
        function showLoading(isLoading, message = '') {
            if (isLoading) {
                loading.classList.remove('hidden');
                loading.classList.add('flex');
                loadingMessage.textContent = message;
                fetchButton.disabled = true;
                fetchButton.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                loading.classList.add('hidden');
                loading.classList.remove('flex');
                fetchButton.disabled = false;
                fetchButton.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        /**
         * Shows or hides a message box (error or success).
         */
        function showMessage(message, type = 'error') {
            const errorIconPath = "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z";
            const successIconPath = "M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z";
            
            // Clear all previous coloring classes
            messageBox.classList.remove('bg-red-800', 'border-red-500', 'text-red-100', 'bg-green-800', 'border-green-500', 'text-green-100');

            if (message) {
                messageContent.textContent = message;
                messageBox.classList.remove('hidden');
                
                // Set colors and icon based on type
                if (type === 'success') {
                    messageBox.classList.add('bg-green-800', 'border-green-500', 'text-green-100');
                    messageType.textContent = 'Success:';
                    messageBox.querySelector('svg path').setAttribute('d', successIconPath);
                } else {
                    messageBox.classList.add('bg-red-800', 'border-red-500', 'text-red-100');
                    messageType.textContent = 'Error:';
                    messageBox.querySelector('svg path').setAttribute('d', errorIconPath);
                }
            } else {
                messageBox.classList.add('hidden');
            }
        }

        /**
         * Parses XML text into a DOM document.
         */
        function parseXml(xmlText) {
            const parser = new DOMParser();
            return parser.parseFromString(xmlText, 'text/xml');
        }

        /**
         * Helper to increment a value in a Map.
         */
        function incrementMap(map, key) {
            map.set(key, (map.get(key) || 0) + 1);
        }

        /**
         * Helper to get the top N keys from a count map.
         */
        function getTopFromMap(map, n = 1) {
            return Array.from(map.entries())
                .sort((a, b) => b[1] - a[1]) // Sort descending by count
                .slice(0, n)
                .map(entry => entry[0]); // Get just the key (name)
        }

    </script>
</body>
</html>

