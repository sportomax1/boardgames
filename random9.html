<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BGG Random 9 Grid</title>
    <style>
        html, body {
            min-height: 100vh;
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            color: #1c1e21;
        }

        .container {
            width: 95%;
            max-width: 550px;
            margin: 20px auto;
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 20px;
            box-sizing: border-box;
        }

        h1 {
            text-align: center;
            color: #333;
            font-size: 1.5rem;
            margin-top: 0;
        }
        
        /* Mobile-First Controls Layout (Stacked) */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 20px;
        }

        #username-input {
            width: 100%;
            font-size: 16px;
            padding: 12px 14px;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-sizing: border-box;
        }

        button {
            font-size: 16px;
            font-weight: bold;
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            width: 100%;
        }

        #submit-btn {
            background-color: #1877f2;
            color: white;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
        }

        #submit-btn:active {
            transform: scale(0.99);
        }
        
        #submit-btn:disabled {
            background-color: #9dbef2;
            cursor: not-allowed;
        }

        #game-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            border: 1px solid #ddd;
            background-color: #f9f9f9;
            padding: 8px;
            border-radius: 8px;
            aspect-ratio: 1 / 1;
        }

        .game-cell {
            position: relative;
            background-color: #fff;
            border-radius: 6px;
            overflow: hidden;
            /* Use flex to center the image if needed, though 100% height/width should fill it */
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            transition: box-shadow 0.2s;
        }

        .game-cell.drag-over {
            box-shadow: 0 0 0 3px #1877f2; /* Touch target indicator */
        }

        .game-cell img {
            width: 100%;
            height: 100%; /* Image now fills the entire cell */
            object-fit: contain; /* CRITICAL: Prevents cropping and maintains aspect ratio */
            cursor: grab;
            transition: opacity 0.2s;
            background-color: #eee;
        }

        .game-cell img.dragging {
            opacity: 0.4;
            cursor: grabbing;
        }
        
        /* .game-name CSS has been removed */

        #status {
            margin: 15px 0;
            text-align: center;
            font-style: italic;
            color: #606770;
            min-height: 1.2em;
            font-size: 0.9rem;
        }

        #generate-btn {
            background-color: #42b72a;
            color: white;
            margin-top: 20px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
        }

        #generate-btn:active {
            transform: scale(0.99);
        }

        #generate-btn:disabled {
            background-color: #a3d99a;
            cursor: not-allowed;
        }
        
        #download-link {
            display: block;
            text-align: center;
            margin-top: 15px;
            font-weight: bold;
            color: #1877f2;
            text-decoration: none;
            padding: 10px;
            border: 2px solid #1877f2;
            border-radius: 8px;
            transition: background-color 0.2s;
        }
        
        #download-link:hover {
            background-color: #e7f3ff;
        }

    </style>
</head>
<body>

    <div class="container">
        <h1>BGG Random 9 Grid</h1>
        <div class="controls">
            <input type="text" id="username-input" value="sportomax" placeholder="Enter BGG Username" autocapitalize="none" autocorrect="off">
            <button id="submit-btn">Get Games</button>
        </div>
        <div id="status">Enter your BGG username and click "Get Games" to fetch 9 random owned titles.</div>
        <div id="game-grid"></div>
        <button id="generate-btn" disabled>Generate Combined Image</button>
        <div id="download-area"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Element References ---
            const usernameInput = document.getElementById('username-input');
            const submitBtn = document.getElementById('submit-btn');
            const grid = document.getElementById('game-grid');
            const status = document.getElementById('status');
            const generateBtn = document.getElementById('generate-btn');
            const downloadArea = document.getElementById('download-area');

            // --- BGG API Base URL ---
            const BGG_API_URL = 'https://boardgamegeek.com/xmlapi2/';
            
            // Proxy only for images to fix Canvas 'tainted' security error
            const IMAGE_PROXY = 'https://images.weserv.nl/?url=';

            let draggedCell = null;
            let touchTargetCell = null;

            // --- Utility Functions ---

            /** Shuffles an array in place. */
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            /** Helper function to delay execution. */
            function wait(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            /**
             * Fetches data from the BGG API, handling the 202 retry logic.
             * @param {string} url The BGG API endpoint URL (e.g., collection?username...)
             * @param {number} retries Number of BGG 202 retries left (fixed 3s delay).
             */
            async function fetchBGG(url, retries = 5) {
                const fullUrl = BGG_API_URL + url;
                
                try {
                    const response = await fetch(fullUrl);

                    // 1. --- BGG-Specific 202 Retry Logic (Fixed 3-second delay) ---
                    if (response.status === 202 && retries > 0) {
                        status.textContent = `BGG is processing the request queue. Retrying in 3 seconds... (${retries} attempts left)`;
                        await wait(3000); 
                        return fetchBGG(url, retries - 1); 
                    }

                    if (!response.ok) {
                        throw new Error(`BGG API fetch failed: Status ${response.status} ${response.statusText}`);
                    }

                    return await response.text();

                } catch (error) {
                    console.error('Fetch error:', error);
                    // Pass network errors up to the caller
                    throw new Error(`Network/API error: ${error.message}`);
                }
            }
            
            /** Parses XML text into a DOM object. */
            function parseXML(xmlText) {
                return new DOMParser().parseFromString(xmlText, 'text/xml');
            }

            // --- Event Handlers ---

            /** Main function to fetch and display games. */
            async function handleSubmit() {
                const username = usernameInput.value.trim();
                if (!username) {
                    status.textContent = 'Please enter a username.';
                    return;
                }

                // Disable buttons and clear
                submitBtn.disabled = true;
                generateBtn.disabled = true;
                grid.innerHTML = '';
                downloadArea.innerHTML = '';
                status.textContent = `Fetching owned collection for "${username}"...`;

                try {
                    // 1. Fetch the user's collection (only owned games)
                    const collectionUrl = `collection?username=${username}&own=1`;
                    const collectionXMLText = await fetchBGG(collectionUrl);
                    const collectionDoc = parseXML(collectionXMLText);

                    if (collectionDoc.querySelector('errors error')) {
                         throw new Error(collectionDoc.querySelector('errors error').textContent);
                    }

                    const items = Array.from(collectionDoc.querySelectorAll('item[objectid]'));
                    if (items.length === 0) {
                        throw new Error(`No owned games found for user "${username}".`);
                    }

                    if (items.length < 9) {
                        status.textContent = `Warning: User only has ${items.length} owned games. Using all of them.`;
                    }

                    // 2. Get 9 random game IDs
                    shuffleArray(items);
                    const randomItems = items.slice(0, 9);
                    const gameIds = randomItems.map(item => item.getAttribute('objectid'));
                    const gameIdString = gameIds.join(',');

                    status.textContent = `Fetching details for ${gameIds.length} random games...`;

                    // 3. Fetch the details (image and name) for those 9 games (ONE CALL)
                    const thingUrl = `thing?id=${gameIdString}`;
                    const thingXMLText = await fetchBGG(thingUrl);
                    const thingDoc = parseXML(thingXMLText);
                    
                    const gameData = [];
                    thingDoc.querySelectorAll('item').forEach(item => {
                        const id = item.getAttribute('id');
                        const imageEl = item.querySelector('image');
                        
                        const imageUrl = imageEl ? imageEl.textContent : null;
                        
                        // Use the image proxy for the canvas to avoid tainted canvas error
                        const proxiedUrl = imageUrl 
                            ? `${IMAGE_PROXY}${imageUrl}` 
                            : 'https://placehold.co/300x300/c0c0c0/000?text=No+Image';

                        // The name element is intentionally not retrieved or stored
                        gameData.push({ id, proxiedUrl });
                    });
                    
                    // 4. Populate the grid
                    populateGrid(gameData);
                    status.textContent = 'Done. Drag and drop the game tiles to organize your grid.';
                    generateBtn.disabled = false;

                } catch (error) {
                    console.error(error);
                    status.textContent = `Error: ${error.message}`;
                } finally {
                    submitBtn.disabled = false;
                }
            }

            /** Creates and adds the game cell elements to the grid. */
            function populateGrid(gameData) {
                grid.innerHTML = ''; // Clear previous grid
                gameData.forEach(game => {
                    const cell = document.createElement('div');
                    cell.className = 'game-cell';
                    cell.draggable = true;
                    
                    const img = document.createElement('img');
                    img.src = game.proxiedUrl;
                    img.dataset.gameId = game.id; 
                    img.crossOrigin = 'Anonymous'; // CRITICAL for canvas access
                    
                    // Game name element creation removed
                    
                    cell.appendChild(img);
                    
                    // Add Drag (Mouse) listeners
                    cell.addEventListener('dragstart', handleDragStart);
                    cell.addEventListener('dragover', handleDragOver);
                    cell.addEventListener('drop', handleDrop);
                    cell.addEventListener('dragend', handleDragEnd);
                    
                    // Add Touch listeners (Mobile Drag & Drop)
                    cell.addEventListener('touchstart', handleTouchStart);
                    cell.addEventListener('touchmove', handleTouchMove);
                    cell.addEventListener('touchend', handleTouchEnd);
                    
                    grid.appendChild(cell);
                });
            }

            /** Generates a single 3x3 PNG image from the current grid order. */
            async function handleGenerateImage() {
                status.textContent = 'Generating image... Please wait.';
                downloadArea.innerHTML = '';
                
                const cells = Array.from(grid.querySelectorAll('.game-cell'));
                if (cells.length !== 9) {
                    status.textContent = 'Error: Grid is not fully populated.';
                    return;
                }

                // Canvas dimensions: 900x900 for good resolution
                const canvas = document.createElement('canvas');
                const cellSize = 300; 
                canvas.width = cellSize * 3;
                canvas.height = cellSize * 3;
                const ctx = canvas.getContext('2d');

                ctx.fillStyle = '#f0f2f5';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                try {
                    const drawPromises = cells.map((cell, index) => {
                        return new Promise((resolve, reject) => {
                            const img = cell.querySelector('img');
                            const x = (index % 3) * cellSize;
                            const y = Math.floor(index / 3) * cellSize;
                            
                            const drawImage = () => {
                                // Draw Image filling the entire cell (300x300)
                                ctx.drawImage(img, x, y, cellSize, cellSize); 
                                resolve();
                            };

                            // Ensure image is loaded before drawing
                            if (img.complete && img.naturalHeight !== 0) {
                                drawImage();
                            } else {
                                img.onload = drawImage;
                                img.onerror = () => {
                                    console.error(`Failed to load image: ${img.src}`);
                                    // Draw error box as fallback
                                    ctx.fillStyle = '#c0392b';
                                    ctx.fillRect(x, y, cellSize, cellSize);
                                    ctx.fillStyle = 'white';
                                    ctx.font = '30px Inter, sans-serif'; 
                                    ctx.textAlign = 'center';
                                    ctx.fillText('ERROR', x + cellSize / 2, y + cellSize / 2);
                                    resolve(); 
                                };
                            }
                        });
                    });

                    await Promise.all(drawPromises);

                    // Create a download link
                    const username = usernameInput.value.trim() || 'bgg-grid';
                    const link = document.createElement('a');
                    link.href = canvas.toDataURL('image/png');
                    link.download = `${username}-bgg-grid.png`;
                    link.textContent = 'Download Combined Image';
                    link.id = 'download-link';
                    
                    downloadArea.appendChild(link);
                    status.textContent = 'Image generated. Click the link to download or long-press to share.';

                } catch (error) {
                    console.error('Canvas generation error:', error);
                    status.textContent = 'Error generating image. See console for details.';
                }
            }


            // --- Drag & Drop (Mouse) Handlers ---

            function swapCellContent(cell1, cell2) {
                // We use the entire innerHTML to swap everything (image + data attributes)
                const tempHTML = cell1.innerHTML;
                const tempGameId = cell1.dataset.gameId;
                
                cell1.innerHTML = cell2.innerHTML;
                cell1.dataset.gameId = cell2.dataset.gameId;

                cell2.innerHTML = tempHTML;
                cell2.dataset.gameId = tempGameId;
                
                // CRITICAL: Re-establish crossOrigin property on swapped images
                cell1.querySelector('img').crossOrigin = 'Anonymous';
                cell2.querySelector('img').crossOrigin = 'Anonymous';
                
                // Clear any old download link
                downloadArea.innerHTML = '';
                if (status.textContent.startsWith('Image generated')) {
                    status.textContent = 'Grid order changed. Generate a new image.';
                }
            }

            function handleDragStart(e) {
                draggedCell = this;
                this.querySelector('img').classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            }

            function handleDragOver(e) {
                e.preventDefault();
                const targetCell = e.target.closest('.game-cell');
                if (targetCell && targetCell !== draggedCell) {
                    // Highlight the drop target
                    targetCell.classList.add('drag-over');
                }
            }
            
            function handleDrop(e) {
                e.preventDefault();
                const targetCell = e.target.closest('.game-cell');
                if (targetCell && targetCell !== draggedCell) {
                    swapCellContent(targetCell, draggedCell);
                }
            }

            function handleDragEnd(e) {
                this.querySelector('img').classList.remove('dragging');
                draggedCell = null;
                // Remove all drag-over highlights
                grid.querySelectorAll('.game-cell').forEach(cell => cell.classList.remove('drag-over'));
            }
            
            // --- Touch (Mobile) Handlers ---
            
            function handleTouchStart(e) {
                e.preventDefault(); // Prevent scrolling/zoom
                draggedCell = this;
                this.querySelector('img').classList.add('dragging');
                // Capture initial touch position for move calculation
                const touch = e.touches[0];
                draggedCell.startX = touch.clientX;
                draggedCell.startY = touch.clientY;
                
                // Store initial position relative to the viewport/document
                const rect = draggedCell.getBoundingClientRect();
                draggedCell.initialX = rect.left + window.scrollX;
                draggedCell.initialY = rect.top + window.scrollY;
            }

            function handleTouchMove(e) {
                if (!draggedCell) return;
                e.preventDefault(); 

                const touch = e.touches[0];
                const dx = touch.clientX - draggedCell.startX;
                const dy = touch.clientY - draggedCell.startY;
                
                // Visually move the element using fixed position for smooth drag feedback
                // Note: We move the element based on its initial fixed position plus the delta
                draggedCell.style.position = 'fixed';
                draggedCell.style.zIndex = '10';
                draggedCell.style.left = `${draggedCell.initialX + dx}px`;
                draggedCell.style.top = `${draggedCell.initialY + dy}px`;

                // Determine which cell the touch is currently over
                const elementOver = document.elementFromPoint(touch.clientX, touch.clientY);
                const currentTargetCell = elementOver ? elementOver.closest('.game-cell') : null;

                // Handle visual drag-over state
                if (currentTargetCell && currentTargetCell !== draggedCell && currentTargetCell !== touchTargetCell) {
                    if (touchTargetCell) {
                        touchTargetCell.classList.remove('drag-over');
                    }
                    currentTargetCell.classList.add('drag-over');
                    touchTargetCell = currentTargetCell;
                } else if (!currentTargetCell && touchTargetCell) {
                    touchTargetCell.classList.remove('drag-over');
                    touchTargetCell = null;
                }
            }

            function handleTouchEnd(e) {
                if (!draggedCell) return;
                e.preventDefault();
                
                // Perform the swap if we have a valid target
                if (touchTargetCell && touchTargetCell !== draggedCell) {
                    swapCellContent(touchTargetCell, draggedCell);
                }

                // Reset styling (must be done AFTER swap if it occurs)
                draggedCell.style.position = 'relative';
                draggedCell.style.zIndex = 'auto';
                draggedCell.style.left = 'auto';
                draggedCell.style.top = 'auto';
                draggedCell.querySelector('img').classList.remove('dragging');
                
                // Clean up
                if (touchTargetCell) {
                    touchTargetCell.classList.remove('drag-over');
                }
                draggedCell = null;
                touchTargetCell = null;
            }


            // --- Initial Setup ---
            submitBtn.addEventListener('click', handleSubmit);
            generateBtn.addEventListener('click', handleGenerateImage);
        });
    </script>

</body>
</html>

