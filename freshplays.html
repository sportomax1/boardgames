<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Viewport optimized for modern iOS devices (iPhone Focus) -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover">
    <title>Fresh Plays - Boardgames Hub</title>
    <style>
        /* Base styles */
        body {
            margin: 0;
            padding: 0;
            /* Use Apple's preferred font stack for a native feel */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: #f7f7fa; /* Light, soft background */
            color: #222;
        }
        .container {
            /* Max width typical of a large iPhone */
            max-width: 430px; 
            margin: 0 auto;
            /* IMPORTANT: Increased top padding to account for fixed header + new debug area */
            padding: 6.5em 1em 1em 1em; 
            box-sizing: border-box;
            min-height: 100vh;
            /* Safe area for bottom swipe bar/notch */
            padding-bottom: calc(1em + env(safe-area-inset-bottom)); 
        }
        /* Fixed Header for Username Input, Title, and Debug Area */
        .header-fixed {
            position: fixed;
            top: 0;
            width: 100%;
            max-width: 430px; 
            margin: 0 auto;
            left: 0;
            right: 0;
            background: #fff;
            box-shadow: 0 1px 4px rgba(0,0,0,0.05);
            z-index: 100;
            /* Safe area for top notch */
            padding: env(safe-area-inset-top) 1em 0.5em 1em; 
            box-sizing: border-box;
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
        }
        h1 {
            font-size: 1.5em;
            margin: 0 0 0.5em 0;
            text-align: center;
            font-weight: 700;
            color: #1976d2; /* Primary blue accent */
        }
        /* Username Input Styling */
        .username-form {
            display: flex;
            gap: 10px;
            margin-bottom: 0.5em;
        }
        #usernameInput {
            flex-grow: 1;
            padding: 0.6em 1em;
            border-radius: 8px;
            border: 1px solid #ddd;
            font-size: 1em;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
            transition: border-color 0.2s;
        }
        #usernameInput:focus {
            border-color: #1976d2;
            outline: none;
        }
        #loadPlaysBtn {
            background: #a020f0; /* Purple for action */
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 0.6em 1.2em;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            flex-shrink: 0;
            transition: background-color 0.2s, box-shadow 0.2s, opacity 0.2s;
            box-shadow: 0 2px 4px rgba(160, 32, 240, 0.3);
        }
        #loadPlaysBtn:active { 
            background: #7a18bc; 
            box-shadow: none;
        }
        /* Style for when button is disabled during fetch */
        #loadPlaysBtn:disabled {
            background: #999;
            opacity: 0.7;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Utility button styling for home/scroll */
        .action-button {
            position:fixed; 
            z-index:999; 
            background:#1976d2; 
            color:#fff; 
            border:none; 
            border-radius:50%; 
            width:44px; 
            height:44px; 
            font-size:1.5em; 
            box-shadow:0 4px 12px rgba(0,0,0,0.2); 
            display:flex; 
            align-items:center; 
            justify-content:center; 
            transition: background-color 0.2s;
        }
        .action-button:active {
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            transform: translateY(1px);
        }
        .scroll-button {
            background: #a020f0; /* Purple for secondary action */
        }


        /* Play Card Styling */
        .play-list {
            margin-top: 0.5em;
        }
        .play-card {
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.08); /* Stronger shadow for professional depth */
            margin-bottom: 1em;
            padding: 1em 1.2em;
            display: flex;
            flex-direction: column;
            border-left: 6px solid #1976d2; /* Accent color */
            transition: transform 0.1s;
        }
        .play-card:active {
            transform: scale(0.99);
        }
        .play-header {
            display: flex;
            align-items: flex-start;
            margin-bottom: 0.5em;
        }
        .play-title {
            font-size: 1.1em;
            font-weight: 600;
            line-height: 1.3;
            color: #000;
        }
        .play-details {
            font-size: 0.9em;
            color: #555;
            line-height: 1.5;
        }
        /* Rating Badges Styling */
        .rating-badge {
            font-size: 0.8em;
            font-weight: 600;
            padding: 0.3em 0.6em;
            border-radius: 4px;
            margin-top: 0.2em;
            display: inline-block;
            margin-right: 8px;
            /* Add subtle shadow to badges */
            box-shadow: 0 1px 2px rgba(0,0,0,0.1); 
        }
        .user-rating {
            background: #a020f033; /* Light purple */
            color: #a020f0;
            border: 1px solid #a020f088;
        }
        .avg-rating {
            background: #ffc10733; /* Light yellow */
            color: #d69800;
            border: 1px solid #d6980088;
        }

        /* Modal Styling */
        .modal {
            position: fixed;
            top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.4); 
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(3px); 
        }
        .modal-content {
            background: #fff;
            border-radius: 14px;
            padding: 1.5em;
            max-width: 90vw;
            box-shadow: 0 16px 48px #0004;
            text-align: center;
        }
        .modal-content button {
            background: #1976d2; 
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 0.7em 2em;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .modal-content button:active { background: #1565c0; }
        .modal-details-box {
            font-size: 1em; 
            text-align:left; 
            background:#f7f7fa; 
            padding:1em; 
            border-radius:8px; 
            max-height:48vh; 
            overflow:auto;
        }
    </style>
</head>
<body>
    <!-- Fixed Navigation/Home Button -->
    <a id="homeBtn" href="index.html" class="action-button" style="left:calc(50vw - 215px); top:calc(10px + env(safe-area-inset-top));">
        <!-- Back Arrow SVG -->
        <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" style="width:24px; height:24px;">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M15 19l-7-7 7-7" />
        </svg>
    </a>
    
    <!-- Scroll Buttons -->
    <button id="scrollTopBtn" class="action-button scroll-button" style="right:calc(50vw - 215px); bottom:calc(24px + env(safe-area-inset-bottom)); display:none;">
        <!-- Up Arrow SVG -->
        <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" style="width:24px; height:24px;">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M5 10l7-7m0 0l7 7m-7-7v18" />
        </svg>
    </button>
    <button id="scrollBottomBtn" class="action-button scroll-button" style="left:calc(50vw - 215px); bottom:calc(24px + env(safe-area-inset-bottom)); display:none;">
        <!-- Down Arrow SVG -->
        <svg fill="none" viewBox="0 0 24 24" stroke="currentColor" style="width:24px; height:24px;">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M19 14l-7 7m0 0l-7-7m7 7V3" />
        </svg>
    </button>

    <!-- Fixed Header containing Title, User Input, and Debug Display -->
    <div class="header-fixed">
        <h1>Fresh Plays</h1>
        <div class="username-form">
            <input type="text" id="usernameInput" placeholder="Enter BGG Username" value="sportomax">
            <button id="loadPlaysBtn">Load</button>
        </div>
        <!-- New Debug Display Area for mobile troubleshooting -->
        <div id="debugDisplay" style="font-size:0.75em; color:#333; background:#f0f8ff; padding:0.4em; border-radius:6px; margin-top:0.4em; text-align:left; border: 1px solid #d0e0ff; overflow-x: scroll; white-space: nowrap;">
            <p style="margin:0;">Debug: Ready. URL status will appear here after clicking "Load".</p>
        </div>
    </div>

    <div class="container">
        <div id="playList" class="play-list">
             <!-- Initial message when not yet loaded -->
             <div id="statusMessage" style="text-align:center; color:#1976d2; font-size:1.1em; padding-top:2em;">Ready to load plays for sportomax. Hit "Load".</div>
        </div>
    </div>

    <script>
    const defaultUsername = 'sportomax';
    const usernameInput = document.getElementById('usernameInput');
    const loadPlaysBtn = document.getElementById('loadPlaysBtn');
    const playList = document.getElementById('playList');
    const debugElement = document.getElementById('debugDisplay');
    const statusMessageElement = document.getElementById('statusMessage');
    
    // Global map and reference for XML nodes
    let collectionRatingsMap = new Map();
    window._playRefs = []; 

    // --- Utility Functions ---

    function escapeHtml(str) {
        if (!str) return '';
        // Basic HTML escaping for safe display
        return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    }

    /**
     * Updates the on-screen debug display
     * @param {string} message The primary status message (e.g., "Retrying...")
     * @param {string} color The CSS color for the message (e.g., "#f44336" for red)
     * @param {string} [debugUrl=''] Optional URL to display
     */
    function updateDebug(message, color, debugUrl = '') {
        if (!debugElement) return;
        let urlHtml = debugUrl ? `<p style="margin: 0; font-weight: 600;">URL:</p><p style="margin:0; word-break: break-all;">${debugUrl}</p>` : '';
        debugElement.innerHTML = `<p style="margin: 0; color: ${color}; font-weight: bold;">${escapeHtml(message)}</p>${urlHtml}`;
    }

    // --- API Fetch with Retry and Exponential Backoff ---

    /**
     * Fetches a URL with retry logic for status 202 (BGG queue) or general failure.
     * @param {string} url The URL to fetch.
     * @param {string} urlName A friendly name for the URL for debugging (e.g., "Collection API")
     * @param {number} [maxRetries=5] Maximum number of attempts.
     * @param {number} [initialDelay=1500] Initial delay in milliseconds for the first retry.
     * @returns {Promise<Response>} The successful response object.
     */
    async function fetchWithRetry(url, urlName, maxRetries = 5, initialDelay = 1500) {
        let delay = initialDelay;

        for (let i = 0; i < maxRetries; i++) {
            const attempt = i + 1;
            const statusMessage = `Attempt ${attempt}/${maxRetries} for ${urlName}...`;
            updateDebug(statusMessage, "#333", url);

            try {
                const resp = await fetch(url);

                if (resp.status === 200) {
                    updateDebug(`Success (200) for ${urlName}!`, "#4caf50", url);
                    return resp; // Success
                }
                
                if (resp.status === 202) {
                    // BGG API uses 202 (Accepted) when the request is queued. Need to retry.
                    if (i < maxRetries - 1) {
                        const retryMessage = `BGG queue (202) for ${urlName}. Retrying in ${delay / 1000}s...`;
                        console.log(retryMessage);
                        updateDebug(retryMessage, "#ff9800", url);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; // Exponential backoff
                        continue;
                    } else {
                        throw new Error(`API queue timeout (202). Failed after ${maxRetries} attempts.`);
                    }
                }
                // Other errors (4xx, 5xx)
                throw new Error(`API returned status ${resp.status}.`);

            } catch (e) { // Catches fetch network errors OR the errors thrown above
                console.error(`Attempt ${attempt} failed: ${e.message}`);
                if (i < maxRetries - 1) {
                    const errorMessage = `Fetch error: ${e.message}. Retrying in ${delay / 1000}s...`;
                    updateDebug(errorMessage, "#f44336", url);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2; // Exponential backoff
                } else {
                    // This is the last attempt, re-throw the final error
                    const finalError = new Error(`Failed ${urlName} after ${maxRetries} attempts. ${e.message}`);
                    updateDebug(finalError.message, "#f44336", url);
                    throw finalError;
                }
            }
        }
    }

    // --- Scroll Logic (unchanged) ---
    
    const scrollTopBtn = document.getElementById('scrollTopBtn');
    const scrollBottomBtn = document.getElementById('scrollBottomBtn');
    window.addEventListener('scroll', () => {
        const scrollThreshold = 300;
        const isNearTop = window.scrollY <= scrollThreshold;
        const isNearBottom = (window.innerHeight + window.scrollY) >= document.body.offsetHeight - scrollThreshold;

        scrollTopBtn.style.display = isNearTop ? 'none' : 'flex';
        scrollBottomBtn.style.display = isNearBottom ? 'none' : 'flex';
    });
    scrollTopBtn.onclick = () => window.scrollTo({ top: 0, behavior: 'smooth' });
    scrollBottomBtn.onclick = () => window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });

    // --- BGG API Utility Functions ---
    
    async function fetchCollectionRatings(username) {
        // FIX: Removed "&own=1" to match user request and fetch all rated games, not just owned games.
        const collectionUrl = `https://boardgamegeek.com/xmlapi2/collection?username=${encodeURIComponent(username)}&stats=1`;
        
        collectionRatingsMap.clear();

        try {
            const resp = await fetchWithRetry(collectionUrl, "Collection API");
            const xml = await resp.text();
            const parser = new window.DOMParser();
            const doc = parser.parseFromString(xml, 'text/xml');
            const items = Array.from(doc.querySelectorAll('item'));

            items.forEach(item => {
                const gameId = item.getAttribute('objectid');
                if (gameId) {
                    const thumbnail = item.querySelector('image')?.textContent || ''; 
                    const userRatingNode = item.querySelector('rating[value]');
                    const userRating = userRatingNode?.getAttribute('value') !== '0' ? userRatingNode?.getAttribute('value') : '';
                    const averageRatingNode = item.querySelector('average');
                    const avgRating = averageRatingNode ? parseFloat(averageRatingNode.getAttribute('value')).toFixed(2) : '';

                    collectionRatingsMap.set(gameId, {
                        userRating: userRating,
                        avgRating: avgRating,
                        thumbnail: thumbnail.startsWith('http') ? thumbnail : (thumbnail ? `https:${thumbnail}` : '')
                    });
                }
            });
        } catch (e) {
            console.error('Error fetching collection ratings:', e);
            // Re-throw the error to be caught by fetchPlays for global error display
            throw e;
        }
    }

    // --- Modal Logic (unchanged) ---

    function showPlayModal(play) {
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.style.display = 'flex';
        modal.onclick = (e) => {
            if (e.target === modal) document.body.removeChild(modal);
        };

        const content = document.createElement('div');
        content.className = 'modal-content';
        content.style.maxWidth = '430px';
        content.style.width = '96vw';
        content.style.boxSizing = 'border-box';
        content.style.padding = '1.2em';

        // Extract readable details from the XML node
        const gameName = play.querySelector('item')?.getAttribute('name') || 'Unknown';
        const date = play.getAttribute('date') || '';
        const location = play.getAttribute('location') || '';
        const comments = play.querySelector('comments')?.textContent || '';
        const players = Array.from(play.querySelectorAll('players player')).map(p => ({
            name: p.getAttribute('name') || '',
            username: p.getAttribute('username') || '',
            score: p.getAttribute('score') || '',
            win: p.getAttribute('win') || '',
            color: p.getAttribute('color') || ''
        }));
        
        let html = `<h2 style='font-size:1.2em; margin-bottom: 0.8em; color:#1976d2;'>${escapeHtml(gameName)} Play Details</h2>`;
        html += `<div class='modal-details-box'>`;
        html += `<b>Date:</b> ${date}<br>`;
        html += `<b>Location:</b> ${location || '<span style="color:#888">(not specified)</span>'}<br><hr style="margin: 0.5em 0; border-color:#eee;">`;
        if (comments) html += `<b>Comments:</b> ${escapeHtml(comments)}<br><hr style="margin: 0.5em 0; border-color:#eee;">`;
        if (players.length) {
            html += `<b>Players:</b><ul style='margin:0.3em 0 0.7em 1.5em; padding:0; list-style-type:disc;'>`;
            players.forEach(p => {
                html += `<li>${escapeHtml(p.name || p.username || 'Unknown')}${p.score ? ` (Score: ${p.score})` : ''}${p.win === '1' ? ' 🏆' : ''}${p.color ? ` [${escapeHtml(p.color)}]` : ''}</li>`;
            });
            html += `</ul>`;
        }
        html += `</div>`;
        html += `<button id='closePlayModalBtn' style='margin-top:1.5em;'>Close</button>`;

        content.innerHTML = html;
        modal.appendChild(content);
        document.body.appendChild(modal);

        document.getElementById('closePlayModalBtn').onclick = () => {
            document.body.removeChild(modal);
        };
    }
    
    // --- Main Data Fetching Logic ---

    async function fetchPlays(username) {
        // FIX: Disable button to prevent multiple clicks
        loadPlaysBtn.disabled = true;
        window._playRefs = []; 
        
        updateDebug(`Starting load for ${escapeHtml(username)}...`, "#333");

        // Show loading message for both collection and plays
        playList.innerHTML = `<div id="statusMessage" style="text-align:center; color:#888; font-size:1.1em; padding-top:2em;">Loading collection and plays for <b style="color:#a020f0;">${escapeHtml(username)}</b>...</div>`;
        
        if (!username) {
            playList.innerHTML = `<div id="statusMessage" style="text-align:center; color:#c00; padding-top:2em;">Please enter a BGG Username.</div>`;
            updateDebug("Error: Username is required.", "#f44336");
            loadPlaysBtn.disabled = false;
            return;
        }

        try {
            // Step 1: Fetch Collection Ratings (Uses fetchWithRetry)
            await fetchCollectionRatings(username);
            
            // Step 2: Fetch Plays List (Uses fetchWithRetry)
            const playsUrl = `https://boardgamegeek.com/xmlapi2/plays?username=${encodeURIComponent(username)}`;
            const playsResp = await fetchWithRetry(playsUrl, "Plays API");

            const xml = await playsResp.text();
            const parser = new window.DOMParser();
            const doc = parser.parseFromString(xml, 'text/xml');
            const items = Array.from(doc.querySelectorAll('play'));
            const totalPlays = doc.querySelector('plays')?.getAttribute('total') || items.length;

            if (items.length === 0) {
                playList.innerHTML = `<div id="statusMessage" style="text-align:center; color:#888; padding-top:2em;">No plays found for user <b style="color:#a020f0;">${escapeHtml(username)}</b>.</div>`;
                updateDebug(`Load Complete: Found 0 plays for ${escapeHtml(username)}.`, "#4caf50");
                return;
            }
            
            playList.innerHTML = ''; // Clear status message
            
            items.forEach((play) => {
                const date = play.getAttribute('date') || '';
                const location = play.getAttribute('location') || '';
                const gameName = play.querySelector('item')?.getAttribute('name') || 'Unknown';
                const gameId = play.querySelector('item')?.getAttribute('objectid') || '';
                const bggLink = gameId ? `https://boardgamegeek.com/boardgame/${gameId}` : '';
                
                // Step 3: Use data from the collection map
                const gameData = collectionRatingsMap.get(gameId) || {};
                const thumbnail = gameData.thumbnail || '';
                const userRating = gameData.userRating || '';
                const avgRating = gameData.avgRating || '';

                // Build Rating Badges HTML
                let ratingBadgesHtml = '';
                if (userRating) {
                    ratingBadgesHtml += `<span class='rating-badge user-rating'>Your Rating: ${userRating}</span>`;
                }
                if (avgRating) {
                    ratingBadgesHtml += `<span class='rating-badge avg-rating'>BGG Avg: ${avgRating}</span>`;
                }

                const card = document.createElement('div');
                card.className = 'play-card';
                
                // Store the XML node for modal
                window._playRefs.push(play); 
                const playIndex = window._playRefs.length - 1;

                card.innerHTML = `
                    <div class='play-header'>
                        ${thumbnail ?
                            `<img src='${thumbnail}' alt='${gameName} thumbnail' 
                                style='width:54px; height:54px; min-width:54px; border-radius:8px; margin-right:1em; object-fit:cover; box-shadow:0 1px 4px #0002;'>` : 
                            `<div style='width:54px; height:54px; min-width:54px; border-radius:8px; margin-right:1em; background:#ddd; display:flex; align-items:center; justify-content:center; font-size:0.7em; text-align:center; color:#666;'>No Thumb</div>`
                        }
                        <div>
                            <div class='play-title'>${escapeHtml(gameName)}</div>
                            <div style='margin-top:0.3em;'>${ratingBadgesHtml}</div>
                        </div>
                    </div>
                    <div class='play-details'>
                        <b>Date:</b> ${date}<br>
                        <b>Location:</b> ${location || 'N/A'}<br>
                        <div style='margin-top:0.7em; display:flex; gap:10px;'>
                            ${bggLink ?
                                `<a href='${bggLink}' target='_blank' style='color:#a020f0; text-decoration:none; font-weight:600; flex-shrink:0;'>View on BGG &rarr;</a>` : ''}
                            <button class='btn' style='background:#1976d2; color:#fff; font-size:0.9em; padding:0.4em 1em; border-radius:8px; border:none; box-shadow:none; cursor:pointer; flex-shrink:0;' onclick='showPlayModal(window._playRefs[${playIndex}])'>Full Details</button>
                        </div>
                    </div>
                `;
                playList.appendChild(card);
            });
            updateDebug(`Load Complete: Displaying ${items.length} of ${totalPlays} plays.`, "#4caf50");
        } catch (e) {
            playList.innerHTML = `<div id="statusMessage" style='text-align:center; color:#c00; padding-top:2em;'>Error: ${escapeHtml(e.message)}</div>`;
            // Debug display is already updated by the failing fetchWithRetry
        } finally {
            // FIX: Re-enable button after fetch is complete (success or fail)
            loadPlaysBtn.disabled = false;
        }
    }
    
    // --- Event Listeners ---
    
    loadPlaysBtn.onclick = () => {
        const username = usernameInput.value.trim();
        // The fetchPlays function now handles the "if (username)" check
        fetchPlays(username);
    };
    
    // Allow 'Enter' key to trigger load
    usernameInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            loadPlaysBtn.click();
        }
    });

    // DO NOT CALL fetchPlays on initial load per user request.
    </script>
</body>
</html>


