<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Collection</title>
    <style>
        /* --- Basic Setup & Fonts --- */
        :root {
            --card-bg: #ffffff;
            --page-bg: #f0f2f5;
            --text-color: #333;
            --primary-color: #007aff;
            --border-color: #e0e0e0;
            --shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            background-color: var(--page-bg);
            color: var(--text-color);
        }

        /* --- Main Layout --- */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
        }

        h1 {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 1.5rem;
        }

        /* --- Controls: Filters & Sorting --- */
        .controls {
            background-color: var(--card-bg);
            padding: 1.25rem;
            border-radius: 12px;
            box-shadow: var(--shadow);
            margin-bottom: 2rem;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.25rem;
        }

        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
                gap: 1rem;
                padding: 1rem;
            }
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #555;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-group input,
        .control-group select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--border-color);
            border-radius: 10px;
            font-size: 1rem;
            box-sizing: border-box;
            background-color: #fff;
            transition: all 0.2s ease;
            -webkit-appearance: none;
            appearance: none;
        }

        .control-group select {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23333' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            padding-right: 2.5rem;
        }

        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.15);
        }

        @media (max-width: 768px) {
            .control-group input,
            .control-group select {
                padding: 0.9rem;
                font-size: 16px; /* Prevents zoom on iOS */
            }
        }

        /* --- Dashboard Styles --- */
        .dashboard {
            background-color: var(--card-bg);
            border-radius: 12px;
            box-shadow: var(--shadow);
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .dashboard-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            cursor: pointer;
            user-select: none;
        }

        .dashboard-header:hover {
            opacity: 0.8;
        }

        .dashboard h3 {
            margin: 0;
            color: var(--primary-color);
            font-size: 1.2rem;
        }

        .dashboard-toggle {
            font-size: 1.5rem;
            color: var(--primary-color);
            transition: transform 0.3s ease;
            transform: rotate(-90deg);
        }

        .dashboard-toggle.expanded {
            transform: rotate(0deg);
        }

        .dashboard-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .dashboard-content.expanded {
            max-height: 2000px;
        }

        .dashboard-table {
            width: 100%;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .dashboard-table table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            table-layout: fixed;
        }

        .dashboard-table th {
            background-color: var(--primary-color);
            color: white;
            padding: 0.6rem 0.4rem;
            text-align: center;
            font-weight: 600;
            font-size: 0.75rem;
            white-space: nowrap;
            width: 12.5%;
        }

        .dashboard-table td {
            padding: 0.5rem 0.4rem;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            width: 12.5%;
        }

        .dashboard-table tr:hover {
            background-color: #f8f9fa;
        }

        .dashboard-table td:first-child {
            font-weight: 600;
            text-align: left;
            color: #555;
            width: auto;
            min-width: 150px;
        }
        
        .dashboard-table .section-header {
            background: #f0f2f5;
            font-weight: bold;
            padding: 0.8rem;
            text-align: left !important;
        }

        /* --- Game Cards Grid --- */
        #game-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 1.5rem;
            min-height: 200px;
        }

        @media (max-width: 768px) {
            #game-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
        }

        /* --- Individual Game Card --- */
        .game-card {
            background-color: var(--card-bg);
            border-radius: 12px;
            box-shadow: var(--shadow);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        @media (hover: hover) {
            .game-card:hover {
                transform: translateY(-5px);
                box-shadow: 0 8px 16px rgba(0, 0, 0, 0.12);
            }
        }

        @media (max-width: 768px) {
            .game-card {
                padding: 1.25rem;
            }
        }

        .game-card h2 {
            font-size: 1.4rem;
            margin: 0 0 1rem 0;
            color: var(--primary-color);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 0.75rem;
        }

        .game-card.simple-view h2 {
            margin: 0;
            border-bottom: none;
            padding-bottom: 0;
            cursor: pointer;
        }

        .game-card.simple-view h2:hover {
            opacity: 0.7;
        }

        .game-card.simple-view {
            padding: 1rem 1.5rem;
        }

        .game-card.simple-view .game-stats {
            display: none;
        }

        .game-card.expanded .game-stats {
            display: grid !important;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 2px solid var(--border-color);
        }

        .game-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }

        @media (max-width: 768px) {
            .game-stats {
                grid-template-columns: 1fr;
                gap: 0.6rem;
            }
        }

        .stat {
            display: flex;
            flex-direction: column;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #666;
            font-weight: 600;
            text-transform: uppercase;
            word-break: break-word;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: 500;
            word-break: break-word;
        }
        
        /* --- Message for No Results --- */
        #no-results {
            text-align: center;
            padding: 2rem;
            font-size: 1.2rem;
            color: #888;
            display: none; /* Hidden by default */
        }

        /* --- Modal Styles --- */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            overflow-y: auto;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-header h2 {
            margin: 0;
            color: var(--primary-color);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
            padding: 0;
        }

        .modal-close:hover {
            color: #333;
        }

        .field-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .field-checkbox {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 8px;
            transition: background-color 0.2s;
        }

        .field-checkbox:hover {
            background-color: #f5f5f5;
        }

        .field-checkbox input {
            cursor: pointer;
            width: 18px;
            height: 18px;
        }

        .field-checkbox label {
            cursor: pointer;
            flex: 1;
            margin: 0;
            font-weight: 500;
        }

        .modal-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            justify-content: flex-end;
        }

        .modal-buttons button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .modal-buttons .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .modal-buttons .btn-primary:hover {
            opacity: 0.9;
        }

        .modal-buttons .btn-secondary {
            background-color: #e0e0e0;
            color: #333;
        }

        .modal-buttons .btn-secondary:hover {
            background-color: #d0d0d0;
        }

        .game-name-link {
            cursor: pointer;
            color: var(--primary-color);
            text-decoration: none;
            transition: opacity 0.2s;
        }

        .game-name-link:hover {
            opacity: 0.7;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>My Game Collection</h1>
        
        <div id="record-count" style="text-align: center; font-size: 1.1rem; margin-bottom: 1rem; color: #666;">
            Loading...
        </div>

        <div style="text-align: center; margin-bottom: 1rem; display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
            <button id="view-toggle" style="padding: 0.75rem 2rem; font-size: 1rem; background-color: var(--primary-color); color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: 600;">
                Switch to Simple View
            </button>
            <button id="customize-fields-toggle" style="padding: 0.75rem 2rem; font-size: 1rem; background-color: var(--primary-color); color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: 600;">
                ⚙️ Customize Fields
            </button>
        </div>

        <div class="controls">
            <!-- Filter Controls -->
            <div class="control-group">
                <label for="filter-name">Filter by Name</label>
                <input type="text" id="filter-name" placeholder="e.g., Terraforming Mars">
            </div>
            <div class="control-group">
                <label for="filter-year">Filter by Year</label>
                <input type="number" id="filter-year" placeholder="e.g., 2016">
            </div>
            <div class="control-group">
                <label for="filter-players">Filter by Player Count</label>
                <input type="number" id="filter-players" placeholder="e.g., 2">
            </div>
            <div class="control-group">
                <label for="filter-best-players">Filter by Best Players</label>
                <input type="text" id="filter-best-players" placeholder="e.g., 3 or 3,4">
            </div>
            <div class="control-group">
                <label for="filter-rec-players">Filter by Rec Players</label>
                <input type="text" id="filter-rec-players" placeholder="e.g., 2,3,4">
            </div>
            <div class="control-group">
                <label for="filter-playtime">Filter by Play Time</label>
                <select id="filter-playtime">
                    <option value="">All</option>
                    <option value="0">0 min</option>
                    <option value="15">Up to 15 min</option>
                    <option value="30">Up to 30 min</option>
                    <option value="45">Up to 45 min</option>
                    <option value="60">Up to 60 min</option>
                    <option value="90">Up to 90 min</option>
                    <option value="120">Up to 120 min</option>
                    <option value="120+">120+ min</option>
                </select>
            </div>
            <div class="control-group">
                <label for="filter-weight-category">Filter by Weight Category</label>
                <select id="filter-weight-category">
                    <option value="">All</option>
                    <option value="light">Light</option>
                    <option value="medium-light">Medium Light</option>
                    <option value="medium">Medium</option>
                    <option value="medium-heavy">Medium Heavy</option>
                    <option value="heavy">Heavy</option>
                </select>
            </div>
            <div class="control-group">
                <label for="filter-status">Collection Status</label>
                <select id="filter-status">
                    <option value="">All</option>
                    <option value="own" selected>Own</option>
                    <option value="fortrade">For Trade</option>
                    <option value="want">Want</option>
                    <option value="wanttobuy">Want to Buy</option>
                    <option value="wanttoplay">Want to Play</option>
                    <option value="prevowned">Previously Owned</option>
                    <option value="preordered">Preordered</option>
                    <option value="wishlist">Wishlist</option>
                </select>
            </div>

            <!-- Sort Control -->
            <div class="control-group">
                <label for="sort-by">Sort By</label>
                <select id="sort-by">
                    <option value="objectname_asc">Name (A-Z)</option>
                    <option value="objectname_desc">Name (Z-A)</option>
                    <option value="rating_desc">My Rating (High-Low)</option>
                    <option value="rating_asc">My Rating (Low-High)</option>
                    <option value="baverage_desc">Weighted Average (High-Low)</option>
                    <option value="baverage_asc">Weighted Average (Low-High)</option>
                    <option value="average_desc">Avg Rating (High-Low)</option>
                    <option value="average_asc">Avg Rating (Low-High)</option>
                    <option value="rank_asc">Rank (Best-Worst)</option>
                    <option value="rank_desc">Rank (Worst-Best)</option>
                    <option value="numplays_desc">Plays (High-Low)</option>
                    <option value="numplays_asc">Plays (Low-High)</option>
                    <option value="weight_desc">Weight (High-Low)</option>
                    <option value="weight_asc">Weight (Low-High)</option>
                    <option value="playingtime_desc">Time (High-Low)</option>
                    <option value="playingtime_asc">Time (Low-High)</option>
                    <option value="yearpublished_desc">Year (New-Old)</option>
                    <option value="yearpublished_asc">Year (Old-New)</option>
                    <option value="invdate_desc">Date Added (New-Old)</option>
                    <option value="invdate_asc">Date Added (Old-New)</option>
                    <option value="pricepaid_desc">Price (High-Low)</option>
                    <option value="pricepaid_asc">Price (Low-High)</option>
                    <option value="customscore_desc">Custom Score (High-Low)</option>
                    <option value="customscore_asc">Custom Score (Low-High)</option>
                </select>
            </div>
        </div>

        <div class="dashboard">
            <div class="dashboard-header" onclick="toggleDashboard('counts')">
                <h3>Collection Dashboard - Counts</h3>
                <span class="dashboard-toggle" id="toggle-counts">▼</span>
            </div>
            <div class="dashboard-content collapsed" id="dashboard-counts">
                <div class="dashboard-table" id="dashboard-counts-content">
                    <!-- Dashboard counts table will be generated here -->
                </div>
            </div>
        </div>

        <div class="dashboard">
            <div class="dashboard-header" onclick="toggleDashboard('averages')">
                <h3>Collection Dashboard - Averages</h3>
                <span class="dashboard-toggle" id="toggle-averages">▼</span>
            </div>
            <div class="dashboard-content collapsed" id="dashboard-averages">
                <div class="dashboard-table" id="dashboard-averages-content">
                    <!-- Dashboard averages table will be generated here -->
                </div>
            </div>
        </div>

        <div id="game-grid"></div>
        <div id="no-results">No games match your criteria.</div>
    </div>

    <!-- Field Customization Modal -->
    <div id="field-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Customize Card Fields</h2>
                <button class="modal-close" onclick="closeFieldModal()">✕</button>
            </div>
            <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem; justify-content: center;">
                <button class="btn-secondary" onclick="selectAllFields()" style="padding: 0.5rem 1rem; font-size: 0.9rem;">Select All</button>
                <button class="btn-secondary" onclick="selectNoneFields()" style="padding: 0.5rem 1rem; font-size: 0.9rem;">Select None</button>
            </div>
            <div class="field-list" id="field-list">
                <!-- Checkboxes will be generated here -->
            </div>
            <div class="modal-buttons">
                <button class="btn-secondary" onclick="resetFieldDefaults()">Reset to Default</button>
                <button class="btn-secondary" onclick="closeFieldModal()">Cancel</button>
                <button class="btn-primary" onclick="saveFieldSettings()">Save Settings</button>
            </div>
        </div>
    </div>

    <script>
        let allGames = []; // To store all games from CSV
        const grid = document.getElementById('game-grid');
        const noResultsMsg = document.getElementById('no-results');
        
        // Filter inputs
        const nameFilter = document.getElementById('filter-name');
        const yearFilter = document.getElementById('filter-year');
        const playersFilter = document.getElementById('filter-players');
        const bestPlayersFilter = document.getElementById('filter-best-players');
        const recPlayersFilter = document.getElementById('filter-rec-players');
        const playtimeFilter = document.getElementById('filter-playtime');
        const weightCategoryFilter = document.getElementById('filter-weight-category');
        const statusFilter = document.getElementById('filter-status');
        
        // Sort select
        const sortBy = document.getElementById('sort-by');
        
        // View mode
        let isSimpleView = false;
        const viewToggle = document.getElementById('view-toggle');
        
        // Store dynamic weight thresholds globally
        let weightThresholds = null;
        
        // Field customization
        const defaultFields = ['myRating', 'numPlays', 'baverage', 'avgRating', 'rank', 'weight', 'avgWeight', 'playTime', 'players', 'bestPlayers', 'recPlayers', 'year', 'dateAdded', 'price', 'itemType', 'acquiredFrom', 'customScore'];
        let visibleFields = [...defaultFields];
        const customizeFieldsToggle = document.getElementById('customize-fields-toggle');
        const fieldModal = document.getElementById('field-modal');

        // Toggle dashboard visibility
        function toggleDashboard(type) {
            const content = document.getElementById(`dashboard-${type}`);
            const toggle = document.getElementById(`toggle-${type}`);
            content.classList.toggle('collapsed');
            content.classList.toggle('expanded');
            toggle.classList.toggle('expanded');
        }

        // Infinite scroll implementation
        let currentBatch = 0;
        let filteredGamesList = [];
        const BATCH_SIZE = 50;
        let isLoading = false;

        function setupInfiniteScroll() {
            window.addEventListener('scroll', () => {
                if (isLoading) return;
                
                const scrollPosition = window.innerHeight + window.scrollY;
                const threshold = document.documentElement.scrollHeight - 500;
                
                if (scrollPosition >= threshold) {
                    loadMoreGames();
                }
            });
        }

        function loadMoreGames() {
            if (currentBatch * BATCH_SIZE >= filteredGamesList.length) return;
            
            isLoading = true;
            const startIndex = currentBatch * BATCH_SIZE;
            const endIndex = Math.min(startIndex + BATCH_SIZE, filteredGamesList.length);
            
            for (let i = startIndex; i < endIndex; i++) {
                renderGameCard(filteredGamesList[i]);
            }
            
            currentBatch++;
            isLoading = false;
        }

        /**
         * Enhanced CSV parser that handles quoted fields and double quotes
         * @param {string} csvText - The CSV content as a string.
         * @returns {Array<Object>} - An array of game objects.
         */
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const headers = parseCSVLine(lines[0]);
            const games = [];
            
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue; // Skip empty lines
                const values = parseCSVLine(lines[i]);
                const game = {};
                headers.forEach((header, index) => {
                    let value = values[index] || '';
                    // Remove surrounding quotes and unescape internal quotes
                    value = value.replace(/^"(.*)"$/, '$1').replace(/""/g, '"');
                    game[header] = value;
                });
                
                // Ignore records where objectname is blank
                if (!game.objectname || game.objectname.trim() === '') {
                    continue;
                }
                
                games.push(game);
            }
            return games;
        }

        /**
         * Parse a single CSV line, respecting quoted fields
         */
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = line[i + 1];
                
                if (char === '"' && inQuotes && nextChar === '"') {
                    // Escaped quote
                    current += '"';
                    i++; // Skip next quote
                } else if (char === '"') {
                    // Toggle quote state
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    // Field separator
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }

        /**
         * Clean and format a value, returning "-" for empty/NaN values
         */
        function cleanValue(value, decimals = null) {
            if (!value || value === '' || value === 'NaN' || value === 'null' || value === 'undefined') {
                return '-';
            }
            if (decimals !== null) {
                const num = parseFloat(value);
                return isNaN(num) ? '-' : num.toFixed(decimals);
            }
            return value;
        }

        /**
         * Calculate custom score: wishlist=1 gives 5 points, then add inverse of wishlistpriority
         */
        function calculateCustomScore(game) {
            let score = 0;
            
            // If wishlist = 1, add 5 points
            if (game.wishlist === '1') {
                score += 5;
            }
            
            // Add inverse of wishlistpriority (lower priority = higher score)
            if (game.wishlistpriority && !isNaN(parseInt(game.wishlistpriority))) {
                const priority = parseInt(game.wishlistpriority);
                if (priority > 0) {
                    score += (1 / priority) * 10; // Scale it to make it meaningful
                }
            }
            
            return score;
        }

        /**
         * Check if player count matches best or rec players list
         */
        function matchesPlayerList(playerListStr, filterValues) {
            if (!playerListStr || playerListStr === '-') return false;
            
            // Parse the player list (could be "2,3,4,5" or just "3")
            const playerList = playerListStr.split(',').map(p => parseInt(p.trim())).filter(p => !isNaN(p));
            
            // Check if any filter value is in the player list
            return filterValues.some(filterVal => playerList.includes(filterVal));
        }

        /**
         * Calculate dynamic weight thresholds based on all games
         */
        function calculateWeightThresholds(games) {
            const validGames = games.filter(g => g.weight && !isNaN(parseFloat(g.weight)));
            const values = validGames.map(g => parseFloat(g.weight));
            
            if (values.length === 0) return null;
            
            const minWeight = Math.min(...values);
            const maxWeight = Math.max(...values);
            const range = maxWeight - minWeight;
            const step = range / 5;
            
            return {
                light: { min: minWeight, max: minWeight + step },
                mediumLight: { min: minWeight + step, max: minWeight + (step * 2) },
                medium: { min: minWeight + (step * 2), max: minWeight + (step * 3) },
                mediumHeavy: { min: minWeight + (step * 3), max: minWeight + (step * 4) },
                heavy: { min: minWeight + (step * 4), max: maxWeight }
            };
        }

        /**
         * Check if game weight falls into category
         */
        function isInWeightCategory(game, category) {
            if (!weightThresholds || !game.weight) return false;
            const weight = parseFloat(game.weight);
            if (isNaN(weight)) return false;
            
            const thresholds = weightThresholds[category];
            if (!thresholds) return false;
            
            return weight >= thresholds.min && weight <= thresholds.max;
        }

        // Field customization functions
        function openFieldModal() {
            const fieldList = document.getElementById('field-list');
            fieldList.innerHTML = '';
            
            const fieldLabels = {
                myRating: 'My Rating',
                numPlays: 'Number of Plays',
                baverage: 'Weighted Average',
                avgRating: 'Avg Rating',
                rank: 'Rank',
                weight: 'Weight',
                avgWeight: 'Avg Weight',
                playTime: 'Play Time',
                players: 'Players',
                bestPlayers: 'Best Players',
                recPlayers: 'Recommended Players',
                year: 'Year Published',
                dateAdded: 'Date Added',
                price: 'Price',
                itemType: 'Item Type',
                acquiredFrom: 'Acquired From',
                customScore: 'Custom Score'
            };
            
            defaultFields.forEach(field => {
                const label = fieldLabels[field];
                const isChecked = visibleFields.includes(field);
                
                const checkboxDiv = document.createElement('div');
                checkboxDiv.className = 'field-checkbox';
                checkboxDiv.innerHTML = `
                    <input type="checkbox" id="field-${field}" ${isChecked ? 'checked' : ''}>
                    <label for="field-${field}">${label}</label>
                `;
                fieldList.appendChild(checkboxDiv);
            });
            
            fieldModal.classList.add('active');
        }

        function closeFieldModal() {
            fieldModal.classList.remove('active');
        }

        function selectAllFields() {
            defaultFields.forEach(field => {
                const checkbox = document.getElementById(`field-${field}`);
                if (checkbox) {
                    checkbox.checked = true;
                }
            });
        }

        function selectNoneFields() {
            defaultFields.forEach(field => {
                const checkbox = document.getElementById(`field-${field}`);
                if (checkbox) {
                    checkbox.checked = false;
                }
            });
        }

        function saveFieldSettings() {
            visibleFields = [];
            defaultFields.forEach(field => {
                const checkbox = document.getElementById(`field-${field}`);
                if (checkbox && checkbox.checked) {
                    visibleFields.push(field);
                }
            });
            
            // Save to localStorage
            localStorage.setItem('visibleFields', JSON.stringify(visibleFields));
            
            closeFieldModal();
            applyFiltersAndSort(); // Re-render cards
        }

        function resetFieldDefaults() {
            visibleFields = [...defaultFields];
            localStorage.removeItem('visibleFields');
            closeFieldModal();
            openFieldModal(); // Reopen to show reset state
        }

        function loadFieldSettings() {
            const saved = localStorage.getItem('visibleFields');
            if (saved) {
                visibleFields = JSON.parse(saved);
            }
        }

        function renderDashboard(games) {
            renderCountsDashboard(games);
            renderAveragesDashboard(games);
        }

        function renderCountsDashboard(games) {
            const dashboardContent = document.getElementById('dashboard-counts-content');
            
            // Helper function to count games in ranges
            function countInRange(games, field, ranges) {
                return ranges.map(range => {
                    return games.filter(game => {
                        const value = parseFloat(game[field]);
                        if (isNaN(value)) return false;
                        
                        if (range.min !== undefined && range.max !== undefined) {
                            return value >= range.min && value < range.max;
                        } else if (range.min !== undefined) {
                            return value >= range.min;
                        } else if (range.max !== undefined) {
                            return value < range.max;
                        }
                        return false;
                    }).length;
                });
            }

            // Rating ranges
            const ratingRanges = [
                {label: 'Under 5', min: 0, max: 5},
                {label: '5', min: 5, max: 6},
                {label: '6', min: 6, max: 7},
                {label: '7', min: 7, max: 8},
                {label: '8', min: 8, max: 9},
                {label: '9', min: 9, max: 10},
                {label: '10', min: 10, max: 11}
            ];

            // Play count ranges
            const playCounts = games.filter(g => g.numplays).map(g => parseInt(g.numplays) || 0);
            const playRanges = [
                {label: '0', count: games.filter(g => !g.numplays || parseInt(g.numplays) === 0).length},
                {label: '1+', count: playCounts.filter(p => p >= 1).length},
                {label: '2+', count: playCounts.filter(p => p >= 2).length},
                {label: '5+', count: playCounts.filter(p => p >= 5).length},
                {label: '10+', count: playCounts.filter(p => p >= 10).length},
                {label: '25+', count: playCounts.filter(p => p >= 25).length},
                {label: '50+', count: playCounts.filter(p => p >= 50).length},
                {label: '100+', count: playCounts.filter(p => p >= 100).length}
            ];

            // Rank ranges
            const rankRanges = [
                {label: 'Top 10', count: games.filter(g => parseInt(g.rank) > 0 && parseInt(g.rank) <= 10).length},
                {label: 'Top 25', count: games.filter(g => parseInt(g.rank) > 0 && parseInt(g.rank) <= 25).length},
                {label: 'Top 100', count: games.filter(g => parseInt(g.rank) > 0 && parseInt(g.rank) <= 100).length},
                {label: 'Top 250', count: games.filter(g => parseInt(g.rank) > 0 && parseInt(g.rank) <= 250).length},
                {label: 'Top 500', count: games.filter(g => parseInt(g.rank) > 0 && parseInt(g.rank) <= 500).length},
                {label: 'Top 1000', count: games.filter(g => parseInt(g.rank) > 0 && parseInt(g.rank) <= 1000).length},
                {label: 'Top 10,000', count: games.filter(g => parseInt(g.rank) > 0 && parseInt(g.rank) <= 10000).length}
            ];

            // Weight ranges
            const weightRanges = [
                {label: '0', min: 0, max: 1},
                {label: '1', min: 1, max: 2},
                {label: '2', min: 2, max: 3},
                {label: '3', min: 3, max: 4},
                {label: '4', min: 4, max: 5},
                {label: '5', min: 5, max: 10}
            ];

            // Time ranges
            const timeRanges = [
                {label: '0', count: games.filter(g => parseInt(g.playingtime) === 0).length},
                {label: '15 Min', count: games.filter(g => parseInt(g.playingtime) > 0 && parseInt(g.playingtime) <= 15).length},
                {label: '30 Min', count: games.filter(g => parseInt(g.playingtime) > 15 && parseInt(g.playingtime) <= 30).length},
                {label: '45 Min', count: games.filter(g => parseInt(g.playingtime) > 30 && parseInt(g.playingtime) <= 45).length},
                {label: '60 Min', count: games.filter(g => parseInt(g.playingtime) > 45 && parseInt(g.playingtime) <= 60).length},
                {label: '90 Min', count: games.filter(g => parseInt(g.playingtime) > 60 && parseInt(g.playingtime) <= 90).length},
                {label: '120 Min', count: games.filter(g => parseInt(g.playingtime) > 90 && parseInt(g.playingtime) <= 120).length},
                {label: '120+ Min', count: games.filter(g => parseInt(g.playingtime) > 120).length}
            ];

            // Player count ranges
            const playerRanges = Array.from({length: 8}, (_, i) => {
                const playerCount = i + 1;
                return {
                    label: playerCount.toString(),
                    count: games.filter(g => {
                        const min = parseInt(g.minplayers);
                        const max = parseInt(g.maxplayers);
                        return !isNaN(min) && !isNaN(max) && min <= playerCount && max >= playerCount;
                    }).length
                };
            });

            // Year ranges
            const currentYear = new Date().getFullYear();
            const yearRanges = [
                {label: 'This Year', count: games.filter(g => parseInt(g.yearpublished) === currentYear).length},
                {label: 'Last Year', count: games.filter(g => parseInt(g.yearpublished) === currentYear - 1).length},
                {label: 'Last 3', count: games.filter(g => parseInt(g.yearpublished) >= currentYear - 2).length},
                {label: 'Last 5', count: games.filter(g => parseInt(g.yearpublished) >= currentYear - 4).length},
                {label: 'Last 10', count: games.filter(g => parseInt(g.yearpublished) >= currentYear - 9).length},
                {label: 'Last 25', count: games.filter(g => parseInt(g.yearpublished) >= currentYear - 24).length},
                {label: 'Older', count: games.filter(g => parseInt(g.yearpublished) < currentYear - 24).length}
            ];

            // Status counts
            const statusCounts = {
                own: games.filter(g => g.own === '1').length,
                fortrade: games.filter(g => g.fortrade === '1').length,
                want: games.filter(g => g.want === '1').length,
                wanttobuy: games.filter(g => g.wanttobuy === '1').length,
                wanttoplay: games.filter(g => g.wanttoplay === '1').length,
                prevowned: games.filter(g => g.prevowned === '1').length,
                preordered: games.filter(g => g.preordered === '1').length,
                wishlist: games.filter(g => g.wishlist === '1').length
            };

            // Price ranges - based on current filtered games
            const priceRanges = [
                {label: 'Zero', count: games.filter(g => !g.pricepaid || parseFloat(g.pricepaid) === 0).length},
                {label: 'Max 5', count: games.filter(g => parseFloat(g.pricepaid) > 0 && parseFloat(g.pricepaid) <= 5).length},
                {label: 'Max 10', count: games.filter(g => parseFloat(g.pricepaid) > 5 && parseFloat(g.pricepaid) <= 10).length},
                {label: 'Max 25', count: games.filter(g => parseFloat(g.pricepaid) > 10 && parseFloat(g.pricepaid) <= 25).length},
                {label: 'Max 50', count: games.filter(g => parseFloat(g.pricepaid) > 25 && parseFloat(g.pricepaid) <= 50).length},
                {label: 'Max 75', count: games.filter(g => parseFloat(g.pricepaid) > 50 && parseFloat(g.pricepaid) <= 75).length},
                {label: 'Max 100', count: games.filter(g => parseFloat(g.pricepaid) > 75 && parseFloat(g.pricepaid) <= 100).length},
                {label: 'Max 100+', count: games.filter(g => parseFloat(g.pricepaid) > 100).length}
            ];

            // Date added ranges - based on current filtered games
            const now = new Date();
            const dateRanges = [
                {label: 'Last 30 days', count: games.filter(g => g.invdate && (now - new Date(g.invdate)) / (1000*60*60*24) <= 30).length},
                {label: 'Last Quarter', count: games.filter(g => g.invdate && (now - new Date(g.invdate)) / (1000*60*60*24) <= 90).length},
                {label: 'Last Half Year', count: games.filter(g => g.invdate && (now - new Date(g.invdate)) / (1000*60*60*24) <= 180).length},
                {label: 'Last Year', count: games.filter(g => g.invdate && (now - new Date(g.invdate)) / (1000*60*60*24*365) <= 1).length},
                {label: 'Last 2 years', count: games.filter(g => g.invdate && (now - new Date(g.invdate)) / (1000*60*60*24*365) <= 2).length},
                {label: 'Last 5 years', count: games.filter(g => g.invdate && (now - new Date(g.invdate)) / (1000*60*60*24*365) <= 5).length},
                {label: 'Last 10 years', count: games.filter(g => g.invdate && (now - new Date(g.invdate)) / (1000*60*60*24*365) <= 10).length},
                {label: 'No Date', count: games.filter(g => !g.invdate).length}
            ];
            // Build HTML
            let html = '<table>';
            
            // Ratings
            html += '<tr><td colspan="8" class="section-header">RATINGS (based on filter)</td></tr>';
            html += '<tr><th></th><th>Under 5</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr>';
            html += '<tr><td>My Rating</td>' + countInRange(games, 'rating', ratingRanges).map(c => `<td>${c}</td>`).join('') + '</tr>';
            html += '<tr><td>Weighted Average</td>' + countInRange(games, 'baverage', ratingRanges).map(c => `<td>${c}</td>`).join('') + '</tr>';
            html += '<tr><td>Avg Rating</td>' + countInRange(games, 'average', ratingRanges).map(c => `<td>${c}</td>`).join('') + '</tr>';
            
            // Plays
            html += '<tr><td colspan="8" class="section-header">PLAYS (based on filter)</td></tr>';
            html += '<tr><th></th><th>0</th><th>1+</th><th>2+</th><th>5+</th><th>10+</th><th>25+</th><th>50+</th><th>100+</th></tr>';
            html += '<tr><td>Plays</td>' + playRanges.map(r => `<td>${r.count}</td>`).join('') + '</tr>';
            
            // Rank
            html += '<tr><td colspan="8" class="section-header">RANK (based on filter)</td></tr>';
            html += '<tr><th></th><th>Top 10</th><th>Top 25</th><th>Top 100</th><th>Top 250</th><th>Top 500</th><th>Top 1000</th><th>Top 10,000</th></tr>';
            html += '<tr><td>Rank</td>' + rankRanges.map(r => `<td>${r.count}</td>`).join('') + '</tr>';
            
            // Weight
            html += '<tr><td colspan="8" class="section-header">WEIGHT (based on filter)</td></tr>';
            html += '<tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th></th></tr>';
            html += '<tr><td>Weight</td>' + countInRange(games, 'weight', weightRanges).map(c => `<td>${c}</td>`).join('') + '<td></td></tr>';
            html += '<tr><td>Avg Weight</td>' + countInRange(games, 'avgweight', weightRanges).map(c => `<td>${c}</td>`).join('') + '<td></td></tr>';
            
            // Play Time
            html += '<tr><td colspan="8" class="section-header">PLAY TIME (based on filter)</td></tr>';
            html += '<tr><th></th><th>0</th><th>15 Min</th><th>30 Min</th><th>45 Min</th><th>60 Min</th><th>90 Min</th><th>120 Min</th><th>120+</th></tr>';
            html += '<tr><td>Play Time</td>' + timeRanges.map(r => `<td>${r.count}</td>`).join('') + '</tr>';
            
            // Players
            html += '<tr><td colspan="8" class="section-header">PLAYERS (based on filter)</td></tr>';
            html += '<tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr>';
            html += '<tr><td>Players</td>' + playerRanges.map(r => `<td>${r.count}</td>`).join('') + '</tr>';
            
            // Years
            html += '<tr><td colspan="8" class="section-header">YEARS (based on filter)</td></tr>';
            html += '<tr><th></th><th>This Year</th><th>Last Year</th><th>Last 3</th><th>Last 5</th><th>Last 10</th><th>Last 25</th><th>Older</th></tr>';
            html += '<tr><td>Years</td>' + yearRanges.map(r => `<td>${r.count}</td>`).join('') + '</tr>';
            
            // Status
            html += '<tr><td colspan="8" class="section-header">STATUS (based on filter)</td></tr>';
            html += '<tr><th></th><th>own</th><th>fortrade</th><th>want</th><th>wanttobuy</th><th>wanttoplay</th><th>prevowned</th><th>preordered</th><th>wishlist</th></tr>';
            html += '<tr><td>Status</td><td>' + statusCounts.own + '</td><td>' + statusCounts.fortrade + '</td><td>' + statusCounts.want + '</td><td>' + statusCounts.wanttobuy + '</td><td>' + statusCounts.wanttoplay + '</td><td>' + statusCounts.prevowned + '</td><td>' + statusCounts.preordered + '</td><td>' + statusCounts.wishlist + '</td></tr>';
            
            // Custom Score
            html += '<tr><td colspan="8" class="section-header">CUSTOM SCORE (based on filter)</td></tr>';
            const customScores = games.map(g => calculateCustomScore(g));
            const avgCustomScore = customScores.length > 0 ? (customScores.reduce((a, b) => a + b, 0) / customScores.length).toFixed(2) : '0';
            const maxCustomScore = customScores.length > 0 ? Math.max(...customScores).toFixed(2) : '0';
            const minCustomScore = customScores.length > 0 ? Math.min(...customScores).toFixed(2) : '0';
            html += '<tr><th></th><th>Count</th><th>Average</th><th>Min</th><th>Max</th><th></th><th></th><th></th></tr>';
            html += '<tr><td>Custom Score</td><td>' + games.length + '</td><td>' + avgCustomScore + '</td><td>' + minCustomScore + '</td><td>' + maxCustomScore + '</td><td></td><td></td><td></td></tr>';
            
            // Price
            html += '<tr><td colspan="8" class="section-header">PRICE (based on filter)</td></tr>';
            html += '<tr><th></th><th>Zero</th><th>Max 5</th><th>Max 10</th><th>Max 25</th><th>Max 50</th><th>Max 75</th><th>Max 100</th><th>Max 100+</th></tr>';
            html += '<tr><td>Price</td>' + priceRanges.map(r => `<td>${r.count}</td>`).join('') + '</tr>';
            
            // Date Added
            html += '<tr><td colspan="8" class="section-header">DATE ADDED (based on filter)</td></tr>';
            html += '<tr><th></th><th>Last 30 days</th><th>Last Quarter</th><th>Last Half Year</th><th>Last Year</th><th>Last 2 years</th><th>Last 5 years</th><th>Last 10 years</th><th>No Date</th></tr>';
            html += '<tr><td>Date Added</td>' + dateRanges.map(r => `<td>${r.count}</td>`).join('') + '</tr>';
            
            html += '</table>';
            
            dashboardContent.innerHTML = html;
        }

        function renderAveragesDashboard(games) {
            const dashboardContent = document.getElementById('dashboard-averages-content');
            
            // Helper function to calculate average
            function calcAvg(games, field) {
                const validGames = games.filter(g => g[field] && !isNaN(parseFloat(g[field])));
                if (validGames.length === 0) return '-';
                const sum = validGames.reduce((acc, g) => acc + parseFloat(g[field]), 0);
                return (sum / validGames.length).toFixed(2);
            }

            // Helper function to calculate median
            function calcMedian(games, field) {
                const validValues = games.filter(g => g[field] && !isNaN(parseFloat(g[field])))
                    .map(g => parseFloat(g[field]))
                    .sort((a, b) => a - b);
                if (validValues.length === 0) return '-';
                const mid = Math.floor(validValues.length / 2);
                if (validValues.length % 2 === 0) {
                    return ((validValues[mid - 1] + validValues[mid]) / 2).toFixed(2);
                }
                return validValues[mid].toFixed(2);
            }

            // Helper function to calculate mode
            function calcMode(games, field) {
                const validValues = games.filter(g => g[field] && !isNaN(parseFloat(g[field])))
                    .map(g => parseFloat(g[field]));
                if (validValues.length === 0) return '-';
                
                const frequency = {};
                let maxFreq = 0;
                let mode = null;
                
                validValues.forEach(val => {
                    frequency[val] = (frequency[val] || 0) + 1;
                    if (frequency[val] > maxFreq) {
                        maxFreq = frequency[val];
                        mode = val;
                    }
                });
                
                return mode.toFixed(2);
            }

            // Build HTML for averages
            let html = '<table>';
            
            html += '<tr><th>Category</th><th>Average</th><th>Median</th><th>Mode</th><th>Min</th><th>Max</th><th>Count</th><th></th></tr>';
            
            // Ratings
            html += '<tr><td colspan="8" class="section-header">RATINGS</td></tr>';
            
            ['rating', 'baverage', 'average'].forEach(field => {
                const validGames = games.filter(g => g[field] && !isNaN(parseFloat(g[field])));
                const values = validGames.map(g => parseFloat(g[field]));
                const label = field === 'rating' ? 'My Rating' : field === 'baverage' ? 'Weighted Average' : 'Avg Rating';
                
                html += `<tr>
                    <td>${label}</td>
                    <td>${calcAvg(games, field)}</td>
                    <td>${calcMedian(games, field)}</td>
                    <td>${calcMode(games, field)}</td>
                    <td>${values.length > 0 ? Math.min(...values).toFixed(2) : '-'}</td>
                    <td>${values.length > 0 ? Math.max(...values).toFixed(2) : '-'}</td>
                    <td>${validGames.length}</td>
                    <td></td>
                </tr>`;
            });
            
            // Plays
            html += '<tr><td colspan="8" class="section-header">PLAYS</td></tr>';
            const validPlays = games.filter(g => g.numplays && !isNaN(parseInt(g.numplays)));
            const playValues = validPlays.map(g => parseInt(g.numplays));
            html += `<tr>
                <td>Num Plays</td>
                <td>${calcAvg(games, 'numplays')}</td>
                <td>${calcMedian(games, 'numplays')}</td>
                <td>${calcMode(games, 'numplays')}</td>
                <td>${playValues.length > 0 ? Math.min(...playValues) : '-'}</td>
                <td>${playValues.length > 0 ? Math.max(...playValues) : '-'}</td>
                <td>${validPlays.length}</td>
                <td></td>
            </tr>`;
            
            // Weight
            html += '<tr><td colspan="8" class="section-header">WEIGHT</td></tr>';
            ['weight', 'avgweight'].forEach(field => {
                const validGames = games.filter(g => g[field] && !isNaN(parseFloat(g[field])));
                const values = validGames.map(g => parseFloat(g[field]));
                const label = field === 'weight' ? 'Weight' : 'Avg Weight';
                
                html += `<tr>
                    <td>${label}</td>
                    <td>${calcAvg(games, field)}</td>
                    <td>${calcMedian(games, field)}</td>
                    <td>${calcMode(games, field)}</td>
                    <td>${values.length > 0 ? Math.min(...values).toFixed(2) : '-'}</td>
                    <td>${values.length > 0 ? Math.max(...values).toFixed(2) : '-'}</td>
                    <td>${validGames.length}</td>
                    <td></td>
                </tr>`;
            });
            
            // Weight Categories - Dynamic based on filtered games
            html += '<tr><td colspan="8" class="section-header">WEIGHT CATEGORIES (Dynamic based on filter)</td></tr>';
            
            // Calculate dynamic weight categories for both weight and avgweight
            ['weight', 'avgweight'].forEach(field => {
                const validGames = games.filter(g => g[field] && !isNaN(parseFloat(g[field])));
                const values = validGames.map(g => parseFloat(g[field]));
                
                if (values.length > 0) {
                    const minWeight = Math.min(...values);
                    const maxWeight = Math.max(...values);
                    const range = maxWeight - minWeight;
                    
                    // Divide range into 5 categories
                    const step = range / 5;
                    const threshold1 = minWeight + step;
                    const threshold2 = minWeight + (step * 2);
                    const threshold3 = minWeight + (step * 3);
                    const threshold4 = minWeight + (step * 4);
                    
                    // Show ranges in header
                    const label = field === 'weight' ? 'Weight' : 'Avg Weight';
                    html += `<tr><th>${label}</th>
                             <th>Light<br/>(${minWeight.toFixed(2)}-${threshold1.toFixed(2)})</th>
                             <th>Med Light<br/>(${threshold1.toFixed(2)}-${threshold2.toFixed(2)})</th>
                             <th>Medium<br/>(${threshold2.toFixed(2)}-${threshold3.toFixed(2)})</th>
                             <th>Med Heavy<br/>(${threshold3.toFixed(2)}-${threshold4.toFixed(2)})</th>
                             <th>Heavy<br/>(${threshold4.toFixed(2)}-${maxWeight.toFixed(2)})</th>
                             <th></th><th></th></tr>`;
                    
                    const categories = [
                        validGames.filter(g => parseFloat(g[field]) >= minWeight && parseFloat(g[field]) < threshold1).length,
                        validGames.filter(g => parseFloat(g[field]) >= threshold1 && parseFloat(g[field]) < threshold2).length,
                        validGames.filter(g => parseFloat(g[field]) >= threshold2 && parseFloat(g[field]) < threshold3).length,
                        validGames.filter(g => parseFloat(g[field]) >= threshold3 && parseFloat(g[field]) < threshold4).length,
                        validGames.filter(g => parseFloat(g[field]) >= threshold4 && parseFloat(g[field]) <= maxWeight).length
                    ];
                    
                    html += '<tr><td></td>';
                    categories.forEach(count => {
                        html += `<td>${count}</td>`;
                    });
                    html += '<td></td><td></td></tr>';
                } else {
                    const label = field === 'weight' ? 'Weight' : 'Avg Weight';
                    html += '<tr><th>' + label + '</th><th>Light</th><th>Med Light</th><th>Medium</th><th>Med Heavy</th><th>Heavy</th><th></th><th></th></tr>';
                    html += '<tr><td></td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td><td></td></tr>';
                }
            });
            
            // Play Time
            html += '<tr><td colspan="8" class="section-header">PLAY TIME</td></tr>';
            const validTime = games.filter(g => g.playingtime && !isNaN(parseInt(g.playingtime)));
            const timeValues = validTime.map(g => parseInt(g.playingtime));
            html += `<tr>
                <td>Play Time (min)</td>
                <td>${calcAvg(games, 'playingtime')}</td>
                <td>${calcMedian(games, 'playingtime')}</td>
                <td>${calcMode(games, 'playingtime')}</td>
                <td>${timeValues.length > 0 ? Math.min(...timeValues) : '-'}</td>
                <td>${timeValues.length > 0 ? Math.max(...timeValues) : '-'}</td>
                <td>${validTime.length}</td>
                <td></td>
            </tr>`;
            
            // Players
            html += '<tr><td colspan="8" class="section-header">PLAYERS</td></tr>';
            ['minplayers', 'maxplayers'].forEach(field => {
                const validGames = games.filter(g => g[field] && !isNaN(parseInt(g[field])));
                const values = validGames.map(g => parseInt(g[field]));
                const label = field === 'minplayers' ? 'Min Players' : 'Max Players';
                
                html += `<tr>
                    <td>${label}</td>
                    <td>${calcAvg(games, field)}</td>
                    <td>${calcMedian(games, field)}</td>
                    <td>${calcMode(games, field)}</td>
                    <td>${values.length > 0 ? Math.min(...values) : '-'}</td>
                    <td>${values.length > 0 ? Math.max(...values) : '-'}</td>
                    <td>${validGames.length}</td>
                    <td></td>
                </tr>`;
            });
            
            // Year Published
            html += '<tr><td colspan="8" class="section-header">YEAR PUBLISHED</td></tr>';
            const validYear = games.filter(g => g.yearpublished && !isNaN(parseInt(g.yearpublished)));
            const yearValues = validYear.map(g => parseInt(g.yearpublished));
            html += `<tr>
                <td>Year Published</td>
                <td>${calcAvg(games, 'yearpublished')}</td>
                <td>${calcMedian(games, 'yearpublished')}</td>
                <td>${calcMode(games, 'yearpublished')}</td>
                <td>${yearValues.length > 0 ? Math.min(...yearValues) : '-'}</td>
                <td>${yearValues.length > 0 ? Math.max(...yearValues) : '-'}</td>
                <td>${validYear.length}</td>
                <td></td>
            </tr>`;
            
            // Rank
            html += '<tr><td colspan="8" class="section-header">RANK</td></tr>';
            const validRank = games.filter(g => g.rank && !isNaN(parseInt(g.rank)) && parseInt(g.rank) > 0);
            const rankValues = validRank.map(g => parseInt(g.rank));
            html += `<tr>
                <td>Rank</td>
                <td>${calcAvg(games, 'rank')}</td>
                <td>${calcMedian(games, 'rank')}</td>
                <td>${calcMode(games, 'rank')}</td>
                <td>${rankValues.length > 0 ? Math.min(...rankValues) : '-'}</td>
                <td>${rankValues.length > 0 ? Math.max(...rankValues) : '-'}</td>
                <td>${validRank.length}</td>
                <td></td>
            </tr>`;
            
            // Price
            html += '<tr><td colspan="8" class="section-header">PRICE</td></tr>';
            const validPrice = games.filter(g => g.pricepaid && !isNaN(parseFloat(g.pricepaid)) && parseFloat(g.pricepaid) > 0);
            const priceValues = validPrice.map(g => parseFloat(g.pricepaid));
            html += `<tr>
                <td>Price Paid</td>
                <td>${validPrice.length > 0 ? '$' + calcAvg(games, 'pricepaid') : '-'}</td>
                <td>${validPrice.length > 0 ? '$' + calcMedian(games, 'pricepaid') : '-'}</td>
                <td>${validPrice.length > 0 ? '$' + calcMode(games, 'pricepaid') : '-'}</td>
                <td>${priceValues.length > 0 ? '$' + Math.min(...priceValues).toFixed(2) : '-'}</td>
                <td>${priceValues.length > 0 ? '$' + Math.max(...priceValues).toFixed(2) : '-'}</td>
                <td>${validPrice.length}</td>
                <td></td>
            </tr>`;
            
            // Total Price
            const totalPrice = priceValues.reduce((sum, val) => sum + val, 0);
            html += `<tr>
                <td>Total Price Paid</td>
                <td colspan="6">${priceValues.length > 0 ? '$' + totalPrice.toFixed(2) : '-'}</td>
                <td></td>
            </tr>`;
            
            html += '</table>';
            
            dashboardContent.innerHTML = html;
        }

        function renderGames(games) {
            grid.innerHTML = ''; // Clear existing cards
            
            // Update record count
            const recordCount = document.getElementById('record-count');
            recordCount.textContent = `Showing ${Math.min(BATCH_SIZE, games.length)} of ${games.length} games (${allGames.length} total)`;
            
            // Render dashboard
            renderDashboard(games);
            
            if (games.length === 0) {
                noResultsMsg.style.display = 'block';
            } else {
                noResultsMsg.style.display = 'none';
            }

            // Setup infinite scroll
            filteredGamesList = games;
            currentBatch = 0;
            
            // Render first batch
            loadMoreGames();
            
            // Update count as more loads
            if (games.length > BATCH_SIZE) {
                setTimeout(() => {
                    const displayed = Math.min(currentBatch * BATCH_SIZE, games.length);
                    recordCount.textContent = `Showing ${displayed} of ${games.length} games (${allGames.length} total)`;
                }, 100);
            }
        }

        function renderGameCard(game) {
            const card = document.createElement('div');
            card.className = 'game-card';
            if (isSimpleView) {
                card.classList.add('simple-view');
            }
            
            // Safely access properties and provide defaults using cleanValue
            const myRating = cleanValue(game.rating, 1);
            const bayesAvg = cleanValue(game.baverage, 2);
            const avgRating = cleanValue(game.average, 2);
            const rank = cleanValue(game.rank);
            const numPlays = cleanValue(game.numplays) === '-' ? '0' : cleanValue(game.numplays);
            const weight = cleanValue(game.weight, 2);
            const avgWeight = cleanValue(game.avgweight, 2);
            const playTime = cleanValue(game.playingtime);
            const minPlayers = cleanValue(game.minplayers);
            const maxPlayers = cleanValue(game.maxplayers);
            const year = cleanValue(game.yearpublished);
            const invDate = cleanValue(game.invdate);
            
            let price = '-';
            if (game.pricepaid) {
                const priceNum = parseFloat(game.pricepaid);
                if (!isNaN(priceNum) && priceNum > 0) {
                    price = `$${priceNum.toFixed(2)}`;
                }
            }
            
            const recPlayers = cleanValue(game.bggrecplayers);
            const bestPlayers = cleanValue(game.bggbestplayers);
            const itemType = cleanValue(game.itemtype);
            const acquiredFrom = cleanValue(game.acquiredfrom);
            const customScore = calculateCustomScore(game).toFixed(2);
            
            // Collection status
            const statusFlags = [];
            if (game.own === '1') statusFlags.push('Own');
            if (game.fortrade === '1') statusFlags.push('For Trade');
            if (game.want === '1') statusFlags.push('Want');
            if (game.wanttobuy === '1') statusFlags.push('Want to Buy');
            if (game.wanttoplay === '1') statusFlags.push('Want to Play');
            if (game.prevowned === '1') statusFlags.push('Prev Owned');
            if (game.preordered === '1') statusFlags.push('Preordered');
            if (game.wishlist === '1') statusFlags.push('Wishlist');
            const statusText = statusFlags.join(', ') || '-';

            card.innerHTML = `
                <h2><a href="https://boardgamegeek.com/boardgame/${game.objectid}" target="_blank" style="color: inherit; text-decoration: none;">${cleanValue(game.objectname) === '-' ? 'Unnamed Game' : game.objectname}</a></h2>
                    <div class="game-stats">
                        ${visibleFields.includes('myRating') ? `<div class="stat">
                            <span class="stat-label">My Rating</span>
                            <span class="stat-value">${myRating}</span>
                        </div>` : ''}
                        ${visibleFields.includes('numPlays') ? `<div class="stat">
                            <span class="stat-label">Plays</span>
                            <span class="stat-value">${numPlays}</span>
                        </div>` : ''}
                        ${visibleFields.includes('bayesaverage') ? `<div class="stat">
                            <span class="stat-label">Weighted Avg</span>
                            <span class="stat-value">${bayesAvg}</span>
                        </div>` : ''}
                        ${visibleFields.includes('avgRating') ? `<div class="stat">
                            <span class="stat-label">Avg Rating</span>
                            <span class="stat-value">${avgRating}</span>
                        </div>` : ''}
                        ${visibleFields.includes('rank') ? `<div class="stat">
                            <span class="stat-label">Rank</span>
                            <span class="stat-value">${rank}</span>
                        </div>` : ''}
                        ${visibleFields.includes('weight') ? `<div class="stat">
                            <span class="stat-label">Weight</span>
                            <span class="stat-value">${weight}</span>
                        </div>` : ''}
                        ${visibleFields.includes('avgWeight') ? `<div class="stat">
                            <span class="stat-label">Avg Weight</span>
                            <span class="stat-value">${avgWeight}</span>
                        </div>` : ''}
                        ${visibleFields.includes('playTime') ? `<div class="stat">
                            <span class="stat-label">Play Time</span>
                            <span class="stat-value">${playTime} min</span>
                        </div>` : ''}
                        ${visibleFields.includes('players') ? `<div class="stat">
                            <span class="stat-label">Players</span>
                            <span class="stat-value">${minPlayers === '-' || maxPlayers === '-' ? '-' : `${minPlayers} - ${maxPlayers}`}</span>
                        </div>` : ''}
                        ${visibleFields.includes('bestPlayers') ? `<div class="stat">
                            <span class="stat-label">Best Players</span>
                            <span class="stat-value">${bestPlayers}</span>
                        </div>` : ''}
                        ${visibleFields.includes('recPlayers') ? `<div class="stat">
                            <span class="stat-label">Rec. Players</span>
                            <span class="stat-value">${recPlayers}</span>
                        </div>` : ''}
                        ${visibleFields.includes('year') ? `<div class="stat">
                            <span class="stat-label">Year</span>
                            <span class="stat-value">${year}</span>
                        </div>` : ''}
                        ${visibleFields.includes('dateAdded') ? `<div class="stat">
                            <span class="stat-label">Date Added</span>
                            <span class="stat-value">${invDate}</span>
                        </div>` : ''}
                        ${visibleFields.includes('price') ? `<div class="stat">
                            <span class="stat-label">Price</span>
                            <span class="stat-value">${price}</span>
                        </div>` : ''}
                        ${visibleFields.includes('itemType') ? `<div class="stat">
                            <span class="stat-label">Item Type</span>
                            <span class="stat-value">${itemType}</span>
                        </div>` : ''}
                        ${visibleFields.includes('acquiredFrom') ? `<div class="stat">
                            <span class="stat-label">Acquired From</span>
                            <span class="stat-value">${acquiredFrom}</span>
                        </div>` : ''}
                        ${visibleFields.includes('customScore') ? `<div class="stat">
                            <span class="stat-label">Custom Score</span>
                            <span class="stat-value">${customScore}</span>
                        </div>` : ''}
                    </div>
            `;
            grid.appendChild(card);
        }

        function toggleCardExpansion(element) {
            if (!isSimpleView) return;
            const card = element.closest('.game-card');
            card.classList.toggle('expanded');
        }

        function applyFiltersAndSort() {
            let filteredGames = [...allGames];
            
            // Calculate weight thresholds based on ALL games for consistent filtering
            weightThresholds = calculateWeightThresholds(allGames);

            // Apply filters
            const nameQuery = nameFilter.value.toLowerCase();
            if (nameQuery) {
                filteredGames = filteredGames.filter(game => game.objectname && game.objectname.toLowerCase().includes(nameQuery));
            }

            const yearQuery = yearFilter.value;
            if (yearQuery) {
                filteredGames = filteredGames.filter(game => game.yearpublished == yearQuery);
            }

            const playersQuery = playersFilter.value;
            if (playersQuery) {
                filteredGames = filteredGames.filter(game => 
                    game.minplayers && game.maxplayers &&
                    parseInt(game.minplayers, 10) <= playersQuery && 
                    parseInt(game.maxplayers, 10) >= playersQuery
                );
            }

            const bestPlayersQuery = bestPlayersFilter.value.trim();
            if (bestPlayersQuery) {
                const filterValues = bestPlayersQuery.split(',').map(p => parseInt(p.trim())).filter(p => !isNaN(p));
                if (filterValues.length > 0) {
                    filteredGames = filteredGames.filter(game => 
                        matchesPlayerList(game.bggbestplayers, filterValues)
                    );
                }
            }

            const recPlayersQuery = recPlayersFilter.value.trim();
            if (recPlayersQuery) {
                const filterValues = recPlayersQuery.split(',').map(p => parseInt(p.trim())).filter(p => !isNaN(p));
                if (filterValues.length > 0) {
                    filteredGames = filteredGames.filter(game => 
                        matchesPlayerList(game.bggrecplayers, filterValues) || 
                        matchesPlayerList(game.bggbestplayers, filterValues)
                    );
                }
            }

            const playtimeQuery = playtimeFilter.value;
            if (playtimeQuery) {
                if (playtimeQuery === '0') {
                    filteredGames = filteredGames.filter(game => parseInt(game.playingtime) === 0);
                } else if (playtimeQuery === '120+') {
                    filteredGames = filteredGames.filter(game => parseInt(game.playingtime) > 120);
                } else {
                    const maxTime = parseInt(playtimeQuery);
                    filteredGames = filteredGames.filter(game => {
                        const time = parseInt(game.playingtime);
                        return !isNaN(time) && time > 0 && time <= maxTime;
                    });
                }
            }

            const weightCategoryQuery = weightCategoryFilter.value;
            if (weightCategoryQuery && weightThresholds) {
                const categoryMap = {
                    'light': 'light',
                    'medium-light': 'mediumLight',
                    'medium': 'medium',
                    'medium-heavy': 'mediumHeavy',
                    'heavy': 'heavy'
                };
                const category = categoryMap[weightCategoryQuery];
                if (category) {
                    filteredGames = filteredGames.filter(game => isInWeightCategory(game, category));
                }
            }

            const statusQuery = statusFilter.value;
            if (statusQuery) {
                filteredGames = filteredGames.filter(game => {
                    const statusValue = game[statusQuery];
                    return statusValue === '1' || statusValue === 1 || statusValue === true;
                });
            }

            // Apply sorting
            const [sortKey, sortOrder] = sortBy.value.split('_');
            filteredGames.sort((a, b) => {
                let valA, valB;
                
                // Special handling for custom score
                if (sortKey === 'customscore') {
                    valA = calculateCustomScore(a);
                    valB = calculateCustomScore(b);
                } else {
                    valA = a[sortKey];
                    valB = b[sortKey];
                }

                // Handle numeric sorting for relevant fields
                const numericKeys = ['rating', 'baverage', 'average', 'rank', 'numplays', 'weight', 'playingtime', 'yearpublished', 'pricepaid', 'customscore', 'avgweight'];
                if (numericKeys.includes(sortKey)) {
                    valA = parseFloat(valA || 0);
                    valB = parseFloat(valB || 0);
                } else if (typeof valA === 'string') {
                    valA = valA.toLowerCase();
                    valB = valB.toLowerCase();
                }
                
                if (valA < valB) return sortOrder === 'asc' ? -1 : 1;
                if (valA > valB) return sortOrder === 'asc' ? 1 : -1;
                return 0;
            });

            renderGames(filteredGames);
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            // Load field settings from localStorage
            loadFieldSettings();
            
            // Setup infinite scroll
            setupInfiniteScroll();
            
            // Setup customize fields button
            customizeFieldsToggle.addEventListener('click', openFieldModal);
            
            // Close modal when clicking outside
            fieldModal.addEventListener('click', (e) => {
                if (e.target === fieldModal) {
                    closeFieldModal();
                }
            });
            
            fetch('collection.csv')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(csvText => {
                    allGames = parseCSV(csvText);
                    applyFiltersAndSort(); // Initial render
                })
                .catch(error => {
                    console.error('Error fetching or parsing collection.csv:', error);
                    noResultsMsg.textContent = 'Error loading game collection. Please check console.';
                    noResultsMsg.style.display = 'block';
                });

            // Event Listeners
            nameFilter.addEventListener('input', applyFiltersAndSort);
            yearFilter.addEventListener('input', applyFiltersAndSort);
            playersFilter.addEventListener('input', applyFiltersAndSort);
            bestPlayersFilter.addEventListener('input', applyFiltersAndSort);
            recPlayersFilter.addEventListener('input', applyFiltersAndSort);
            playtimeFilter.addEventListener('change', applyFiltersAndSort);
            weightCategoryFilter.addEventListener('change', applyFiltersAndSort);
            statusFilter.addEventListener('change', applyFiltersAndSort);
            sortBy.addEventListener('change', applyFiltersAndSort);
            
            // View toggle
            viewToggle.addEventListener('click', () => {
                isSimpleView = !isSimpleView;
                viewToggle.textContent = isSimpleView ? 'Switch to Full View' : 'Switch to Simple View';
                applyFiltersAndSort(); // Re-render with new view mode
            });
        });
    </script>

</body>
</html>
